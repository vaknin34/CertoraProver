/*
 *     The Certora Prover
 *     Copyright (C) 2025  Certora Ltd.
 *
 *     This program is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU General Public License as published by
 *     the Free Software Foundation, version 3 of the License.
 *
 *     This program is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU General Public License for more details.
 *
 *     You should have received a copy of the GNU General Public License
 *     along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

package sbf.domains

import sbf.*
import sbf.disassembler.*
import sbf.callgraph.*
import sbf.cfg.*
import sbf.support.*
import kotlin.math.absoluteValue
import datastructures.stdcollections.*
import org.jetbrains.annotations.TestOnly

/**
 * Pointer analysis based on the paper
 * "A Context-Sensitive Memory Model for Verification of C/C++ Programs" SAS 2017.
 *
 * The pointer analysis builds an explicit points-to graph (class `PTAGraph`).
 *  - A **node** (class `PTANode`) in the graph is a struct with fields (each field denoted by a numerical offset and width)
 *  - A **cell** (class `PTACell`) is a pair of a node and offset.
 *  - An **edge** in the graph connects cells.
 *
 *  The points-to graph is unification-based and therefore, a cell can only have at most one outgoing edge.
 *
 *  Unlike the SAS paper, this implementation is *partially* flow-sensitive so that strong updates are possible when:
 *  1) reassigning a register
 *  2) reassigning a stack slot (i.e., local variable)
 *
 *  Recall that a SBF program has access to a set of Registers and 4 (disjoint) memory regions:
 *  Stack, Input, Heap, and Globals. When a SBF program is called all memory regions have been already
 *  allocated so there is no explicit allocation sites (*) for these memory areas.
 *
 *  (*) This is true if the Heap area is accessed directly via absolute addresses in the range
 *      [0x300000000, 0x300001000), but Heap memory can be also accessed via malloc-like calls in which case
 *      there are allocation sites.
 *
 * *  How a graph node is created?
 *
 *    1) For Heap, via malloc-like calls.
 *    2) At a memory read, the analysis allocates a node if there is not a node yet (under the assumption that memory
 *       is properly initialized). Since we cannot know which memory region that node belongs to, the analysis has
 *       also the concept of **External** memory region that represents all the memory allocated **outside** the program
 *       under analysis. There are two main sources of external memory: memory that belongs to Input, but it is
 *       allocated before the program under analysis is executed or after some deserialization, and
 *       memory allocated by functions whose code is not available.
 *
 *  Currently, the analysis keeps track of one `PTAGraph` per block, but it's only partially flow-sensitive (see below how):
 *  - Each register (normal and scratch ones) is mapped to a `PTACell`.
 *  - Stack is represented by a special `PTANode`.
 *  - The rest of nodes are **shared**, and they belong to one of these regions:
 *    - Input is the memory area that represents the inputs to the program.
 *    - Heap represents the range of addresses [0x300000000, 0x300001000).
 *      It can be accessed via two incompatible methods:
 *      (1) de-referencing absolute address in that range (no explicit allocation sites) or
 *      (2) via system calls such as `calloc` or `sol_alloc_free`.
 *    - Globals consists of read-only global variables such as constant strings. The disassembler identifies them.
 *    - External consists of all memory allocated outside the program.
 *
 *  How do we achieve partial flow-sensitivity?
 *
 *  Each time a PTAGraph is copied, a new copy of the Stack PTANode (and its outgoing links) is done.
 *  Similarly, with normal and scratch registers. The rest of the PTAGraph (Input, Heap, Globals, and External)
 *  is shared among copies. In this way, both registers and stack slots can be re-assigned (i.e., strong updates)
 *  while other memory writes are modeled by weak updates.
 *
 *  Soundness Assumptions
 *
 *  1) The pointer analysis assumes that the program is **memory safe**. This has several implications:
 *      - There are infinite gaps between points-to graph nodes. This means that we cannot jump from one node
 *        to another via pointer arithmetic.
 *      - Memory is properly initialized, so we cannot get dangling pointers from reading memory.
 *      - Null pointers and pointers generated by the Rust `dangling()` function
 *        (https://doc.rust-lang.org/std/ptr/struct.NonNull.html).
 *
 *        The Rust `dangling()` function returns a `NonNull::dangling` pointer which is a pointer that is not null,
 *        but it's not de-referenceable. This type is used to represent pointers to Zero Sized Types (ZST)
 *        (https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts).
 *
 *        In LLVM IR, the `dangling()` function is implemented as an `inttoptr` instruction that casts a small
 *        power-of-two integer to a pointer. In SBF, we don't have explicit casts, so a register can be either
 *        a small power-of-two integer or a properly allocated pointer.
 *        However, under the assumption of memory safety, if that register is ultimately de-referenced then
 *        the path condition that makes the register to be a small power-of-two must be false.
 *
 *  2) If Heap memory region is accessed via explicit malloc-like calls then we assume that each call returns a
 *     pointer to a fresh memory object and pointers returned by calls to malloc cannot alias.
 *
 *  3) Each allocation from External region assumes no-aliasing with previous external allocations,
 *     and external memory is non-deterministically initialized.
 *
 **/

// For debugging purposes
private const val debugPTAJoin = false
private const val debugPTALeq = false
private const val debugPTASimMapperFail = false
private const val debugPTAUnify = false
//const val debugPTACloning = false
private const val debugPTACollapses = false
private const val debugPTAMemTransfer = false
// Need more testing: disabled for now.
private const val useSummarizeNodeWithStride = false
// Enable pointer analysis warnings (it can be very verbose)
private const val enablePTAWarnings = false

/** For internal errors **/
@TestOnly
class PointerDomainError(msg: String): SolanaInternalError("PointerDomain error: $msg")

/**
 * The pointer domain manipulates two kind of offsets: concrete (PTAOffset) and
 * symbolic ones (PTASymOffset).
 *
 * - Concrete offsets are used to model edges between nodes.
 * - Symbolic offsets are used to model edges between registers and nodes.
 *   With concrete offsets, we need to summarize **eagerly** a node if we don't know the exact offset
 *   to which a register points to.
 *   However, summarization is unnecessary if the register is not used later to read or write into
 *   memory but instead to do pointer comparison. Symbolic offsets can remember where a register points
 *   which allows us to do summarization **lazily** when strictly needed.
 *
 * Using symbolic offsets to model edges between nodes is possible, but we would need to know when two
 * offsets can overlap. With concrete offsets check for overlapping is trivial.
 **/
typealias PTAOffset = Long
typealias PTASymOffset = ConstantOffset /** Long extended with top **/

private fun ptaWarning(msg: () -> Any) {
    if (enablePTAWarnings) {
        sbfLogger.warn(msg)
    }
}

/**
 * A concrete cell: this is just a wrapper to a pair of node and offset.
 * Only PTANode should create PTACell instances.
 **/
sealed class PTACell(open val node: PTANode, open val offset: PTAOffset) {
    // Unify n1 at offset o1 with n2 at offset o2
    // let's assume o1 < o2 (the other case is symmetric)
    // The idea is to unify (n1,0) with (n2, o2-o1).
    // Then, we unify recursively each (n1,oi) to (n2, o2-o1 +oi)

    // API for TAC encoding
    @Suppress("ForbiddenComment")
    // FIXME: we don't do path compression
    fun resolve(): PTACell {
        val forwardC = node.forward
        return if (forwardC == null) {
            this
        } else {
            if (node.isMayStack) {
                throw PointerDomainError("A node that might represent the stack shouldn't not be unified")
            }
            val resolvedC = forwardC.resolve()
            resolvedC.node.createCell(resolvedC.offset + offset)
        }
    }

    /**
     *  Unify this with other.
     *  @param cache is used to make sure that two nodes are not unified twice
     */
    fun unify(other: PTACell,
              cache: MutableMap<PTANode, PTANode> = mutableMapOf()) {
        if (this == other) {
            if (debugPTAUnify) {
                sbfLogger.info {"\t\tSkipped unification of $this with itself\n"}
            }
            return
        }

        val c1 = this
        val c2 = other
        val o1 = c1.offset // no adjusted by the kind of node
        val o2 = c2.offset // no adjusted by the kind of node
        val n1 = c1.node
        val n2 = c2.node

        if (debugPTAUnify) {
            sbfLogger.info {"\tStarted unification of $c1 with $c2\n"}
        }
        if (o1 > o2) {
            // unify (n2,0) and (n1,o1-o2)
            n2.unify(n1, o1-o2, cache)
        } else if (o1 < o2){
            // unify (n1,0) and (n2,o2-o1)
            n1.unify(n2, o2-o1, cache)
        } else {
            if (n1.numOfPredecessors() > n2.numOfPredecessors()) {
                n2.unify(n1, 0, cache)
            } else {
                n1.unify(n2, 0, cache)
            }
        }
        if (debugPTAUnify) {
            sbfLogger.info { "\tFinished unification of $c1 with $c2\n"}
        }

    }

    fun renameNode(oldNode: PTANode, newNode: PTANode): PTACell {
        return if (node == oldNode) {
            newNode.createCell(offset)
        } else {
            this
        }
    }

    fun lessOrEqual(other: PTACell): Boolean {
        return if (this == other) {
            true
        } else {
            // For ordering, all integers are indistinguishable from each other
            node.mustBeInteger() && other.node.mustBeInteger()
        }
    }

    fun createSymCell() = node.createSymCell(PTASymOffset(offset))

    fun getFields(): List<PTAField> {
        val out = mutableListOf<PTAField>()
        for (size in usedMemoryBitwidths) {
            val field = PTAField(offset, size.toShort())
            val succ = node.getSucc(field)
            if (succ != null) {
                out.add(field)
            }
        }
        return out
    }

    /**
     * Return true if all fields in the range [offset, offset+[length]-1]
     * are compatible with [wordSize].
     *
     * A field f within the above range is compatible with [wordSize] if
     *   1. f.size == [wordSize], and
     *   2. The distance from f.offset to offset is a multiple of [wordSize]
     *
     * Note that condition 2 is weaker than imposing that f.offset is aligned with [wordSize]
     * (i.e., f.offset % [wordSize] == 0)
     */
    fun isWordCompatible(length: Long, wordSize: Byte): Boolean {
        if (!node.isExactNode()) {
            return false
        } else if (length <= 0 || length.mod(wordSize.toInt()) != 0) {
            return false
        } else {
            if (SolanaConfig.OptimisticMemcmp.get()) {
                return true
            }
            val links = node.getLinksInRange(offset, length).filter {
                if (SolanaConfig.OptimisticPTAOverlaps.get()) {
                    // due to optimisticOverlaps we can have multiple fields at the same offset
                    // with different bit widths. isWordCompatible will not return false if one
                    // of those fields is word-compatible.
                    it.first.size == wordSize.toShort()
                } else {
                    true
                }
            }

            if (links.isEmpty()) {
                return true
            }
            val first = links.first().first.offset
            for ((field, _) in links) {
                val offset = field.offset
                check(offset >= first) {"$links is not sorted as expected"}
                if ((offset - first).mod(wordSize.toInt()) != 0) {
                    return false
                }
                if (field.size != wordSize.toShort()) {
                    return false
                }
            }
            return true
        }
    }

    /** Unused functionality but don't remove yet **/
    fun import(importer: PTAGraphImporter): PTACell {
        return node.import(importer).createCell(offset)
    }

    override fun toString(): String = "($node,$offset)"
}

/**
 *  A symbolic cell: wrapper for a node and a symbolic offset.
 *  A symbolic cell is always convertible to a concrete cell (PTACell) via `reify` operation.
 *  Only PTANode should create PTASymCell instances.
 **/
sealed class PTASymCell(open val node: PTANode, open val offset: PTASymOffset) {

    fun isReified() = offset.get() != null

    // Return a concrete cell where the node is summarized if the offset is top
    fun reify(): PTACell {
        val concreteOffset = offset.get()
        return if (concreteOffset != null) {
            node.createCell(concreteOffset)
        } else {
            if (debugPTACollapses) {
                sbfLogger.info { "LOSING FIELD-SENSITIVITY (reification): begin summarizing node ${node.id}"}
            }

            // We don't need to rename stack nodes because smashing should not
            // affect a stack node. Note that we throw an exception if it does.
            val zeroOffset = PTAGraph.mkOffset(0L)
            val smashedNode = if (useSummarizeNodeWithStride) {
                PTANode.summarizeWithStride(node, 1U)
            } else {
                PTANode.smash(node)
            }
            val res =  smashedNode.createCell(zeroOffset)
            node.forward = res

            if (debugPTACollapses) {
                sbfLogger.info { "LOSING FIELD-SENSITIVITY (reification): end summarizing node " +
                    "${node.id} with ${smashedNode.id}"}
            }
            res
        }
    }

    fun renameNode(oldNode: PTANode, newNode: PTANode): PTASymCell {
        return if (node == oldNode) {
            newNode.createSymCell(offset)
        } else {
            this
        }
    }

    fun lessOrEqual(other: PTASymCell): Boolean {
        return if (node == other.node && offset.lessOrEqual(other.offset)) {
            true
        } else {
            // For ordering, all integers are indistinguishable from each other
            node.mustBeInteger() && other.node.mustBeInteger()
        }
    }

    fun getPTACell(): PTACell {
        if (!isReified()) {
            throw PointerDomainError("The cell needs to be reified before calling getPTACell")
        }
        return node.createCell(offset.get()!!)
    }
    override fun toString(): String  = "($node,$offset)"

    /** Unused functionality but don't remove yet **/
    fun import(importer: PTAGraphImporter): PTASymCell {
        return node.import(importer).createSymCell(offset)
    }
}

/**
 * A PTAField represents the sequence of bytes [offset,...,offset+size-1]
 **/
data class PTAField(val offset: PTAOffset, val size: Short): Comparable<PTAField>  {
    override fun compareTo(other: PTAField): Int {
        // lexicographical order
        val r1 = offset.compareTo(other.offset)
        return if (r1 != 0) {
            r1
        } else {
            size.compareTo(other.size)
        }
    }
    override fun toString() = "${offset}:*i${size*8}"

    fun toInterval() =  FiniteInterval.mkInterval(offset, size.toLong())
}

/**
 * Another wrapper so that a register can be considered as a predecessor of a PTACell
 * in a PTAGraph. The key benefit is that the register will be updated after any redirection.
 **/
abstract class PTAGraphPred {
    abstract fun samePredecessor(other: PTAGraphPred): Boolean

    /**
     *  This class represents a **mutable** reference to parent[idx].
     *  The goal of parent[idx] is to keep track of a cell even when it's redirected to another
     *  cell via unification.
     **/
    class MutablePTASymCellRef(private val parent: ArrayList<PTASymCell?>,
                               private val idx: Int): PTAGraphPred() {

        init {
            check(idx < parent.size) {"Cannot create MutablePTASymCellRef due to out of bounds"}
        }

        // If the symbolic cell is not reified yet, we don't want to reify it.
        // This means that there is a predecessor edge between the register and the symbolic cell
        // at an unknown offset. For convenience, we pretend that the offset is zero.
        private fun getConcreteOffset(c: PTASymCell): PTAOffset {
            return if (c.isReified()) {
                c.getPTACell().offset
            } else {
                0
            }
        }

        fun set(c: PTASymCell?) {
            if (idx >= parent.size) {
                throw PointerDomainError("out of bounds set access to $this")
            }
            parent[idx] = c
            c?.node?.addPred(getConcreteOffset(c), this)
        }

        fun update(c: PTASymCell?) {
            val oldC = get()
            // remove this as predecessor of oldC
            oldC?.node?.removePred(getConcreteOffset(oldC), this)
            set(c)
        }

        fun get(): PTASymCell? {
            if (idx >= parent.size) {
                throw PointerDomainError("out of bounds get access to $this")
            }
            return parent[idx]
        }

        override fun toString() = "MutablePTASumCellRef($${System.identityHashCode(parent)}, $idx)"

        override fun samePredecessor(other: PTAGraphPred): Boolean {
            return if (other !is MutablePTASymCellRef) {
                false
            } else {
                // the use of === is intentional
                (parent === other.parent && idx == other.idx)
            }
        }
    }

    data class Cell(val node: PTANode, val f: PTAField): PTAGraphPred() {
        override fun toString() = "($node,$f)"
        override fun samePredecessor(other: PTAGraphPred): Boolean {
            return if (other !is Cell) {
                false
            } else {
                (node == other.node && f == other.f)
            }
        }
    }
}
enum class NodeAccess(val value: Int) {
    None(0x0),
    Read(0x1),
    Write(0x2),
    Any(0x3);
    companion object {
        val values = arrayListOf(None, Read, Write, Any)
    }
    fun join(other: NodeAccess): NodeAccess {
        return values[value.or(other.value)]
    }
}

/**
 * PTANode is a struct of fields that can point to other nodes' offsets (PTACell).
 * In this class, all the fields are tracked precisely (see below PTASummarizedNode when fields
 * are not known statically).
 * A PTANode can be only allocated by PTANodeAllocator which is global.
 **/
open class PTANode constructor(val id: ULong,
                               val nodeAllocator: PTANodeAllocator) {
    // whether this node is from the stack area. This is may information
    var isMayStack: Boolean = false
    // whether this node is a global variable. This is may information
    var isMayGlobal: Boolean = false
    // whether this node is from the heap area. This is may information
    var isMayHeap: Boolean = false
    // whether this node is allocated outside the program under analysis. This is may information
    var isMayExternal: Boolean = false
    // whether this node represents an integer. This is may information.
    var isMayInteger: Boolean = false
    // keep track of whether the node has been written, read, or none.
    var access: NodeAccess = NodeAccess.None

    // When the node is unified, the memory cell at which the
    // node begins in some other memory object
    // For now, we will use it only for TAC encoding.
    var forward: PTACell? = null

    /**
     * @property preds is indexed by PTAOffset. It is used during redirection of edges as part of cell
     * unification.
     **/
    private val preds: MutableMap<PTAOffset, ArrayList<PTAGraphPred>> = MutableNonInjectiveMap(
        mutableMapOf()) { o -> offsetEquivClass(o) }
    /**
    * @property succs is indexed by PTAField so that we could have multiple edges between the same
    * two cells: one per PTAField. It is a sorted map so that we can detect overlaps efficiently.
    **/
    private val succs: MutableMap<PTAField, PTACell> = MutableNonInjectiveMap(
        sortedMapOf()) { f -> fieldEquivClass(f) }

    /* "Non-injective" because i != j does not imply m[i] !== m[k] (note that this is reference inequality) */
    private inner class MutableNonInjectiveMap<K,V>(
        private val theMap: MutableMap<K, V>,
        private val mapper: PTANode.(K) -> K,
    ): MutableMap<K, V> by theMap {
        override fun remove(key: K): V? = theMap.remove(mapper(key))
        override fun putAll(from: Map<out K, V>) = theMap.putAll(from.mapKeys { mapper(it.key) })
        override fun put(key: K, value: V): V? = theMap.put(mapper(key), value)
        override fun get(key: K): V? = theMap[mapper(key)]
        override fun containsKey(key: K): Boolean = theMap.containsKey(mapper(key))
    }

    private fun checkEdgeConsistency(msg: String) {
        if (!SolanaConfig.SanityChecks.get()) {
            return
        }
        fun succsToStr(node: PTANode): String {
            val sb = StringBuilder()
            sb.append("")
            for ((field, succC) in node.getSuccs()) {
                sb.append("$field:$succC|")
            }
            return sb.toString()
        }

        for ((offset, preds) in getPreds()) {
            val dstC = createCell(offset)
            for (srcC in preds) {
                when (srcC) {
                    is PTAGraphPred.Cell -> {
                        if (srcC.node.getSuccs()[srcC.f] != dstC) {
                            throw PointerDomainError("$dstC is not a successor of  $srcC. " +
                                "The successors of $srcC are: ${succsToStr(srcC.node)}. $msg")
                        }
                    }
                    is PTAGraphPred.MutablePTASymCellRef -> {
                        if (srcC.get() == null) {
                            throw PointerDomainError("$srcC does not point to any cell so it cannot be " +
                                                     " a predecessor of $dstC. $msg")
                        }
                        if (srcC.get()!!.node != dstC.node) {
                            throw PointerDomainError("$srcC is not a predecessor of $dstC. " +
                                    "The successors of $srcC are: ${succsToStr(srcC.get()!!.reify().node)}. $msg")
                        }
                    }
                    else -> { throw PointerDomainError("unreachable")}
                }
            }
        }

        for ((field, dstC) in getSuccs()) {
            val srcC = createGraphPredCell(field)
            val predCs = dstC.node.getPreds()[dstC.offset]
                    ?: throw PointerDomainError("$srcC does not match with any predecessor of $dstC. $msg")
            if (!(predCs.any {
                        when (it) {
                            is PTAGraphPred.Cell -> it == srcC
                            else -> false
                        }
            })) {
                throw PointerDomainError("Successor from $srcC does not match with any predecessor of $dstC. $msg")
            }
        }
    }

    private fun getField(src: PTAGraphPred.Cell, dst: PTACell): PTAField? {
        val f = src.f
        val c = src.node.getSuccs()[f]
        if (c == dst) {
            return f
        }
        return null
    }

    private fun fieldEquivClass(f: PTAField) = PTAField(offsetEquivClass(f.offset), f.size)

    fun addOffsets(f: PTAField, o: PTAOffset) = addOffsets(f.offset, o)

    open fun offsetEquivClass(o: PTAOffset): PTAOffset  = o

    open fun addOffsets(o1: PTAOffset, o2: PTAOffset): PTAOffset  = o1+o2

    open fun addOffsets(o1: PTAOffset, o2: PTASymOffset): PTASymOffset {
        check(!o2.isBottom()) {"offset cannot be bottom"}
        return if (o2.get() == null) {
            PTASymOffset.makeTop()
        } else {
            PTASymOffset(addOffsets(o1, o2.get()!!))
        }
    }

    open fun isExactNode() = true

    protected data class Cell(override val node: PTANode,
                              override val offset: PTAOffset)
        : PTACell(node, offset) {
            override fun toString(): String = "($node,$offset)"
        }

    open fun createCell(o: PTAOffset): PTACell {
        return Cell(this, offsetEquivClass(o))
    }

    open fun createGraphPredCell(f: PTAField): PTAGraphPred.Cell {
        return PTAGraphPred.Cell(this, fieldEquivClass(f))
    }

    protected data class SymCell(override val node: PTANode,
                                 override val offset: PTASymOffset)
        : PTASymCell(node, offset) {
            override fun toString(): String = "($node,$offset)"
        }

    open fun createSymCell(o: PTASymOffset): PTASymCell {
        return SymCell(this, o)
    }

    // We could cache results
    fun allAccessedFieldsDivisibleBy(stride: Int): Boolean {
        fun divisibleBy(size: Int, strideInBytes: Int): Boolean {
            return (size >= strideInBytes && (size.mod(strideInBytes) == 0))
        }
        for ((field,_) in succs) {
            val size = field.size.toInt()
            if (!divisibleBy(size, stride)) {
                return false
            }
        }
        return true
    }

    /** Return true if o1 and o2 are equal
     * @param o1 is normalized with respect to the type of node that this is
     * @param o2 is **not** normalized.
     **/
    fun equalOffsets(o1: PTAOffset, o2: PTAOffset): Boolean {
        return offsetEquivClass(o1) == o2
    }

    /** Return true if the node must be an integer **/
    open fun mustBeInteger() = isMayInteger && !isMayExternal && !isMayGlobal && !isMayHeap && !isMayStack

    companion object {
        /** Make a summarized node from a non-summarized one.
         * For that, we need to unify all the node's fields
         *
         *  if n is already summarized {
         *      return
         *   }
         *  c = create a fresh cell with offset 0
         *  for each o in fields(n) {
         *     unifyCells(c, (n,o))
         *     remove edge from (n, o)
         *  }
         ***/
        fun smash(n: PTANode, cache: MutableMap<PTANode, PTANode> = mutableMapOf()): PTANode {
            if (n is PTASummarizedNode) {
                return n
            }
            /** We make a summarized node N by creating a fresh node N'
             * and unifying all N's fields with the zero-field of N'.
             * Note that since unify is called, we can recursively smash other nodes.
             **/
            if (debugPTAUnify || debugPTACollapses) {
                sbfLogger.info { "\t### Making $n field insensitive\n" }
            }

            // REVISIT: I think this comment is obsolete and the cache has indeed become unused.
            /**
             * Special case is when a node is reachable through different paths.
             * We use a cache to ensure that given the same N we get the same fresh node N'.
             * Any register or cell pointed to n will be redirected to a new summarized cell.
             */
            var summarizedN = cache[n]
            if (summarizedN == null) {
                summarizedN = n.nodeAllocator.mkSummarizedNode()
                cache[n] = summarizedN
            }

            val summarizedC = summarizedN.createCell(PTAGraph.mkOffset(0L))
            if (debugPTAUnify) {
                sbfLogger.info {"\tStarted redirection $n to ${summarizedC.node}\n"}
            }
            n.redirectEdges(summarizedC.node, summarizedC.offset, cache)
            if (debugPTAUnify || debugPTACollapses) {
                sbfLogger.info {"\tFinished redirection $n to ${summarizedC.node}\n"}
                sbfLogger.info { "\t### Made $n field insensitive\n" }
            }
            return summarizedN
        }

        fun summarizeWithStride(n: PTANode, stride: UInt,
                                cache: MutableMap<PTANode, PTANode> = mutableMapOf()): PTANode {
            if (n is PTASummarizedNode || n is PTASummarizedWithStrideNode) {
                return n
            }
            val summarizedN = n.nodeAllocator.mkSummarizedWithStrideNode(stride)
            val summarizedC = summarizedN.createCell(PTAGraph.mkOffset(0L))
            n.redirectEdges(summarizedC.node, summarizedC.offset, cache)
            return summarizedN
        }

    }

    fun setWrite() {
        // weak update semantics
        access = access.join(NodeAccess.Write)
    }

    fun setRead() {
        // weak update semantics
        access = access.join(NodeAccess.Read)
    }

    fun isUnaccessed(): Boolean {
        return access == NodeAccess.None
    }

    fun isForwarding() = forward != null

    fun numOfPredecessors(): Int {
        var res = 0
        for (p in preds) {
            res += p.value.size
        }
        return res
    }

    /** Redirect all n1's predecessors to n2
    *   for each edge (pred -> (n1,i)) do
    *     add edge (pred -> (n2, o+i))
    **/
    private fun redirectPredecessors(other: PTANode, o: PTAOffset) {
        check(id != other.id) {"Cannot redirect predecessors to itself"}
        /** Remove edge (predC, (this,i)) **/
        val it = preds.iterator()
        while (it.hasNext()) {
            val (i, predCs) = it.next()
            val curC = createCell(i)
            val newC = other.createCell(other.addOffsets(i, o))
            val predIt = predCs.iterator()
            while (predIt.hasNext()) {
                val predC = predIt.next()
                when (predC) {
                    is PTAGraphPred.Cell -> {
                        val field = getField(predC, curC)
                                ?: throw PointerDomainError("Not found an edge from $predC to $curC")
                        /** Add edge (predC, (other,o+i)) **/
                        predC.node.removeSucc(field, curC)
                        predC.node.addSucc(field,  newC)
                        newC.node.addPred(newC.offset, predC)
                    }
                    is PTAGraphPred.MutablePTASymCellRef -> predC.set(newC.createSymCell())
                }
                if (debugPTAUnify) {
                    sbfLogger.info {"\t\tRemoved $predC as predecessor of $curC"}
                }
                predIt.remove()
            }
            it.remove()
        }
    }

    /** Redirect all n1's successors to n2's successors
    *  for each ((n1,i) -> succ) do
    *     if exists (n2, o+i) -> c' // adjusted to whether n2 is exact or not
    *        unifyCells(succ, c')
    *     else
    *        add edge from (n2, o+i) to succ
    **/
    private fun redirectSuccessors(other: PTANode, o: PTAOffset,
                                   cache: MutableMap<PTANode, PTANode>) {
        check(id != other.id) {"Cannot redirect successors to itself"}
        while (succs.iterator().hasNext()) {
           /** Avoid ConcurrentModificationException
            *
            *  it is assigned to succs.iterator() at every iteration because calling to unify (CASE A, below)
            *  can actually remove entries from succs in presence of cycles
            **/
            val it = succs.iterator()
            val (i, succC) = it.next()
            // there is a direct link from (n1,i) to succC
            if (debugPTAUnify) {
                sbfLogger.info {"\t\tProcessing succ of ($this,$i) = $succC\n"}
            }
            // we need to add a new link between (other,j) and succC
            val j = i.copy(offset=other.addOffsets(i.offset, o))
            // but it's important to check whether (other,j) has already a successor.
            // If yes, we need then to unify succC and (other,j)'s successor which we call c3.
            val c3 = other.getSucc(j)
            // Remove the edge between (this,i) and succC
            succC.node.removePred(succC.offset, createGraphPredCell(i))
            it.remove()
            if (debugPTAUnify) {
                sbfLogger.info { "\t\tRemoved $succC as successor of ($this,${i.offset})" }
            }
            if (c3 != null) {
                /** CASE A:
                 *  (this, i) --> succC   ==>   (this,i)
                 *  (other,j) --> c3             c2    --> unify(succC, c3)
                 *
                 * Ensure that (other,j) has always at most one successor.
                 **/
                c3.unify(succC, cache)
            } else {
                /** CASE B:
                 *  (this, i) --> succC   ==>   (this,i)
                 *  (other,j)                   c2    --> succC
                 *
                 * It's safe to add an outgoing edge while iterating on node this' successors because
                 * we know that other is different from this.
                 **/
                other.addSucc(j, succC)
                succC.node.addPred(succC.offset, other.createGraphPredCell(j))
            }
        }
    }

    /** Redirect all edges from this to $other and reset this **/
    private fun redirectEdges(other: PTANode, o: PTAOffset, cache: MutableMap<PTANode, PTANode>) {
        checkEdgeConsistency("Before redirect edges \"source\" node ($id,0)")
        other.checkEdgeConsistency("Before redirect edges \"destination\" (${other.id}, $o)")
        if (isMayStack) {
            throw PointerDomainError("cannot redirect nodes that might represent the program stack")
        }
        if (other.isMayStack) {
            throw PointerDomainError("cannot redirect nodes that might represent the program stack")
        }

        val n1 = this
        val n2 = other
        check(n1.id != n2.id) {"cannot redirect to itself"}

        if (debugPTAUnify) {
            sbfLogger.info {"\tStarted redirection of predecessors of $n1"}
        }
        n1.redirectPredecessors(n2, o)
        if (debugPTAUnify) {
            sbfLogger.info {"\tFinished redirection of predecessors of $n1"}
        }

        if (debugPTAUnify) {
            sbfLogger.info {"\tStarted redirection of successors of $n1"}
        }
        n1.redirectSuccessors(n2, o, cache)
        if (debugPTAUnify) {
            sbfLogger.info {"\tFinished redirection of successors of $n1"}
        }

        n2.isMayStack   = n2.isMayStack   or n1.isMayStack
        n2.isMayGlobal  = n2.isMayGlobal  or n1.isMayGlobal
        n2.isMayHeap    = n2.isMayHeap    or n1.isMayHeap
        n2.isMayExternal= n2.isMayExternal or n1.isMayExternal
        n2.isMayInteger = n2.isMayInteger or n1.isMayInteger

        n2.access = n2.access.join(n1.access)

        if (n1.preds.isNotEmpty()) {
            throw PointerDomainError("node ${n1.id} has a dangling predecessor")
        }
        if (n1.succs.isNotEmpty()) {
            throw PointerDomainError("node ${n1.id} has a dangling successor")
        }
        n1.checkEdgeConsistency("After redirect edges \"source\" node ($id,0)")
        n2.checkEdgeConsistency("After redirect edges \"destination\" (${n2.id}, $o)")
    }

    /**
     *  Unify n1 at offset 0 with n2 at offset o
     *  Upon completion n1 at offset 0 points to (n2,o)
     **/
    fun unify(other: PTANode, o: PTAOffset, cache: MutableMap<PTANode, PTANode>) {
        fun smashAndUnifyWith(n1: PTANode,n2: PTANode, o: PTAOffset) {
            if (debugPTACollapses) {
                sbfLogger.info {"LOSING FIELD SENSITIVITY: unifying Node${n1.id} with collapsed " +
                                 "Node${n2.id}"}
            }
            val summN1 = smash(n1, cache)
            summN1.unify(n2, o, cache)
        }

        checkEdgeConsistency("Unify left node $id")
        other.checkEdgeConsistency("Unify right node ${other.id}")

        val n1 = this
        val n2 = other

        if (n1 is PTASummarizedNode && n2 !is PTASummarizedNode){
            n2.unify(n1, 0, cache)
            return
        } else if (n1 !is PTASummarizedNode && n2 is PTASummarizedNode) {
            // fallback: go to redirect edges
        } else if (n1 is PTASummarizedWithStrideNode  && n2 !is PTASummarizedWithStrideNode) {
            if (!n2.equalOffsets(o, 0L )) {
                // Cannot unify with an array at non-zero offset
                smashAndUnifyWith(n1, n2, o)
                return
            } else {
                n2.unify(n1, o, cache) // flip the arguments and call again
                return
            }
        } else if (n1 !is PTASummarizedWithStrideNode && n2 is PTASummarizedWithStrideNode) {
            if (n2.getStride() == 0U || !n2.equalOffsets(o, 0L)) {
                // Cannot unify with an array at non-zero offset
                smashAndUnifyWith(n1, n2, o)
                return
            } else {
                // toInt() shouldn't overflow because strides cannot be large numbers
                if (n1.allAccessedFieldsDivisibleBy(n2.getStride().toInt())) {
                    // fallback: go to redirect edges
                } else {
                    smashAndUnifyWith(n1, n2, o) // it doesn't matter the order
                    return
                }
            }
        } else if (n1 is PTASummarizedWithStrideNode && n2 is PTASummarizedWithStrideNode) {
            if (n1.getStride() == 0U || n2.getStride() == 0U) {
                smashAndUnifyWith(n1, n2, o) // it doesn't matter the order
                return
            } else {
                val (small, large) = if (n1.getStride() <= n2.getStride()) {
                    Pair(n1, n2)
                } else {
                    Pair(n2, n1)
                }
                if (large.getStride().mod(small.getStride()) != 0U) {
                    smashAndUnifyWith(small, large, o) // it doesn't matter the order
                    return
                } else {
                    if (small.equalOffsets(o, 0L)) {
                        if (small !== this /*n2*/) {
                            // unify by merging into the smaller array
                            n2.unify(n1, o, cache) // flip the arguments and call again
                            return
                        } else {
                            // fallback to redirect edges
                        }
                    } else {
                        smashAndUnifyWith(small, large, o) // it doesn't matter the order
                        return
                    }
                }
            }
        }

        if (n1 == n2) {
            if (debugPTAUnify) {
                sbfLogger.info {"\tUnifying same node $n1 at different offsets\n"}
            }
            if (useSummarizeNodeWithStride && (n1.isExactNode() && o > 0)) {
                val summarizedN = summarizeWithStride(n1, o.toUInt(), cache)
                n1.forward = summarizedN.createCell(0)
            } else {
                if (!n1.equalOffsets(o, 0L)) {
                    if (debugPTACollapses) {
                        sbfLogger.info {
                            "LOSING FIELD SENSITIVITY: unifying same node Node${n1.id} at " +
                                    "different offsets"
                        }
                    }
                    val summarizedN = smash(n1, cache)
                    n1.forward = summarizedN.createCell(0)
                }
            }
        } else {
            check(!(n1 is PTASummarizedNode && n2 !is PTASummarizedNode))
            {"we should not redirect from a summarized node to a non-summarized node"}

            if (debugPTACollapses) {
                if (n1 !is PTASummarizedNode && n2 is PTASummarizedNode) {
                    sbfLogger.info { "LOSING FIELD SENSITIVITY\n\tStarting redirection from $n1 to $n2\n" }
                    sbfLogger.info { "\t### Making $n1 field insensitive\n" }
                }
            }
            n1.forward = n2.createCell(o)
            n1.redirectEdges(n2, o, cache)
        }
    }

    /**
     *  Add a *direct* edge from (this, o) to cell
     *  Used for the transfer function of, for instance, memory stores.
     **/
    fun mkLink(o: PTAOffset, width: Short, cell: PTACell, isStrongUpdate: Boolean = false) {
        if (this is PTASummarizedWithStrideNode) {
            check(width > 0) {"strides are greater than zero"}
            fun gcd(x: UInt, y:UInt):UInt {
                check(x != 0U || y != 0U) {"precondition of gcd is not satisfied"}
                var a = x
                var b = y
                var c:UInt
                while (b > 0U) {
                    c = a.mod(b)
                    a = b
                    b = c
                }
                return a
            }
            this.setStride(gcd(this.getStride(), width.toUInt()))
        }

        val adjustedOffset = offsetEquivClass(o)
        val field = PTAField(adjustedOffset, width)
        val succ = succs[field]
        if (succ == null) {
            addEdge(field, cell)
        } else {
            if (isExactNode() && isStrongUpdate /*flag set by memory domain*/) {
                // Strong update
                addEdge(field, cell)
            } else {
                // Weak update
                succ.unify(cell)
            }
        }
        checkEdgeConsistency("After mklink 1")
        cell.node.checkEdgeConsistency("After mklink 2")
    }

    fun getSucc(field: PTAField): PTACell? {
       return succs[field]
    }

    // Add one edge from (this, field) to succC
    // Note that our PTAGraph is a bidirectional graph.
    // addSucc only adds one direction.
    // Thus, checkEdgeConsistency will fail if it's called after this function.
    private fun addSucc(field: PTAField, succC: PTACell) {
        succs[field] = succC
        if (debugPTAUnify) {
            sbfLogger.info { "\t\tUpdated $succC as successor of ($this, ${fieldEquivClass(field)})" }
        }
    }

    // Add one edge from (this, o) to predC
    // Note that our PTAGraph is a bidirectional graph.
    // addPred only adds one direction.
    // As a result, checkEdgeConsistency will fail if it's called after this function.
    fun addPred(o: PTAOffset, predC: PTAGraphPred) {
        val predecessors = preds[o]
        if (predecessors == null) {
            preds[o] = arrayListOf(predC)
        } else {
            if (!predecessors.any {it.samePredecessor(predC)}) {
                predecessors.add(predC)
            }
        }
        if (debugPTAUnify) {
            sbfLogger.info { "\t\tAdded $predC as predecessor of ($this,${offsetEquivClass(o)})" }
        }
    }

    // Remove one edge from (this, field) to succC
    // Note that our PTAGraph is a bidirectional graph.
    // removeSucc only removes one direction.
    // Thus, checkEdgeConsistency will fail if it's called after this function.
    fun removeSucc(field: PTAField, succC: PTACell) {
        val oldSucc = succs[field]
        if (oldSucc != null) {
            if (oldSucc != succC) {
                throw PointerDomainError("The successor of ($this,${fieldEquivClass(field)}) " +
                                         "is expected to be $succC but instead, it is $oldSucc")
            }
            succs.remove(field)
            if (debugPTAUnify) {
                sbfLogger.info { "\t\tRemoved $oldSucc as successor of ($this, ${fieldEquivClass(field)})" }
            }
        } else {
            if (debugPTAUnify) {
                sbfLogger.info { "\t\tNo successor of ($this, ${fieldEquivClass(field)}) found, so nothing to remove" }
            }
        }
    }

    // Remove one edge from (this, o) to predC
    // Note that our PTAGraph is a bidirectional graph.
    // removePred only removes one direction.
    // Thus, checkEdgeConsistency will fail if it's called after this function.
    fun removePred(o: PTAOffset, predC: PTAGraphPred) {
        val preds = this.preds[o]
        if (preds != null) {
            preds.removeIf { it.samePredecessor(predC) }
            if (preds.isEmpty()) {
                this.preds.remove(o)
            }
        }
        if (debugPTAUnify) {
            sbfLogger.info { "\t\tRemoved $predC as predecessor of ($this,${offsetEquivClass(o)})" }
       }
    }

    // Remove all outgoing and incoming edges from (this, f)
    // Note that our PTAGraph is a bidirectional graph.
    // removeField removed all edges in *both* directions.
    // Thus, checkEdgeConsistency should succeed after this function is executed.
    fun removeField(f: PTAField) {
        checkEdgeConsistency("before removeField")

        fun removeAllPreds(o: PTAOffset) {
            val preds = this.preds[o]
            if (preds != null) {
                val worklist = ArrayList<PTAGraphPred>(preds.size)
                for (p in preds) {
                    worklist.add(p)
                }
                while (worklist.isNotEmpty()) {
                    val p = worklist.removeLast()
                    // remove one direction
                    removePred(o, p)
                    // remove the other direction
                    when (p) {
                        is PTAGraphPred.Cell -> {
                            p.node.removeSucc(p.f, createCell(o))
                        }
                        is PTAGraphPred.MutablePTASymCellRef -> {
                            p.update(createCell(o).createSymCell())
                        }
                    }
                }
            }
        }
        val succC = this.succs[f]
        if (succC != null) {
            // remove one direction
            removeSucc(f, succC)
            // remove the other direction
            succC.node.removePred(succC.offset, createGraphPredCell(f))
        }
        removeAllPreds(f.offset)
        this.succs.remove(f)
        checkEdgeConsistency("after removeField")
    }

    // Add edge from (this, field.offset) to c
    // if (this, field.offset) pointed to another cell c' then the link is removed.
    // Note that our PTAGraph can be seen as a bidirectional graph.
    // addEdge should update *both* directions.
    fun addEdge(field: PTAField, c: PTACell) {
        checkEdgeConsistency("before addEdge")
        val oldSucc = succs[field]
        // add one direction
        succs[field] = c
        if (debugPTAUnify) {
            sbfLogger.info { "\t\tAdded $c as successor of ($this, ${fieldEquivClass(field)})" }
        }
        // add the other direction
        oldSucc?.node?.removePred(oldSucc.offset, createGraphPredCell(field))
        c.node.addPred(c.offset, createGraphPredCell(field))

        checkEdgeConsistency("after addEdge ($this,$field) -> $c")
    }

    // Remove edge from (this, field.offset) to c in *both* directions
    fun removeEdge(field: PTAField,  c: PTACell) {
        checkEdgeConsistency("before addEdge")
        removeSucc(field, c)
        c.node.removePred(c.offset, createGraphPredCell(field))
        checkEdgeConsistency("after addEdge")
    }

    fun getSuccs(): Map<PTAField, PTACell> = succs
    fun getPreds(): Map<PTAOffset, List<PTAGraphPred>>  = preds

    fun copyFlags(other: PTANode) {
        other.isMayStack = isMayStack
        other.isMayGlobal = isMayGlobal
        other.isMayHeap = isMayHeap
        other.isMayExternal = isMayExternal
        other.isMayInteger = isMayInteger
        other.access =  access
    }

    // If sliceFields is null then all fields are copied.
    fun copyAllLinks(other: PTANode, sliceFields: Set<PTAField>?, renameFn: (c: PTACell) -> PTACell) {
        // This function should be only used during initialization of a PTANode
        check(other.succs.isEmpty()) {"copyAllLinks expects empty successors in $other"}
        for ((field, succC ) in succs) {
            if (sliceFields == null || sliceFields.contains(field)) {
                val renamedSuccC = renameFn(succC)
                other.succs[field] = renamedSuccC
                renamedSuccC.node.addPred(renamedSuccC.offset, other.createGraphPredCell(field))
            }
        }
        other.checkEdgeConsistency("After copyAllLinks")
    }

    fun copyLinks(links: List<Pair<PTAField,PTACell>>,
                  adjustedOffset: PTAOffset,
                  notify: (PTAField) -> Unit = {}) {
        for ((field, succC) in links) {
            val adjustedField = field.copy(offset = field.offset + adjustedOffset)
            notify(adjustedField)
            succs[adjustedField] = succC
            succC.node.addPred(succC.offset, createGraphPredCell(adjustedField))
        }
        checkEdgeConsistency("After copyLinks")
    }

    fun removeLinks(links: List<Pair<PTAField, PTACell>>,
                    notify: (PTAField) -> Unit = {}) {
        for ((field,  succC) in links) {
            notify(field)
            removeSucc(field, succC)
            succC.node.removePred(succC.offset, createGraphPredCell(field))
        }
        checkEdgeConsistency("After removeLinks")
    }

    /** Return the range of accessed bytes at field f **/
    fun getAccessedBytes(f: PTAField): FiniteInterval {
        val lb = f.offset
        val ub = f.size.toLong()
        return FiniteInterval.mkInterval(lb, ub)
    }

    // Kotlin iterators are a pain. I cannot access to the current element without calling next()
    // I cannot either call toList() because I want efficient access to previous and next
    // Allocating a new ArrayList is a bad idea, but I don't know a better solution.
    private fun toFieldList(m : Map<PTAField, PTACell>): ArrayList<PTAField> {
        val out = ArrayList<PTAField>(m.size)
        m.forEachEntry {out.add(it.key)}
        return out
    }

    /// Check for **partial** overlaps between this and other.
    fun findOverlaps(other: PTANode): ArrayList<Pair<PTAField, PTAField>> {
        check(isExactNode()) {"failed precondition of findOverlaps"}
        check(other.isExactNode()) {"failed precondition of findOverlaps"}

        val out = ArrayList<Pair<PTAField,PTAField>>()
        /// pre-condition: getSuccs() returns the successors in a sorted manner
        val a1 = toFieldList(getSuccs())
        val a2 = toFieldList(other.getSuccs())
        var i = 0
        var j = 0
        while (i < a1.size && j < a2.size) {
            val i1 = getAccessedBytes(a1[i])
            val i2 = other.getAccessedBytes(a2[j])
            if (i1.lessThan(i2)) {
                i++
            } else if (i2.lessThan(i1)) {
                j++
            } else if (i1 == i2) {
                i++
                j++
            } else {
                check(i1.overlap(i2)) {"unexpected situation in findOverlaps"}
                out.add(Pair(a1[i], a2[j]))
                i++
            }
        }
        return out
    }

    /**
     * Return all pairs (field, succCell) from this node in the range [start, start+size-1]
     * If isStrict is false then pairs whose fields overlap with lower or upper bound of the above range are also included.
     * If onlyPartial is true then we don't include a pair (field, succCell) if the field occupies the whole range.
     *
     * TOIMPROVE: use something similar to C++ lower_bound to avoid a full pass over all successors.
     */
    fun getLinksInRange(start: PTAOffset, size: Long, isStrict: Boolean = true, onlyPartial: Boolean = false)
        : ArrayList<Pair<PTAField, PTACell>>   {
        check(isExactNode()) {"failed precondition of getLinksInRange"}
        // pre-condition: getSuccs() returns the successors in a sorted manner
        // post-condition: result is sorted in the same way that getSuccs()

        val fullRange = FiniteInterval.mkInterval(start, size)
        val links = ArrayList<Pair<PTAField, PTACell>>(getSuccs().size)
        for ((field, succC) in getSuccs()) {
            val fieldRange = getAccessedBytes(field)
            if (fieldRange.lessThan(fullRange)) {
                continue
            }
            if (fullRange.lessThan(fieldRange)) {
                break
            }
            if (onlyPartial && fieldRange == fullRange) {
                continue
            }
            if (isStrict) {
                if (fullRange.l <= fieldRange.l && fieldRange.u <= fullRange.u) {
                    links.add(Pair(field, succC))
                }
            } else {
                if (fieldRange.overlap(fullRange)) {
                    links.add(Pair(field, succC))
                }
            }
        }
        return links
    }

    /**
     * @param other
     * @return a list of pairs where the first element is a field this_field from this and the second is a cover from [other].
     * A cover for this_field is a list of pairs (f, size) where each pair should be interpreted as the interval [f, f+size]
     * such that (1) each pair is disjoint from each other and (2) the list of pairs fully cover the interval represented by
     * this_field.
    */
    private fun findCovers(other: PTANode): ArrayList<Pair<PTAField, ArrayList<Pair<PTAField,ULong>>>> {
        fun isCover(l: List<Pair<PTAField, ULong>>, start: Long, end: Long): Boolean {
            if (l.isEmpty()) {
                return false
            }
            if (l.first().first.offset != start) {
                return false
            }
            val last = l.last()
            if (last.first.offset + last.second.toLong() != end) {
                return false
            }
            for (i in (0 until l.size - 1)) {
                if ((l[i].first.offset + l[i].second.toLong()) != l[i+1].first.offset) {
                    return false
                }
            }
            return true
        }

        check(isExactNode()) {"failed precondition of findOverlaps"}
        check(other.isExactNode()) {"failed precondition of findOverlaps"}
        val out = ArrayList<Pair<PTAField,ArrayList<Pair<PTAField, ULong>>>>()
        /// pre-condition: getSuccs() returns the successors in a sorted manner
        val a1 = toFieldList(getSuccs())
        val a2 = toFieldList(other.getSuccs())
        var i = 0
        var j = 0
        while (i < a1.size && j < a2.size) {
            val i1 = getAccessedBytes(a1[i])
            var i2 = other.getAccessedBytes(a2[j])
            if (i1.lessThan(i2)) {
                i++
            } else if (i2.lessThan(i1)) {
                j++
            } else if (i1 == i2) {
                i++
                j++
            } else {
                // We follow here a generate-and-test approach just for simplicity and also in case
                // we don't need covers but just partitions.
                val partition = ArrayList<Pair<PTAField,ULong>>()
                while (i1.includes(i2) && j < a2.size) {
                    partition.add(Pair(a2[j], i2.size()))
                    j++
                    if (j < a2.size) {
                        i2 = other.getAccessedBytes(a2[j])
                    }
                }
                // i1 is actually a closed-half interval, so we add 1 to the i1.u
                if (isCover(partition, i1.l, i1.u+1)) {
                    out.add(Pair(a1[i], partition))
                }
                i++
            }
        }
        return out
    }

    /**
     *  Split a field F into a set of subfields F1,...,Fn extracted from other
     *
     *  This is done in five steps:
     *  1. let Preds and Succ be the set of predecessors and the successor of F in this
     *  2. Remove F from this
     *  3. Add F1,...,Fn in this
     *  4. Add Succ as the successor of F1,...,Fn in this
     *  5. Add Preds as the predecessors of F1 in this
     */
    fun splitFields(other: PTANode,
                    splitPred: (PTANode, PTAField) -> Boolean,
                    copyLinksFn: (PTAField) -> Unit) {
        for ((field, subFields) in findCovers(other)) {
            check(subFields.isNotEmpty()) {"splitStack expects a non-empty list"}
            if (splitPred(this, field)) {
                // Step 1: get Succ and Preds
                val leftSucc = getSucc(field)
                check(leftSucc != null)
                val leftPreds = preds[field.offset]
                // Step 2: remove field
                removeField(field)
                // Step 3,4
                val newSubfields = ArrayList<Pair<PTAField, PTACell>>()
                for ((subField, _) in subFields) {
                    newSubfields.add(Pair(subField, leftSucc))
                }
                copyLinks(newSubfields, 0, copyLinksFn)
                // Step 5
                if (leftPreds != null) {
                    val newC = createCell(subFields.first().first.offset)
                    while (leftPreds.isNotEmpty()) {
                        when (val pred = leftPreds.removeLast()) {
                            is PTAGraphPred.Cell -> {
                                val predNode = pred.node
                                predNode.addEdge(pred.f, newC)
                            }
                            is PTAGraphPred.MutablePTASymCellRef -> {
                                pred.update(newC.createSymCell())
                            }
                        }
                    }
                }
            }
        }
        checkEdgeConsistency("After splitFields")
    }


    /** JN: don't remove the code for now. It might be useful in the future **/

    /*private fun mayReachableFrom(pred: (PTANode) -> Boolean): Boolean {
        val cache = mutableSetOf<PTANode>()
        return mayReachableFrom(pred, cache)
    }
    private fun mayReachableFrom(pred: (PTANode) -> Boolean, cache: MutableSet<PTANode>): Boolean {
        if (pred(this)) {
            return true
        }
        if (cache.contains(this)) {
            return false
        }
        cache.add(this)
        for (predCells in getPreds().values) {
            return predCells.any {
                when (it) {
                    is PTAGraphPred.Cell -> {
                        it.node.mayReachableFrom(pred, cache)
                    }
                    else -> {
                        false
                    }
                }

            }
        }
        return false
    }*/


    /** Unused functionality but don't remove yet **/
    fun import(importer: PTAGraphImporter): PTANode {
        checkEdgeConsistency("Before cloning $id")
        val res = importer.import(this)
        checkEdgeConsistency("After cloning ${res.id}")
        return res
    }

    override fun equals(other: Any?): Boolean {
        if (other == null) {
            return false
        }
        if (other !is PTANode) {
            return false
        }
        // Node id's are global so this comparison makes sense
        return id == other.id
    }

    override fun hashCode(): Int {
        return id.toInt()
    }

    override fun toString(): String {
        val sb = StringBuilder()
        sb.append("Node${id}[")
        var addSep = false
        if (this is PTASummarizedNode) {
            sb.append("Summary")
            sb.append("|")
        } else if (this is PTASummarizedWithStrideNode) {
            sb.append("Summary(stride=${getStride()})")
            sb.append("|")
        }

        if (this.isMayStack) {
            if (addSep) {
                sb.append(":")
            }
            sb.append("Stack")
            addSep = true
        }
        if (this.isMayExternal) {
            if (addSep) {
                sb.append(":")
            }
            sb.append("Extern")
            addSep = true
        }
        if (this.isMayInteger) {
            if (addSep) {
                sb.append(":")
            }
            sb.append("Int")
            addSep = true
        }
        if (this.isMayGlobal) {
            if (addSep) {
                sb.append(":")
            }
            sb.append("Global")
            addSep = true
        }
        if (this.isMayHeap) {
            if (addSep) {
                sb.append(":")
            }
            sb.append("Heap")
            //addSep = true
        }

        sb.append("<")
        when (this.access) {
            NodeAccess.Any   -> sb.append("RX")
            NodeAccess.Read  -> sb.append("R")
            NodeAccess.Write -> sb.append("X")
            NodeAccess.None  -> sb.append("U")
        }
        sb.append(">]")
        sb.append("(fwd=${forward?.node?.id})")
        return sb.toString()
    }
}

/**
 *  Important: the concept of "summarized" node means that the offsets of a node cannot
 *  be tracked precisely (loss of field-sensitivity). Thus, it has nothing to do with whether
 *  the node represents multiple memory objects.
 *
 *  PTASummarizedNode represents a summarized node with no information about its accessed
 *  fields (i.e., field-insensitive)
 **/
class PTASummarizedNode(id: ULong, nodeAllocator: PTANodeAllocator): PTANode(id, nodeAllocator) {
    override fun isExactNode() = false

    override fun offsetEquivClass(o: PTAOffset) = PTAGraph.mkOffset(0L)

    override fun mustBeInteger() = false

    override fun addOffsets(o1: PTAOffset, o2: PTAOffset) = PTAGraph.mkOffset(0L)

    override fun addOffsets(o1: PTAOffset, o2: PTASymOffset) =
        PTAGraph.mkAbstractOffset(0L)

    override fun createCell(o: PTAOffset) =
        Cell(this, PTAGraph.mkOffset(0)) as PTACell

    override fun createGraphPredCell(f: PTAField) =
        PTAGraphPred.Cell(this, f.copy(offset = PTAGraph.mkOffset(0)))

    override fun createSymCell(o: PTASymOffset) =
        SymCell(this, PTAGraph.mkAbstractOffset(0)) as PTASymCell
}

/**
 * PTASummarizedWithStrideNode represents a summarized node where all read or written fields
 * are divisible by stride. This abstraction doesn't keep track of mis-alignments or overlaps.
 * For instance,
 * - node with read/written fields [4,8) and [8,12),
 * - node with read/written fields [5,9) and [13,14), and
 * - node with read/written fields [4, 8) and [6, 10) have the same abstraction: a summarized
 *   node with stride of 4.
 *
 *   REVISIT(SOUNDNESS): overlapping induces aliasing so missing overlaps might not be sound.
 *
 * @param stride can be zero at constructor time because we need to create PTASummarizedWithStrideNode
 * objects before we can know the stride.
 **/
class PTASummarizedWithStrideNode(private var stride: UInt, id: ULong, nodeAllocator: PTANodeAllocator)
    : PTANode(id, nodeAllocator) {

    fun getStride() = stride

    fun setStride(stride: UInt) {
        check(stride > 0U) {"strides cannot be zero"}
        this.stride = stride
    }

    override fun isExactNode() = false

    override fun mustBeInteger() = false

    override fun offsetEquivClass(o: PTAOffset): PTAOffset {
        return if (stride == 0U) {
            PTAGraph.mkOffset(0L)
        } else {
            // Since stride is always positive the result of mod is also positive
            o.mod(stride.toInt()).toLong()
        }
    }
    override fun addOffsets(o1: PTAOffset, o2: PTAOffset) = PTAGraph.mkOffset(0L)

    override fun addOffsets(o1: PTAOffset, o2: PTASymOffset) =
        PTAGraph.mkAbstractOffset(0L)

    override fun createCell(o: PTAOffset) =
        Cell(this, PTAGraph.mkOffset(0)) as PTACell

    override fun createGraphPredCell(f: PTAField) =
        PTAGraphPred.Cell(this, f.copy(offset = PTAGraph.mkOffset(0)))

    override fun createSymCell(o: PTASymOffset) =
        SymCell(this, PTAGraph.mkAbstractOffset(0)) as PTASymCell
}

/**
 * JN: this code is currently unused because we keep "mostly" one single points-to graph
 * (nodes representing the stack are deep copied), so there is no need to copy one graph into another.
 * I still keep it because it can be useful in the future.
 **/
class PTAGraphImporter(val graph: PTAGraph) {
    private val cloningMap: MutableMap<PTANode, PTANode> = mutableMapOf()

    fun import(node: PTANode): PTANode {
        var clonedNode = cloningMap[node]
        if (clonedNode == null) {
            clonedNode = when (node) {
                is PTASummarizedNode -> {
                    graph.mkSummarizedNode()
                }
                is PTASummarizedWithStrideNode -> {
                    graph.mkSummarizedWithStrideNode(node.getStride())
                }
                else -> {
                    graph.mkNode()
                }
            }
            node.copyFlags(clonedNode)
            // needed here to break cycles
            cloningMap[node] = clonedNode
            for ((field, c) in node.getSuccs()) {
                val clonedCell = c.import(this)
                clonedNode.addEdge(field, clonedCell)
            }
        }
        return clonedNode
    }
}

/**
 *  The expected use of SimulationMapper is to compare two cells (c1, c2) in **two** different graphs
 *  and being able to tell if the subgraph rooted at c1 is over-approximated (simulated)
 *  by the subgraph rooted at c2.
 *
 *  JN: right now the code is unused because we only keep one points-to graph.
 *  I keep the code because it might be useful in the future
**/
@Suppress("unused")
class SimulationMapper {
    // This map is one-to-many
    private val sim: MutableMap<PTANode, MutableMap<PTANode, PTAOffset>> = mutableMapOf()

    // Return true if node n1 is simulated by node n2 at offset o.
    // This means that all cells (n1,i) are also simulated by (n2,o),...,(n2,o+j)
    private fun insert(n1: PTANode, n2: PTANode, o: PTAOffset, onlyAccessed:Boolean): Boolean {
        if (onlyAccessed && n1.isUnaccessed()) {
            // n1 cannot have children since it's not accessed, so we just return true
            return true
        }

        val map = sim[n1]
        if (map != null) {
            val p = map[n2]
            if (p != null) {
                return if (n2.equalOffsets(o, p)) {
                    true
                } else {
                    if (debugPTASimMapperFail) {
                        sbfLogger.info {"EXPLAIN SIMREL FAILURE: asking if ($n1,0) is simulated by ($n2,$o) " +
                                         "but found in the cache that ($n1,0) is simulated by ($n2,$p)"}
                    }
                    // break cycles
                    sim.clear()
                    false
                }
            }
        } else {
            sim[n1] = mutableMapOf()
        }


        if (n2 is PTASummarizedNode) {
            // a field-insensitive node simulates any node
        } else if (n1 is PTASummarizedNode) {
            if (debugPTASimMapperFail) {
                sbfLogger.info {"EXPLAIN SIMREL FAILURE: ${n1.id} is summarized but ${n2.id} is not"}
            }
            sim.clear()
            return false
        } else {
            if (n1 !is PTASummarizedWithStrideNode && n2 is PTASummarizedWithStrideNode) {
                var res = false
                if (n2.equalOffsets(o, 0L) && n2.getStride() > 0U) {
                    // check that n1 is an unfolding of n2
                    // toInt() shouldn't overflow because strides cannot be large numbers
                    res = n1.allAccessedFieldsDivisibleBy(n2.getStride().toInt())
                }
                if (!res) {
                    sim.clear()
                    return false
                }
            } else if (n1 is PTASummarizedWithStrideNode && n2 !is PTASummarizedWithStrideNode) {
                sim.clear()
                return false
            } else if (n1 is PTASummarizedWithStrideNode && n2 is PTASummarizedWithStrideNode) {
                // the two arrays are properly aligned and n2's stride is smaller than n1,
                // and n1 is an unfolding of n2
                var res = false
                if (n2.equalOffsets(o, 0L) && n1.getStride() >0U && n2.getStride() > 0U) {
                    val stride1 = n1.getStride()
                    val stride2 = n2.getStride()
                    res =  (stride1 == stride2) || (stride1 > stride2 && (stride1.mod(stride2) == 0U))
                }

                if (!res) {
                    sim.clear()
                    return false
                }
            }
        }

        // At this point, n1 (at offset 0) is simulated by n2 at offset.
        // Thus, we add n2 into the map and check children recursively.
        sim[n1]!![n2] = n2.offsetEquivClass(o)

        // Check all n1's successors are simulated by some of the n2's successors
        //  for each ((n1,i) -> succ1) do
        //     let succ2 be (n2, o+i) // adjusted to whether n2 is exact or not
        //     if succ2 exists then
        //        return true iff succ1 is simulated by succ2 (recursive call)
        //     else
        //        return false
        for ((i, succ1) in n1.getSuccs()) {
            val n3 = succ1.node
            val o3 = succ1.offset
            val j = n2.addOffsets(i, o)
            val c2 = n2.createCell(j)
            val succ2 = c2.node.getSucc(i.copy(offset = c2.offset))
            if (succ2 != null) {
                val n4 = succ2.node
                val o4 = succ2.offset
                if (n4 is PTASummarizedNode) {
                    if (!insert(n3, n4, PTAGraph.mkOffset(0), onlyAccessed)) {
                        sim.clear()
                        return false
                    }
                } else {
                    if (o3 > o4) {
                        if (debugPTASimMapperFail) {
                            sbfLogger.info {"EXPLAIN SIMREL FAILURE: offset from  ($n3,$o3) > ($n4,$o4)"}
                        }
                        sim.clear()
                        return false
                    } else if (!insert(n3, n4, o4 - o3, onlyAccessed)) {
                        sim.clear()
                        return false
                    }
                }
            } else {
                if (debugPTASimMapperFail) {
                    sbfLogger.info {"EXPLAIN SIMREL FAILURE: ${n1.id} has a successor at $i but ${n2.id} " +
                            "does not at $j"}
                }
                sim.clear()
                return false
            }
        }
        return true
    }

    // Return true c1 is simulated (over-approximated) by c2.
    fun insert(c1: PTACell?, c2: PTACell?, onlyAccessed: Boolean = false): Boolean {
        if (c1 != null && c2 == null) {
            return if (onlyAccessed) {
                c1.node.isUnaccessed()
            } else {
                if (debugPTASimMapperFail) {
                    sbfLogger.info {"EXPLAIN SIMREL FAILURE: right cell is null"}
                }
                false
            }
        } else if (c1 == null) {
            return true
        }

        check(c2 != null)

        val n1 = c1.node
        val n2 = c2.node
        val o1 = c1.offset
        val o2 = c2.offset


        if (c2.node is PTASummarizedNode) {
            return insert(n1, n2, PTAGraph.mkOffset(0), onlyAccessed)
        } else {
            /** if o1 > o2 then c1 cannot be simulated by c2
             *
             *  Example: given n1 and n2 with 3 and 4 fields.
             *        --------         ----------
             *   n1: | x y z |    n2: | a b c d |
             *       ---------        -----------
             *         0 1 2            0 1 2 3
             *
             *  Is (n1,2) simulated by (n2, 1)  (note: offsets start at 0) ?
             *  For that we need to check that:
             *  1. z is simulated by b
             *  2. y is simulated by a
             *  3. but x cannot be simulated by any cell from n2
             **/
            return if (o1 > o2) {
                if (debugPTASimMapperFail) {
                    sbfLogger.info {"EXPLAIN SIMREL FAILURE: $c1 is not simulated by $c2 because $o1 > $o2"}
                }
                false
            } else {
                return insert(n1, n2, o2 - o1, onlyAccessed)
            }
        }
    }

    private fun get(n : PTANode): PTACell? {
        val map = sim[n]
        if (map == null || map.size != 1) {
            // n is not simulated by exactly one node
            if (debugPTASimMapperFail) {
                sbfLogger.info {"EXPLAIN SIMREL FAILURE: simulation relation is not a function for ${n.id}"}
            }
            return null
        }
        check(map.size == 1)
        check(map.iterator().hasNext())
        val (node, offset) = map.iterator().next()
        return node.createCell(offset)
    }

    fun get(c: PTACell): PTACell? {
        val res = get(c.node)
        return res?.node?.createCell(res.offset + c.offset)
    }

}


/**
 * Allocate points-to graph nodes.
 **/
class PTANodeAllocator {
    private var value:ULong = 0UL
    private val addressMap: MutableMap<ULong, PTANode> = mutableMapOf()
    // To allocate different nodes per instruction operand (e.g., call argument).
    private val instMap: MutableMap<LocatedSbfInstruction,  MutableMap<Int, PTANode>> = mutableMapOf()
    private val globalsMap: MutableMap<SbfGlobalVariable, PTANode> = mutableMapOf()

    fun mkNode(): PTANode {
        return PTANode(value++, this)
    }

    fun mkSummarizedNode(): PTANode {
        return PTASummarizedNode(value++, this)
    }

    fun mkSummarizedWithStrideNode(stride: UInt): PTANode {
        return PTASummarizedWithStrideNode(stride, value++, this)
    }

    @TestOnly
    fun mkIntegerNode(): PTANode {
        // Don't need (and we shouldn't because we might lose precision) to cache integers
        // because integers do not alias with other integers. This assumes that our disassembler
        // identified all global variables so that global variables are not confused with integers.
        // However, we need to treat specially nodes that contain integers in the inclusion operation
        // to ensure termination of the fixpoint.
        val n = mkNode()
        n.isMayInteger = true
        return n
    }

    /**
     *  Return a cell for [address]
     */
    fun mkCell(address: ULong): PTACell {
        return addressMap.getOrPut(address) { mkNode() }.createCell(0).resolve()
    }

    /**
     *  Return a cell for pair ([locInst], [i])
     */
    fun mkCell(locInst: LocatedSbfInstruction, i: Int = 0): PTACell {
        val indexMap = instMap[locInst]
        return if (indexMap == null) {
            val n = mkNode()
            instMap[locInst] = mutableMapOf(Pair(i,n))
            n.createCell(0)
        } else {
            var n = indexMap[i]
            if (n == null) {
                n = mkNode()
                indexMap[i] = n
                instMap[locInst] = indexMap
                n.createCell(0)
            } else {
                n.createCell(0).resolve()
            }
        }
    }

    /**
     *  Return a cell for [global]
     */
    fun mkCell(global: SbfGlobalVariable): PTACell {
        return globalsMap.getOrPut(global) { mkNode() }.createCell(0).resolve()
    }
}

/** Model an allocation in the Global memory region **/
class GlobalAllocation(private val allocator: PTANodeAllocator) {
    /**
     * Each global variable is modeled by a **different** node.
     * Therefore, we assume that there is no aliasing between global variables.
     **/
    fun alloc(gv: SbfGlobalVariable, offset: ConstantOffset): PTASymCell {
        val c = allocator.mkCell(gv)
        c.node.isMayGlobal = true
        val o = offset.get()
        return if (o != null) {
            c.node.createSymCell(PTAGraph.mkAbstractOffset(o + c.offset))
        } else {
            c.node.createSymCell(PTASymOffset.makeTop())
        }
    }
}

/** Model an allocation in the Heap memory region **/
class HeapAllocation(private val allocator: PTANodeAllocator) {
    /**
     *  In Solana, we cannot use both low- and high-level APIs within the same program
     *  https://docs.solana.com/developing/on-chain-programs/developing-c#heap
     **/
    private var usedLowLevel = false
    private var usedHighLevel = false

    /**
     * Used when heap is accessed via absolute addresses in the range [0x30000000, 0x300001000)
     * @param offset is relative to 0x300000000.
     *
     * We model the whole heap with a single points-to graph node.
     * This ensures sound results but better abstractions will be needed if programs
     * use heavily the heap via absolute addresses.
     */
    fun lowLevelAlloc(offset: ConstantOffset): PTASymCell {
        if (usedHighLevel) {
            throw PointerDomainError("Cannot use both low-level and high-level heap allocation APIs")
        }
        usedLowLevel = true
        val o = offset.get()
        return if (o != null) {
            val c = allocator.mkCell(SBF_HEAP_START.toULong())
            c.node.isMayHeap = true
            c.node.createSymCell(PTAGraph.mkAbstractOffset(o + c.offset))

        } else {
            val c = allocator.mkCell(SBF_HEAP_START.toULong())
            c.node.isMayHeap = true
            c.node.createSymCell(PTASymOffset.makeTop())
        }
    }

    /**
     * Used when heap is accessed via high-level allocation functions such as
     * __rust_alloc, malloc, etc.
     *
     * Unchecked assumption: each time one of these functions is called, it returns either null
     * or a pointer that is disjoint from any other pointer returned by previous calls.
     */
    fun highLevelAlloc(locInst: LocatedSbfInstruction, i: Int = 0): PTASymCell {
        if (usedLowLevel) {
            throw PointerDomainError("Cannot use both low-level and high-level heap allocation APIs")
        }
        usedHighLevel = true

        val c = allocator.mkCell(locInst, i)
        c.node.isMayHeap = true
        return c.createSymCell()
    }
}

/**
 *  Allocates a new node and mark it as "external" indicating that the allocation takes place
 *  outside the code under analysis. This external memory should be allocated in one of Input, Heap, or Global
 *  memory regions, but we cannot tell.
 **/
class ExternalAllocation(private val allocator: PTANodeAllocator) {
    fun alloc(locInst: LocatedSbfInstruction, i: Int = 0): PTASymCell {
        val c = allocator.mkCell(locInst, i)
        c.node.isMayExternal = true
        return c.createSymCell()
    }

    fun alloc(address: ULong): PTASymCell {
        val c = allocator.mkCell(address)
        c.node.isMayExternal = true
        return c.createSymCell()
    }
}

class IntegerAllocation(private val allocator: PTANodeAllocator) {
    fun alloc(locInst: LocatedSbfInstruction, i: Int = 0): PTASymCell {
        val c = allocator.mkCell(locInst, i)
        c.node.isMayInteger = true
        return c.createSymCell()
    }
}

private val usedMemoryBitwidths = listOf(1, 2, 4, 8)

/**
 *  A points-to graph consists of cells PTACell (pair of node PTANode and offset) and edges between cells.
 *  The roots of the graph are (normal and scratch) registers.
 *  That is, cells in the graphs are only accessible directly by registers or by following transitively edges.
 **/
class PTAGraph(/** Global node allocator **/
               val nodeAllocator: PTANodeAllocator,
               init: Boolean = false,
               /**
                *  A field in this set means that the field might point to anywhere (top).
                *  This will allow us to be sound without merging stack fields too eagerly.
                *
                *  Invariant: if a field f in untrackedStackFields then getStack().getSucc(f) == null
                **/
               /* It needs to be "var" because SetUnionDomain is an immutable class but PTAGraph is not */
               private var untrackedStackFields: SetDomain<PTAField> = SetUnionDomain(),
               /** To do allocations depending on the memory region **/
               private val globalAlloc: GlobalAllocation = GlobalAllocation(nodeAllocator),
               private val heapAlloc: HeapAllocation = HeapAllocation(nodeAllocator),
               private val externAlloc: ExternalAllocation = ExternalAllocation(nodeAllocator),
               private val integerAlloc: IntegerAllocation = IntegerAllocation(nodeAllocator)){

    /* Note: why registers and scratchRegisters are not arguments in the constructor.

       When we copy a PTAGraph, the cells to which registers and scratchRegisters point to need to be renamed,
       so that the node that represents the old stack is replaced with a fresh node that represents the new stack.
       So there is kind of egg-chicken problem here because we need to know which node is the new stack node
       to do the renaming but this is not known until we call the PTAGraph constructor.
       By excluding registers and scratchRegisters from the constructor parameters, we can initialize the PTAGraph
       in several steps solving the above-mentioned problem.
       Note that a parameter with keyword "lateinit" cannot be in the constructor either.
     */
    /** Contains r1,...,r10
     *  A register can point to either a PTASymCell or null.
     *  Null means here that the register can point to anywhere (i.e., top).
     *  Setting a register to null is always sound because the analysis will throw an exception if a
     *  memory instruction access to a null register.
     **/
    private val registers: ArrayList<PTASymCell?> = ArrayList(NUM_OF_SBF_REGISTERS)
    /** Contains the scratch registers of all callers
     * This is a stack whose size is multiple of 4 which is the number of scratch registers.
     **/
    private val scratchRegisters: ArrayList<PTASymCell?> = arrayListOf()

    init {
        for (i in 0 until NUM_OF_SBF_REGISTERS) {
            registers.add(null)
        }
        if (init) {
            /** This node represents the Stack memory region **/
            val stackNode = mkNode()
            stackNode.isMayStack = true
            setRegCell(Value.Reg(SbfRegister.R10_STACK_POINTER),
                       stackNode.createSymCell(mkAbstractOffset(SBF_STACK_FRAME_SIZE)))
        }
    }

    private fun getIndex(reg: Value.Reg): Int {
        val idx = reg.r.value.toInt()
        if (idx !in (0 until NUM_OF_SBF_REGISTERS)) {
            throw PointerDomainError("register $idx out-of-bounds")
        }
        return idx
    }

    fun getRegCell(reg: Value.Reg): PTASymCell? {
        val idx = getIndex(reg)
        return registers[idx]
    }

    private fun setRegCell(registers: ArrayList<PTASymCell?>, idx: Int, sc: PTASymCell?) {
        // We wrap it into a MutablePTASymCellRef so that registers[idx] is updated correctly
        // as a predecessor of sc
        PTAGraphPred.MutablePTASymCellRef(registers, idx).update(sc)
    }

    fun setRegCell(reg: Value.Reg, sc: PTASymCell?) {
        setRegCell(registers, getIndex(reg), sc)
    }

    private fun pushScratchReg(sc: PTASymCell?) {
        scratchRegisters.add(null)
        if (sc != null) {
            val idx = scratchRegisters.size - 1
            scratchRegisters[idx] = sc
            // We wrap it into a MutablePTASymCellRef so that scratchRegisters[idx] is
            // updated correctly as a predecessor of sc
            PTAGraphPred.MutablePTASymCellRef(scratchRegisters, idx).update(sc)
        }
    }

    private fun popScratchReg(): PTASymCell? {
        val idx = scratchRegisters.size - 1
        val sc = scratchRegisters[idx]
        if (sc != null) {
            // We wrap it into a MutablePTASymCellRef so that scratchRegisters[idx] is not anymore
            // a predecessor of sc
            PTAGraphPred.MutablePTASymCellRef(scratchRegisters, idx).update(null)
        }
        scratchRegisters.removeLast()
        return sc
    }

    private fun getStack(): PTANode {
        val stackC = getRegCell(Value.Reg(SbfRegister.R10_STACK_POINTER))
        check(stackC != null) {"getStack() expects to find the stack node in $this"}
        return stackC.node
    }

    private fun reifyCell(sc: PTASymCell, devMsg: String, locInst: LocatedSbfInstruction?): PTACell {
        if (!sc.isReified() && sc.node == getStack()) {
            throw UnknownPointerDerefError(DevErrorInfo(locInst, null,  devMsg))
        }
        return sc.reify()
    }

    /**
     * Return the result of offset op n.
     **/
    private fun updateOffset(op: BinOp, node: PTANode, offset: PTASymOffset, n: Long): PTASymOffset {
        return when (node) {
            is PTASummarizedNode -> {
                PTASymOffset(0L)
            }
            is PTASummarizedWithStrideNode -> {
                throw PointerDomainError("updateOffset not implemented with PTASummarizedWithStrideNode")
            }
            else -> {
                val nOffset = PTASymOffset(n)
                when (op) {
                    BinOp.ADD -> offset.add(nOffset)
                    BinOp.SUB -> offset.sub(nOffset)
                    else -> throw PointerDomainError("unsupported operation $op for updateOffset")
                }
            }
        }
    }

    /**
     * Return a copy of this but all nodes reachable from this's stack and registers are
     * shared.
     **/
    fun copy(): PTAGraph {
        return copy(registers, scratchRegisters, null)
    }

    // Add a new node into this with same markers and successors than stack
    private fun importStack(stack: PTANode, sliceFields: Set<PTAField>?): PTANode {
        val newNode = when (stack) {
            is PTASummarizedNode -> mkSummarizedNode()
            is PTASummarizedWithStrideNode -> mkSummarizedWithStrideNode(stack.getStride())
            else -> mkNode()
        }
        stack.copyFlags(newNode)
        stack.copyAllLinks(newNode, sliceFields) { c ->
            if (c.node == stack) {
                newNode.createCell(c.offset)
            } else {
                c
            }
        }

        return newNode
    }

    private fun copy(sliceNormalRegisters: ArrayList<PTASymCell?>,
                     sliceScratchRegisters: ArrayList<PTASymCell?>,
                     sliceStackFields: Set<PTAField>?): PTAGraph {

        check(sliceNormalRegisters.size == registers.size)
        { "sliceNormalRegisters should have same size than registers" }
        check(sliceScratchRegisters.size == scratchRegisters.size)
        { "sliceScratchRegisters should have same size than scratchRegisters" }

        // We create a fresh stack node that points to the cells that the old stack pointed to
        val newG = PTAGraph(nodeAllocator, false, untrackedStackFields,
                            globalAlloc, heapAlloc, externAlloc, integerAlloc)
        val oldStack = getStack()
        val newStack = newG.importStack(oldStack, sliceStackFields)
        sliceNormalRegisters.forEachIndexed { i, c ->
            if (c != null) {
                newG.setRegCell(Value.Reg(SbfRegister.getByValue(i.toByte())), c.renameNode(oldStack, newStack))
            }
        }
        sliceScratchRegisters.forEach { c ->
            if (c != null) {
                /**
                 * IMPORTANT: If a scratch register points to a stack node, then the node needs to be updated
                 * each time the scratch register is copied. This is because stacks are flow-sensitive.
                 */
                newG.pushScratchReg(c.renameNode(oldStack, newStack))
            } else {
                newG.pushScratchReg(null)
            }
        }
        return newG
    }

    fun mkNode() = nodeAllocator.mkNode()

    @TestOnly
    fun mkIntegerNode() = nodeAllocator.mkIntegerNode()

    fun mkSummarizedNode() = nodeAllocator.mkSummarizedNode()

    fun mkSummarizedWithStrideNode(stride: UInt): PTANode {
        return nodeAllocator.mkSummarizedWithStrideNode(stride)
    }

    fun reset() {
        for (i in 0 until registers.size) {
            setRegCell(Value.Reg(SbfRegister.getByValue(i.toByte())), null)
        }
        while (scratchRegisters.isNotEmpty()) {
            popScratchReg()
        }
        untrackedStackFields = SetUnionDomain()
    }

    companion object {
        // We keep this function even if it's the identity function so that
        // we can recognize places where we need conceptually convert Long (offsets in SBF) into
        // PTAOffset (offsets in the points-to graph)
        fun mkOffset(value: Long): PTAOffset {
            return value
        }
        fun mkAbstractOffset(value: Long) = PTASymOffset(value)
    }


    /**
     *  Conceptually, this class simply traverses each pair of the list and unifies the first pair element
     *  with the second.
     *
     *  However, when we perform a bunch of unifications {...,(ci, ci'),...,(cj, cj'),...},
     *  the result of unifying cells (ci,ci') can change the nodes to which cj and cj' points to.
     *  However, without special support, cj and cj' will still point to the old nodes.
     *  This class solves the problem by creating mutable references to cells so that all unification
     *  effects are properly propagated.
     */
    private class UnificationBatch(val g: PTAGraph,
                                   l: List<Pair<PTASymCell, PTASymCell>>,
                                   // This function is needed to call PTAGraph::reifyCell
                                   val reificationFn: (PTASymCell, String) -> PTACell) {
        private val batch = ArrayList<Pair<PTAGraphPred.MutablePTASymCellRef,
                                           PTAGraphPred.MutablePTASymCellRef>>()
        // We keep l1 and l2 because batch stores references to them
        private val l1 = ArrayList<PTASymCell?>()
        private val l2 = ArrayList<PTASymCell?>()
        init {
            l.forEachIndexed { i, (c1, c2) ->
                l1.add(null)
                l2.add(null)
                val mutRef1 = PTAGraphPred.MutablePTASymCellRef(l1, i)
                val mutRef2 = PTAGraphPred.MutablePTASymCellRef(l2, i)
                mutRef1.set(c1)
                mutRef2.set(c2)
                batch.add(Pair(mutRef1, mutRef2))
            }
        }

        private fun clear() {
            while (batch.isNotEmpty()) {
                val (mutRef1, mutRef2) = batch.removeLast()
                mutRef1.update(null)
                mutRef2.update(null)
            }
        }

        fun run() {
            batch.forEach { (leftRef,rightRef) ->
                val leftSc = leftRef.get()
                val rightSc = rightRef.get()
                check(leftSc != null && rightSc != null) {"cells are expected to be non-null"}
                val leftC = reificationFn(leftSc, "join")
                val rightC = reificationFn(rightSc, "join")
                if (debugPTAJoin) {
                    sbfLogger.info { "BEFORE UNIFY $leftC with $rightC\nGraph=$g" }
                }
                leftC.unify(rightC)
                if (debugPTAJoin) {
                    sbfLogger.info { "AFTER UNIFY $leftC with $rightC\nGraph=$g" }
                }
            }
            clear()
        }
    }

    /**
     * If some conditions hold, some fields of the stack node from this are split into multiple
     * subfields such that the stack node from this and other have the same fields.
    **/
    fun pseudoCanonicalize(other: PTAGraph) {
        fun splitCond(node: PTANode, field: PTAField): Boolean {
            val succ = node.getSucc(field)
            return succ?.node?.mustBeInteger() ?: false
        }

        if (SolanaConfig.EnablePTAPseudoCanonicalize.get()) {
            val leftStack = getStack()
            val rightStack = other.getStack()
            leftStack.splitFields(rightStack, ::splitCond) { f ->
                untrackedStackFields = untrackedStackFields.remove(f)
            }
        }
    }

    /**
     * Join leftStack with rightStack.
     *
     * The effects of joining the two stacks are stored in onlyLeft, onlyRight, unificationList,
     * and the returned values.
     *
     * ## The join of two stacks has **union semantics** ##
     *
     * This means that if a stack field is defined on leftStack but not in rightStack (or vice-versa) then
     * the joined stack will keep the stack field from leftStack (or rightStack). This is sound under the assumption
     * of memory safety. If memory is properly initialized then it must be the case that the branch on which
     * the field is not defined is infeasible.
     *
     * ## Non-accessed stack field (undefined) vs a stack field pointing to "top" ##
     *
     * If a stack field is not defined (i.e., does not point to a cell) then it means that the stack has not been
     * yet accessed which doesn't mean "top".
     *
     * So when does a stack field become "top"?
     *
     * If leftStack and rightStack has the same field F pointing to their stacks (but different fields) then
     * the cells pointed by F should be stored in unificationList to be unified.
     * However, that would cause the resulting joined stack to be smashed which would not allow to perform
     * the TAC translation. Instead, we mark the field in the joined stack as pointing to "top".
     * As a result, any future access to that field will throw an exception. In many cases, that field is never
     * accessed so the analysis can go on.
     *
     * @param leftStack
     * @param rightStack
     * @param leftUntrackedStackFields: fields in leftStack that point to "top"
     * @param rightUntrackedStackFields: fields in rightStack that point to "top"
     * @param onlyLeft: stack fields defined (accessed) only on leftStack
     * @param onlyRight: stack fields defined (accessed) only on rightStack
     * @param unificationList: stack fields defined in both leftStack and rightStack but pointing to different cells.
     * @return a pair of untracked and tracked stack fields
     */
    private fun joinStacks(/** input parameters **/
                           leftStack: PTANode,
                           rightStack: PTANode,
                           @Suppress("UNUSED_PARAMETER") leftUntrackedStackFields: SetDomain<PTAField>,
                           @Suppress("UNUSED_PARAMETER") rightUntrackedStackFields: SetDomain<PTAField>,
                           /** input/output parameters **/
                           onlyLeft: ArrayList<Pair<PTAField, PTACell>>,
                           onlyRight: ArrayList<Pair<PTAField, PTACell>>,
                           unificationList: ArrayList<Pair<PTASymCell, PTASymCell>>):
        Pair<SetDomain<PTAField>, Set<PTAField>> {

        if (!leftStack.isExactNode() || !rightStack.isExactNode()) {
            throw PointerDomainError("Stacks should be tracked exact." +
                                     "\nLeft=${leftStack}\nRight=${rightStack}")
        }
        /** keep track of stack fields that might point to anywhere (i.e., top) after the join **/
        var outUntrackedStackFields:SetDomain<PTAField> = SetUnionDomain()
        /** keep track of fields that should be kept after the join **/
        val outTrackedStackFields = mutableSetOf<PTAField>()

        for ((field, leftSuccC) in leftStack.getSuccs()) {
            val rightSuccC = rightStack.getSucc(field)
            if (rightSuccC == null) {
                /**
                 *  The field from the left stack is kept in the joined graph (union semantics) **even** if
                 *  the right stack already marked it as top
                 **/
                onlyLeft.add(Pair(field, leftSuccC))

            } else {
                val renamedLeftSuccC = leftSuccC.renameNode(leftStack, rightStack)
                if (renamedLeftSuccC == rightSuccC) {
                    /** leftSuccC and rightSuccC are equal modulo renaming **/
                    outTrackedStackFields.add(field)
                } else {
                    /** leftSuccC and rightSuccC are different cells **/
                    if (leftSuccC.node == leftStack || rightSuccC.node == rightStack) {
                        /** One of the stack fields points back to its stack **/
                        outUntrackedStackFields = outUntrackedStackFields.add(field)
                    } else {
                        /**
                         *  left and right stacks have a cell at the same field but the cells are
                         *  different (but they don't point back to their stacks):
                         *  put in the unification worklist for later processing
                         **/
                        outTrackedStackFields.add(field)
                        unificationList.add(Pair(leftSuccC.createSymCell(), rightSuccC.createSymCell()))
                        if (debugPTAJoin) {
                            sbfLogger.info { "## JOIN: stack cells at field $field: $leftSuccC and $rightSuccC to the unification list" }
                        }
                    }
                }
            }
        }
        /**
         *  All the fields from the right stack that are not in the left stack are kept in the
         *  joined graph (union semantics) **even** if the left stack already marked them as top
         **/
        for ((field, succC) in rightStack.getSuccs()) {
            if (leftStack.getSucc(field) == null) {
                onlyRight.add(Pair(field, succC))
            }
        }
        return Pair(outUntrackedStackFields, outTrackedStackFields)
    }

    private fun getType(scalar: ScalarValue): SbfType? {
        return if (scalar.isTop() || scalar.isBottom()) {
            null
        } else {
            scalar.get()
        }
    }

    private fun getNumber(scalar: SbfType): Long? {
        return if (scalar !is SbfType.NumType) {
            null
        } else {
            scalar.value.get()
        }
    }

    /** This is just a heuristic to identify dangling pointers **/
    private fun isNullOrDanglingPtr(scalar: SbfType): Boolean {
        val n = getNumber(scalar)
        return if (n != null) {
            // Rust `dangling()` function returns a small power-of-two
            (n == 0L || n == 1L || n == 2L || n == 4L || n == 8L || n == 16L || n == 32L || n == 64L)
        } else {
            false
        }
    }


    /**
     * If a register points to a cell but the same register in the other operand is null
     * (i.e., top) then the joined result discards the cell (i.e., top).
     * If both registers are mapped to different cells then we unify them with the exception that nodes
     * that represent the stacks are not unified.
     *
     * POST: the return list of cells must reference only nodes that are reachable from the left operand.
     *       This means that it cannot contain any reference to [rightStack].
     */
     private fun joinRegister(reg: SbfRegister,
                              leftStack: PTANode,
                              rightStack: PTANode,
                              leftC: PTASymCell?,
                              rightC: PTASymCell?,
                              leftScalars: ScalarDomain,
                              rightScalars: ScalarDomain,
                              unificationList: ArrayList<Pair<PTASymCell, PTASymCell>>): PTASymCell? {

        if (leftC != null && rightC != null) {
            val renamedLeftC = leftC.renameNode(leftStack, rightStack)
            if (renamedLeftC == rightC) {
                /** cells are equal modulo renaming */
                return leftC
            } else {
                if (leftC.node == leftStack || rightC.node == rightStack) {
                    /**
                     *  We avoid unifying stacks by setting the register to "top".
                     *  This is sound because if there is read/write to the register then an exception
                     *  will be thrown. The exception is when the register is r10 because by design
                     *  the analysis cannot lose track of r10.
                     **/
                    if (reg == SbfRegister.R10_STACK_POINTER) {
                        throw PointerDomainError("Join is losing track of r10")
                    }

                    if (SolanaConfig.OptimisticPTAJoin.get()) {
                        // See below comments about optimistic joins.
                        // Note that we don't try to distinguish whether the non-pointer argument is
                        // a dangling pointer or a regular number.
                        if (leftC.node == leftStack && rightC.node.mustBeInteger()) {
                            ptaWarning {
                                "The pointer domain performed optimistic join: " +
                                    "$reg looks a dangling pointer or number on one branch so we keep $reg to $leftC"
                            }
                            return leftC
                        } else if (leftC.node.mustBeInteger() && rightC.node == rightStack){
                            val outC = rightC.renameNode(rightStack, leftStack)
                            ptaWarning {
                                "The pointer domain performed optimistic join: " +
                                    "$reg looks a dangling pointer or number on one branch so we keep $reg to $outC"
                            }
                            return outC
                        }
                    }


                    if (debugPTAJoin) {
                        sbfLogger.info { "## JOIN: set register $reg to top to avoid unifying stacks" }
                    }

                    return null
                } else {
                    if (debugPTAJoin) {
                        sbfLogger.info { "## JOIN: register $reg cells $leftC and $rightC to the unification list" }
                    }
                    unificationList.add(Pair(leftC, rightC))
                    return leftC
                }
            }
        } else {
            if (SolanaConfig.OptimisticPTAJoin.get()) {
                // join(X,Y) = X if X is a pointer and Y looks a dangling pointer, a regular number or non-dereferenced global.
                //
                // Note that being a dangling pointer is something that our analysis cannot know for sure.
                // The analysis identifies a dangling pointer as a small power-of-two number following Rust convention.
                // However, this is not a sufficient condition. We separate the case of being potentially a
                // dangling pointer for a regular number just for debugging purposes.
                //
                // Soundness explanation for our optimistic join.
                //
                // - If Y is a dangling pointer then due to our assumption of memory-safety we shouldn't have
                //   a concrete memory access to the dangling pointer.
                //
                // - If Y is a number or non-dereferenced global then we assume that there is not a single execution where a number
                //   becomes a pointer, but instead, we are merging imprecisely two different executions.
                val (ptrC, danglingScalars) =
                    if (leftC != null) {
                        Pair(leftC, rightScalars)
                    } else if (rightC != null) {
                        // The renaming is needed to make sure that rightStack won't be part of the join
                        Pair(rightC.renameNode(rightStack, leftStack), leftScalars)
                    } else {
                        Pair(null, null)
                    }

                if (ptrC != null) {
                    val scalarVal = danglingScalars!!.getValue(Value.Reg(reg))
                    val scalarType = getType(scalarVal)
                    if (scalarType != null) {
                        if (isNullOrDanglingPtr(scalarType)) {
                            ptaWarning {
                                "The pointer domain performed optimistic join: " +
                                    "$reg looks a dangling pointer on one branch so we keep $reg to $ptrC"
                            }
                            return ptrC
                        } else if (scalarType is SbfType.NumType) {
                            ptaWarning {
                                "The pointer domain performed optimistic join: " +
                                    "$reg is a pointer on one branch and an integer on the other so we keep $reg to $ptrC"
                            }
                            return ptrC
                        } else if (scalarType is SbfType.PointerType.Global) {
                            ptaWarning {
                                "The pointer domain performed optimistic join: " +
                                    "$reg is a pointer on one branch and a global (perhaps string?) on the other so we keep $reg to $ptrC"
                            }
                            return ptrC
                        }
                    }
                }
            }
        }
        return null
     }

    private fun joinRegisters(leftStack: PTANode,
                              rightStack: PTANode,
                              // null means that the register is "top"
                              leftRegisters: List<PTASymCell?>,
                              // null means that the register is "top"
                              rightRegisters: List<PTASymCell?>,
                              leftScalars: ScalarDomain,
                              rightScalars: ScalarDomain,
                              unificationList: ArrayList<Pair<PTASymCell, PTASymCell>>): ArrayList<PTASymCell?> {

        val commonRegisters = ArrayList<PTASymCell?>(registers.size)
        leftRegisters.forEachIndexed { i, leftC ->
            val rightC = rightRegisters[i]
            commonRegisters.add(joinRegister(SbfRegister.getByValue(i.toByte()),
                                              leftStack, rightStack,
                                              leftC, rightC,
                                              leftScalars, rightScalars,
                                              unificationList))
        }
        check(leftRegisters.size == commonRegisters.size) {"join sanity check 1" }
        return commonRegisters
    }

    /**
     * Same logic than in joinRegisters but we don't need to unify cells because it shouldn't be the case
     * that the same register is pointing to different cells at a joint point.
     */
    private fun joinScratchRegisters(leftStack: PTANode,
                                     rightStack: PTANode,
                                     leftScratchRegisters: List<PTASymCell?>,
                                     rightScratchRegisters: List<PTASymCell?>): ArrayList<PTASymCell?> {
        val commonScratchRegisters = ArrayList<PTASymCell?>(scratchRegisters.size)
        leftScratchRegisters.forEachIndexed {i, leftC ->
            commonScratchRegisters.add(null)
            val rightC = rightScratchRegisters[i]
            if ((leftC == null && rightC != null) || (leftC != null && rightC == null)) {
                throw PointerDomainError("Unexpected mismatch in scratch register $i at join point\n" +
                    "Left=${leftScratchRegisters}\nRight=${rightScratchRegisters}")
            } else if (leftC != null) {
                val renamedLeftC = leftC.renameNode(leftStack, rightStack)
                if (renamedLeftC == rightC) {
                    /** cells are equal modulo renaming */
                    commonScratchRegisters[i] = leftC
                } else {
                    /**
                     *  The scratch registers are expected to be equal (modulo stacks renaming) at any join point since
                     *  all incoming blocks to join points should have the same call stack
                     **/
                    throw PointerDomainError("Unexpected mismatch in scratch register $i at join point\n" +
                        "Left=${leftScratchRegisters}\nRight=${rightScratchRegisters}")
                }
            }
        }
        check(leftScratchRegisters.size == commonScratchRegisters.size) {"join sanity check 2"}
        return commonScratchRegisters
    }

    /// Helper for join
    private fun removeFieldFromStack(stack: PTANode, field: PTAField, g:PTAGraph,
                                     @Suppress("UNUSED_PARAMETER")
                                     msg: String) {
        val succC = stack.getSuccs()[field]
        if (succC != null) {
            stack.removeEdge(field, succC)
        }
        g.untrackedStackFields = g.untrackedStackFields.add(field)
    }

    /**
     * Recall that the stack is represented as another points-to graph node.
     * However, when we join two abstract states, the nodes that model the stacks must be treated differently
     * from the other nodes. The reason is that the stack is modeled in a flow-sensitive way while
     * the other nodes are modeled in a flow-insensitive way.
     *
     * The high-level idea of the join is to "import" the stack of one graph into the other, and then keep all
     * commonalities by performing unifications (if needed), when the same stack fields or registers point to
     * different cells (in the two abstract states).
     */
    fun join(other: PTAGraph, leftScalars: ScalarDomain, rightScalars: ScalarDomain,
             left: Label?, right: Label?): PTAGraph {
        if (scratchRegisters.size != other.scratchRegisters.size) {
            val msg = if (left != null && right != null ){
                "join between $left and $right"
            } else if (left != null){
                "widening at $left"
            } else {
                ""
            }
            throw PointerDomainError("$msg failed because disagreement on the number of scratch registers")
        }

        val dotDebugger = BinaryOperationToDot("join")
        if (debugPTAJoin) {
            dotDebugger.addOperands(this, other, left, right)
        }

        val rightG = other
        val leftG = this
        val leftStack = leftG.getStack()
        val rightStack = rightG.getStack()
        if (debugPTAJoin) {
            sbfLogger.info {"### Starting JOIN ####\n" +
                             "Left block=$left right block=$right\n" +
                             "Left=$this\nRight=$other\n"}
        }

        /** To perform stack additions to preserve union semantics **/
        val onlyLeft = ArrayList<Pair<PTAField, PTACell>>()
        val onlyRight = ArrayList<Pair<PTAField, PTACell>>()
        /** To perform unifications **/
        val unificationList = ArrayList<Pair<PTASymCell, PTASymCell>>()

        val (outUntrackedStackFields, outTrackedStackFields) =
            joinStacks(leftStack, rightStack,
                       leftG.untrackedStackFields, rightG.untrackedStackFields,
                       onlyLeft, onlyRight,
                       unificationList)
        val commonRegisters =
            joinRegisters(leftStack, rightStack,
                          leftG.registers, rightG.registers,
                          leftScalars, rightScalars,
                          unificationList)
        val commonScratchRegisters =
            joinScratchRegisters(leftStack, rightStack,
                                leftG.scratchRegisters, rightG.scratchRegisters)

        /** Creating the resulting graph as a partial copy of the left graph **/
        val outG = leftG.copy(commonRegisters, commonScratchRegisters, outTrackedStackFields)
        val leftOutStack = outG.getStack()
        val rightOutStack = outG.importStack(rightStack, null)
        if (debugPTAJoin) {
            sbfLogger.info {"Result graph (after selective copy of left with \n" +
                             "registers=${commonRegisters}\nscratch=${commonScratchRegisters}\n" +
                             "stack fields=${outTrackedStackFields}):\n$outG"}
            sbfLogger.info{"Left stack renamed to $leftOutStack and right stack renamed to $rightOutStack"}
        }

        /**
         *  Add fields that were only either on the left or on the right stacks.
         *
         *  It's possible to add a field that will be removed later if overlaps with other fields,
         *  but we do it like this for simplicity.
         **/
        for ((field, c) in onlyLeft) {
            val renamedC = c.renameNode(leftStack, leftOutStack)
            leftOutStack.addEdge(field, renamedC)
            if (debugPTAJoin) {
                sbfLogger.info { "JOIN added stack field ($leftOutStack,$field)" }
            }
        }
        for ((field, c) in onlyRight) {
            val renamedC = c.renameNode(rightStack, leftOutStack)
            leftOutStack.addEdge(field, renamedC)
            if (debugPTAJoin) {
                sbfLogger.info { "JOIN added stack field ($leftOutStack,$field)" }
            }
        }

        /**
         * Remove overlapping cells.
         *
         * An invariant of the Pointer domain is that given an abstract state, its stack doesn't have overlaps.
         * However, when we join two stacks we need to deal with overlaps to keep that invariant.
         * We remove those overlaps from the stack, and if later, there is a read to the removed
         * stack slots then the analysis will throw an exception.
         *
         * There are two common sources for overlaps at joins:
         * 1. Local variables that live in different lifetimes.
         * 2. Rust union types.
         *
         * If the cause for overlap is (1) then we shouldn't throw an exception.
         * However, if the reason is (2) then we will probably throw an exception.
         **/
        val overlaps = leftStack.findOverlaps(rightStack)
        for ((fieldL, fieldR) in overlaps) {
            if (SolanaConfig.OptimisticPTAOverlaps.get()) {
               ptaWarning { "The pointer domain performed optimistic join: " +
                          "keeping stack overlaps $fieldL and $fieldR" }
            } else {
                removeFieldFromStack(
                    leftOutStack, fieldL, outG,
                    "Removed link at $fieldL from the joined stack because overlapping"
                )
                removeFieldFromStack(
                    leftOutStack, fieldR, outG,
                    "Removed link at $fieldR from the joined stack because overlapping"
                )
            }
        }

        /**
         * Remove fields that are marked as top
         **/
        for (field in outUntrackedStackFields.iterator()) {
            removeFieldFromStack(leftOutStack, field, outG,
                "Removed link at $field from the joined stack because stacks")
        }

        /** And finally, perform unifications **/
        val renamedMerges = ArrayList<Pair<PTASymCell, PTASymCell>> ()
        unificationList.forEach { (leftSC, rightSC) ->
            val renamedLeftSC = leftSC.renameNode(leftStack, leftOutStack)
            val renamedRightSC = rightSC.renameNode(rightStack, rightOutStack)
            if (debugPTAJoin) {
                if (renamedLeftSC == leftSC && renamedRightSC == rightSC) {
                    sbfLogger.info { "JOIN SCHEDULED UNIFY $leftSC with $rightSC" }
                } else {
                    sbfLogger.info { "JOIN SCHEDULED UNIFY $renamedLeftSC ($leftSC) with $renamedRightSC ($rightSC)" }
                }
            }
            renamedMerges.add(Pair(renamedLeftSC, renamedRightSC))
        }
        UnificationBatch(outG, renamedMerges) { sc, msg -> (::reifyCell)(sc, msg, null) }.run()

        if (debugPTAJoin) {
            dotDebugger.addResultAndPrint(outG, left, right)
        }

        if (SolanaConfig.SanityChecks.get() && !SolanaConfig.OptimisticPTAJoin.get()) {
            for (field in outG.untrackedStackFields.iterator()) {
                if (outG.getStack().getSuccs()[field] != null) {
                    throw PointerDomainError("Stack has a top field $field but the field has successors (1)")
                }
            }
            if (!leftG.lessOrEqual(outG, left, right)) {
                if (left != null && right != null) {
                    throw PointerDomainError("The join of $left and $right " +
                                                   "is not an upper bound of the left operand")
                } else {
                    throw PointerDomainError("The join of is not an upper bound of the left operand")
                }
            }
            if (!rightG.lessOrEqual(outG, left, right)) {
                if (left != null && right != null) {
                    throw PointerDomainError("The join of $left and $right " +
                                                   "is not an upper bound of the right operand")
                } else {
                    throw PointerDomainError("The join of is not an upper bound of the right operand")
                }
            }
        }
        return outG
    }

    fun widen(other: PTAGraph, b: Label?): PTAGraph {
        val leftScalars = ScalarDomain() // top
        val rightScalars = ScalarDomain() // top
        return join(other, leftScalars, rightScalars, b, null)
    }

    /**
     * We only compare the flow-sensitive components: normal registers, stack, and
     * scratch registers. The rest should be same because it's global.
     * - If a register is mapped to null then it means "top"
     * - If a stack field is empty then it means it has not been accessed
     **/
    fun lessOrEqual(other: PTAGraph, left: Label?, right: Label?): Boolean {

        // For registers
        fun lessOrEqual(left: ArrayList<PTASymCell?>, right:ArrayList<PTASymCell?>,
                        leftStack: PTANode, rightStack: PTANode): Boolean {
            left.forEachIndexed{i, leftC ->
                val rightC = right[i]
                if (leftC == null && rightC != null) {
                    if (debugPTALeq) {
                        sbfLogger.info { "register $i is top on left but non-top on right operand" }
                    }
                    return false
                } else if (leftC != null && rightC != null) {
                    val renamedLeftC = leftC.renameNode(leftStack, rightStack)
                    if (!renamedLeftC.lessOrEqual(rightC)) {
                        if (debugPTALeq) {
                            sbfLogger.info { "register $i has different cells for left and right operands: " +
                                              "$renamedLeftC and $rightC" }
                        }
                        return false
                    }
                }
            }
            return true
        }

        if (scratchRegisters.size != other.scratchRegisters.size) {
            val msg = if (left != null && right != null ){
                "inclusion between $left and $right"
            } else {
                "inclusion"
            }
            throw PointerDomainError("$msg failed because disagreement on the number of scratch registers")
        }

        val dotDebugger = BinaryOperationToDot("leq")
        if (debugPTALeq) {
            dotDebugger.addOperands(this, other, left, right)
            dotDebugger.print()
        }

        val leftStack = getStack()
        val rightStack = other.getStack()

        if (!lessOrEqual(registers, other.registers, leftStack, rightStack)) {
            return false
        }

        // special case if the left stack has been already summarized but the right stack hasn't.
        if (!leftStack.isExactNode() && rightStack.isExactNode()) {
            if (debugPTALeq) {
                sbfLogger.info {"Left stack is not summarized but right stack is"}
            }
            return false
        }

        for ((field, leftSuccC) in leftStack.getSuccs()) {
            val rightSuccC = rightStack.getSucc(field)
                    ?: if (other.untrackedStackFields.contains(field)) {
                        continue
                    } else {
                        if (debugPTALeq) {
                            sbfLogger.info {"Right stack does not have cell at field $field\n" +
                                "Left=$this\n" +
                                "Right=$other"}
                        }
                        return false
                    }

            val renamedLeftSuccC = leftSuccC.renameNode(leftStack, rightStack)
            if (!renamedLeftSuccC.lessOrEqual(rightSuccC)) {
                if (rightSuccC.node == rightStack && !rightStack.isExactNode()) {
                    // rightStack is fully summarized and its successor link points to itself:
                    // this is the most general stack so anything is less or equal than that.
                    continue
                }

                if (debugPTALeq) {
                    sbfLogger.info {
                        "Stack at field $field has different cells for left and right operands: " +
                            "$renamedLeftSuccC and $rightSuccC\nLeft=$this\nRight=$other"
                    }
                }
                return false

            }
        }

        return lessOrEqual(scratchRegisters, other.scratchRegisters, leftStack, rightStack)
    }

    /** TRANSFER FUNCTIONS **/

    /**
     * let `c` be `getRegCell(reg)` and let `c'` be a fresh cell.
     * - if `c` is not null return `c`
     * - if [type] is a pointer to Heap/Global then  make [reg] pointing to `c'` and return `c'`
     * - if [type] is a number then the behaviour depends on [stopIfError]. If [stopIfError] is true then
     *   we report an error else make [reg] pointing to `c'` and return `c'`
     * - else return null.
     */
    fun getRegCell(reg: Value.Reg,
                   type: SbfType,
                   globalsMap: GlobalVariableMap,
                   locInst: LocatedSbfInstruction?,
                   stopIfError: Boolean = true): PTASymCell? {

        var sc = getRegCell(reg)
        if (sc != null) {
            return sc
        }

        val pointerType: SbfType.PointerType? = when(type) {
            is SbfType.NumType -> castNumToPtr(type, globalsMap)
            is SbfType.PointerType -> type
            else -> null
        }

        if (pointerType != null) {
            when(pointerType) {
                is SbfType.PointerType.Stack -> {
                    // It's possible that we don't keep track of a register in the pointer domain but
                    // the scalar domain knows about it.
                    // This can happen if we set to top a register during the join to avoid unifying stacks.
                    val o = pointerType.offset
                    check(!o.isBottom()) { "offsets cannot be bottom" }
                    if (!o.isTop()) {
                        val r10C = getRegCell(Value.Reg(SbfRegister.R10_STACK_POINTER))
                        if (r10C != null) {
                            sc = r10C.node.createSymCell(PTASymOffset(o.get()!!))
                            setRegCell(reg, sc)
                        }
                    }
                }
                is SbfType.PointerType.Global -> {
                    val gv = pointerType.global ?: throw UnknownGlobalDerefError(DevErrorInfo(locInst, PtrExprErrReg(reg),""))
                    sc = globalAlloc.alloc(gv, pointerType.offset)
                    setRegCell(reg, sc)
                }
                is SbfType.PointerType.Heap -> {
                    sc = heapAlloc.lowLevelAlloc(pointerType.offset)
                    setRegCell(reg, sc)
                }
                is SbfType.PointerType.Input -> {
                    // do nothing: it will return  null
                }
            }
        } else if (type is SbfType.NumType) {
                val address = type.value.get()
                if (address != null) {
                    if (!stopIfError) {
                        // allocate fresh memory
                        sc = externAlloc.alloc(address.toULong())
                        setRegCell(reg, sc)
                        return sc
                    }
                }

                val devMsg = "dereference of an absolute address " +
                    if (address != null) {
                        "$address (0x${address.toString(16)})"
                    } else {
                        "although the actual address is unknown statically"
                    } +
                    if (locInst != null) {
                        " at ${locInst.inst}"
                    } else {
                        ""
                    }
                throw DerefOfAbsoluteAddressError(DevErrorInfo(locInst, PtrExprErrReg(reg), devMsg))
        }

        return sc
    }

    fun forget(reg: Value.Reg) {
        setRegCell(reg, null)
    }

    /** Transfer function for pointer assignment  dst := src **/
    private fun doPointerAssign(dst: Value.Reg, src: Value.Reg) {
        setRegCell(dst, getRegCell(src))
    }

    /** dst points to n at an unknown offset **/
    private fun doUnknownPointerArithmetic(dst: Value.Reg, n: PTANode) {
        setRegCell(dst, if (n is PTASummarizedNode) {
            n.createSymCell(mkAbstractOffset(0L))
        } else {
            n.createSymCell(PTASymOffset.makeTop())
        })
    }
    /** Transfer function for dst := op1 op op2
     *  Note that we don't really know if op1 is a pointer or a number.
     *  @param op1 is a pointer.
     *  @param op2 is a number that can be later promoted to a pointer but that's okay.
     **/
    private fun doConstantPointerArithmetic(op: BinOp,
                                            dst: Value.Reg,
                                            op1: Value.Reg,
                                            op2: Value.Imm) {
        if ((op == BinOp.ADD || op == BinOp.SUB) && op2.v == 0UL) {
            doPointerAssign(dst, op1)
        } else {
            val c = getRegCell(op1)
                ?: if (enableDefensiveChecks) {
                    throw PointerDomainError("cannot find cell for $op1 in $this")
                } else {
                    forget(dst)
                    return
                }
            val n = c.node
            val o = c.offset
            if (op == BinOp.ADD || op == BinOp.SUB) {
                val newOffset = updateOffset(op, n, o, op2.v.toLong())
                setRegCell(dst, n.createSymCell(newOffset))
                if (op == BinOp.SUB &&
                    dst.r == SbfRegister.R10_STACK_POINTER &&
                    op1.r == SbfRegister.R10_STACK_POINTER && op2.v == SBF_STACK_FRAME_SIZE.toULong()) {
                    // Pop stack
                    removeDeadStackFields()
                }
            } else {
                doUnknownPointerArithmetic(dst, n)
            }
        }
    }

    /** Transfer function for dst := op1 op op2
     *  Note that we don't really know if op1 is a pointer or a number.
     *  @param op1 is a pointer.
     *  @param op2 is a number that can be later promoted to a pointer but that's okay.
     **/
    private fun doConstantPointerArithmetic(locInst: LocatedSbfInstruction,
                                            op: BinOp,
                                            dst: Value.Reg,
                                            op1: Value.Reg,
                                            op2: Value.Reg,
                                            op2Type: SbfType.NumType) {

        val o = op2Type.value.get()
        if (o != null && o == 0L) {
            doPointerAssign(dst, op1)
        } else {
            val c1 = getRegCell(op1)
                    ?: if (enableDefensiveChecks) {
                        throw PointerDomainError("cannot find cell for $op1 in $this")
                    } else {
                        forget(dst)
                        return
                    }

            if (o != null && (op == BinOp.ADD || op == BinOp.SUB)) {
                // This is a long explanation for why we unify nodes pointed by `op1` and `op2` even if we know at this
                // point that `op2` is a number.
                //
                // First point: we perform a reduction from PTA to scalar domain.
                // This reduction might tell the scalar domain that some register contains a number.
                // This is okay, but we need to keep in mind that part of PTA's information is flow-insensitive.
                //
                //
                // Second point: recall that during TAC encoding we recompute invariants at the instruction level.
                // During analysis phase, we now that `op2` is a number.
                // When we reanalyze `op1:= op1+op2`, it is possible that the node pointed by `op2` has been unified with other
                // nodes due to flow-insensitivity. Then, the reanalysis of `op1:=op1+op2` will not be done by
                // `doConstantPointerArithmetic` but instead by `doGeneralCasePointerArithmetic`.
                // This different transfer function might do extra unifications between nodes pointed by `op1` and `op2` which we
                // did not perform during analysis phase. This is a problem because the TAC encoding phase
                // assumes that the re-analysis of instructions does not cause extra aliasing.
                //
                // Solution: if `op2` points to a node then we always unify it with the node pointed by `op1` even if we
                // know that at this time `op2` is a number.
                val c2 = getRegCell(op2)
                if (c2 != null) {
                    reifyCell(c1, "$dst:= $op1 $op $op2", locInst)
                        .unify(reifyCell(c2, "$dst:= $op1 $op $op2", locInst))
                }
                // after unification, op1 and op2 point to the same cell.
                if (dst != op1 && dst != op2) {
                    setRegCell(dst, getRegCell(op1))
                }
            } else {
                doUnknownPointerArithmetic(dst, c1.node)
            }
        }
    }

    /**
     *  Return true iff [op1] and [op2] point to a cell in the points-to graph.
     *
     *  Both [op1] and [op2] can point to two different cells from different nodes.
     *  This might be counterintuitive because coming from *memory-safe* C/C++/Rust,
     *  pointer arithmetic can only involve pointers within the same memory object,
     *  so they should point at least to the same node.
     *  However, our abstraction cannot even tell whether [op1] and [op2] are definitely pointers.
     **/
    private fun doGeneralCasePointerArithmetic(locInst: LocatedSbfInstruction,
                                               op: BinOp, dst: Value.Reg, op1: Value.Reg, op2: Value.Reg): Boolean {
        val c1 = getRegCell(op1)
        val c2 = getRegCell(op2)
        return if (c1 != null && c2 != null) {
            /**
             * op1 and op2 could be either pointers or integers.
             * This might be unnecessarily imprecise, but it's sound.
             */
             // If we know that one of the operands cannot be a pointer then we can
             // avoid the unification
            reifyCell(c1, "$dst:= $op1 $op $op2", locInst)
                .unify(reifyCell(c2, "$dst:= $op1 $op $op2", locInst))
            // after unification, op1 and op2 point to the same cell.
            if (dst != op1 && dst != op2) {
                setRegCell(dst, getRegCell(op1))
            }
            true
        } else {
            false
        }
    }
    /**
     * Note that we might not know whether the operation is pointer arithmetic or simply integer arithmetic.
     * We assume that src and dst might be pointers unless the scalar domain says otherwise.
     * We use dstType and srcType from the scalar domain to learn about src and dst types.
     * Note that the fact that src and dst can be mapped to cells it doesn't mean that they are pointers
     * since the pointer domain assumes that all operands can be pointers.
     **/
    private fun doPointerArithmetic(locInst: LocatedSbfInstruction,
                                    op: BinOp,
                                    dst: Value.Reg,
                                    op1: Value.Reg,
                                    op1Type: SbfType, /* from scalar analysis */
                                    op2: Value.Reg,
                                    op2Type: SbfType  /* from scalar analysis */) {
        check(!(op1Type is SbfType.NumType && op2Type is SbfType.NumType))
        {"failed preconditions on doPointerArithmetic in pointer domain"}

        if (op2Type is SbfType.NumType) {
            // op1 could still be either a pointer or a number.
            doConstantPointerArithmetic(locInst, op, dst, op1, op2, op2Type)
        } else  if (op1Type is SbfType.NumType) {
            // Symmetric case: op2 could still be either a pointer or a number.
            if (op.isCommutative) {
                doConstantPointerArithmetic(locInst, op, dst, op2, op1, op1Type)
            } else {
                if (!doGeneralCasePointerArithmetic(locInst, op, dst, op1, op2)) {
                    if (enableDefensiveChecks) {
                        throw PointerDomainError("TODO(1): $dst:= $op1 $op $op2 when $op1 is $op1Type")
                    }
                    forget(dst)
                }
            }
        } else if (op1Type is SbfType.PointerType && op2Type is SbfType.PointerType) {
            if (op == BinOp.SUB){
                // dst is a number
                forget(dst)
            } else {
                throw PointerDomainError("TODO(2): unsupported pointer arithmetic $dst := $op1 $op $op2")
            }
        } else {
            if (!doGeneralCasePointerArithmetic(locInst, op, dst, op1, op2)) {
                val c1 = getRegCell(op1)
                val c2 = getRegCell(op2)
                if (c1 != null) {
                    doUnknownPointerArithmetic(dst, c1.node)
                } else if (c2 != null) {
                    doUnknownPointerArithmetic(dst, c2.node)
                } else {
                    if (enableDefensiveChecks) {
                        throw PointerDomainError("TODO(3) cannot find a cell for $op1 and $op2 in $this")
                    }
                    forget(dst)
                }
            }
        }
    }

    /** Transfer function for dst = dst op src
     *
     *  In languages compiled to LLVM (C/C++/Rust), the only valid arithmetic operations on pointers are adding an
     *  offset to a pointer or subtracting pointers. However, pointers can be cast to integers (e.g., inttoptr_t)
     *  so that other arithmetic operations can be applied on pointers (e.g., bitwise operations are used to check
     *  whether a pointer is aligned or not). In SBF, there is no instructions for explicit casts from pointers to
     *  integers, or vice-versa. Thus, operations such as ADD, SUB, OR, AND, and XOR on registers that are supposed
     *  to contain pointers are pretty common.
     *
     *  To deal with this, the pointer domain models everything as a pointer unless the scalar domain can prove
     *  the opposite. The soundness of the transfer functions relies always on finding a cell in the graph for each
     *  operand (dst and src), and conservatively unifying and/or summarizing nodes whenever we don't really
     *  know whether the operation is supposed to be on integers or pointers.
     */
    fun doBin(locInst: LocatedSbfInstruction,
              op: BinOp,
              dst: Value.Reg,
              src: Value,
              dstType: SbfType,
              srcType: SbfType,
              @Suppress("UNUSED_PARAMETER") globalsMap: GlobalVariableMap) {
        if (dstType is SbfType.NumType && srcType is SbfType.NumType) {
            // the pointer domain doesn't keep track of @dst
            forget(dst)
            return
        }

        if (src is Value.Imm) {
            when (op) {
                BinOp.MOV -> {
                    // forgetting dst may seem too conservative. However, note that
                    // if dst is used later for pointer arithmetic or is de-referenced,
                    // then we will recover its value from the scalar domain.
                    forget(dst)
                }
                else -> {
                    doConstantPointerArithmetic(op, dst, dst, src)
                }
            }
        } else {
            when (op) {
                BinOp.MOV -> {
                    doPointerAssign(dst, src as Value.Reg)
                }
                else  -> {
                    doPointerArithmetic(locInst, op, dst, dst, dstType, src as Value.Reg, srcType)
                }
            }
        }
    }

    fun doSelect(locInst: LocatedSbfInstruction,
                 @Suppress("UNUSED_PARAMETER") globals: GlobalVariableMap,
                 scalars: ScalarDomain) {
        val inst = locInst.inst
        check(inst is SbfInstruction.Select) {"doSelect expects a select instruction instead of $inst"}

        val dst = inst.dst
        val trueVal = inst.trueVal
        val falseVal = inst.falseVal
        val trueC = if (trueVal is Value.Reg) { getRegCell(trueVal) } else { null }
        val falseC = if (falseVal is Value.Reg) { getRegCell(falseVal) } else { null }

        val unificationList = ArrayList<Pair<PTASymCell, PTASymCell>>()
        // set destination (the result of joinRegister can be null)
        setRegCell(Value.Reg(dst.r),
            joinRegister(dst.r, getStack(), getStack(), trueC, falseC, scalars, scalars, unificationList))

        // extra unifications
        UnificationBatch(this, unificationList) { sc, msg ->
            (::reifyCell)(sc, msg, locInst)
        }.run()
    }


    /** Transfer function for dst := *(baseReg + offset) **/
    fun doLoad(locInst: LocatedSbfInstruction,
               dst: Value.Reg,
               baseReg: Value.Reg,
               offset: Short,
               width: Short,
               baseRegType: SbfType,
               globalsMap: GlobalVariableMap) {
        val allocSite = locInst.inst
        check(allocSite is SbfInstruction.Mem) {"doAlloc expects a memory instruction instead of $allocSite"}
        val baseC = getRegCell(baseReg, baseRegType, globalsMap, locInst)
                ?: throw UnknownPointerDerefError(
                    DevErrorInfo(locInst, PtrExprErrReg(baseReg),"load: the base $baseReg does not point to a graph node in $this"))
        baseC.node.setRead()
        val newOffset = updateOffset(BinOp.ADD, baseC.node, baseC.offset, offset.toLong())
        /** Reification takes place here because we cannot delay longer symbolic offsets **/
        val concreteC = reifyCell(baseC.node.createSymCell(newOffset),
                        "reification of $baseReg in $dst := *($baseReg + $offset)", locInst)
        val concreteOffset = concreteC.offset
        val field = PTAField(concreteOffset, width)
        val concreteNode = concreteC.node
        val isConcreteNodeStack = concreteNode == getStack()
        val succC = concreteNode.getSucc(field)
        if (succC == null) {
            if (locInst.inst.metaData.getVal(SbfMeta.LOADED_AS_NUM_FOR_PTA) == false) {
                // We only skip the load instruction if the loaded value cannot affect control-flow of the program
                // This is important because we want PTA to check that the load matches the last store even if the loaded
                // value is not a pointer.
                return
            }

            if (isConcreteNodeStack) {
                val reconstructedSuccC = reconstructIntegerCell(locInst, concreteC, width)
                if (reconstructedSuccC != null) {
                    setRegCell(dst, reconstructedSuccC)
                    // It's possible that the read field was marked as untracked by a previous store.
                    // But in this case it's okay to call reconstructIntegerCell and mark the field as trackable again.
                    untrackedStackFields = untrackedStackFields.remove(PTAField(concreteC.offset, width))
                    return
                } else if (untrackedStackFields.contains(field)) {

                    // We find the field at the same offset but with different size
                    // This info is useful for debugging later.
                    var errExp: PtrExprErrStackDeref? = null
                    for (otherSize in listOf(1, 2, 4, 8)) {
                        if (otherSize.toShort() != field.size) {
                            val otherField = PTAField(field.offset, otherSize.toShort())
                            if (concreteNode.getSucc(otherField) != null) {
                                errExp = PtrExprErrStackDeref(otherField)
                                break
                            }
                        }
                    }
                    throw UnknownStackContentError(DevErrorInfo(locInst, errExp,
                        "load: reading from a stack offset $concreteOffset that points to nowhere."))
                }
            }

            /**
             * Non-standard step: **ALLOCATION** the first time reading from memory.
             *
             * Some memory regions (e.g., Input) are pre-allocated
             * when the Solana program is called. Because of that, the analysis can read from memory without
             * finding a node for baseReg since it analyzes the program without knowing about those pre-allocations.
             *
             * Our solution is to pretend that an allocation takes place right before we do the memory read.
             * This is sound under the assumption that program is memory safe so that memory is properly
             * initialized.
             *
             * REVISIT: updateLink will kill first all the overlapping cells.
             *  Perhaps, we should throw an exception if there are overlaps.
             */
            val allocC = reifyCell(externAlloc.alloc(locInst), "external allocation", locInst)
            updateLink(locInst, concreteC, width, allocC, false)
            setRegCell(dst, allocC.createSymCell())
        } else {
            @Suppress("ForbiddenComment")
            // FIXME/TODO: check that the widths are the same
            setRegCell(dst, succC.createSymCell())
        }
    }


    /** Reconstruct a cell from the overlapping cells **/
    private fun reconstructIntegerCell(locInst: LocatedSbfInstruction, deref: PTACell, width: Short): PTASymCell? {
        if (deref.node.getSuccs().isEmpty()) {
            return null
        }
        val x = FiniteInterval.mkInterval(deref.offset, width.toLong())
        for ((field, succC) in deref.node.getSuccs()) {
            val fieldRange =  deref.node.getAccessedBytes(field)
            if (!fieldRange.includes(x)) {
                continue
            }
            return if (succC.node.mustBeInteger()) {
                integerAlloc.alloc(locInst)
            } else {
                null
            }
        }
        return null
    }

    /**
     *  A new edge from src to dst is created in the points-to graph.
     *  We check that it is not an edge from non-stack memory to stack.
     *  This is sufficient to check that whether a stack address escapes.
     */
    private fun checkStackDoesNotEscape(locInst: LocatedSbfInstruction?, src: PTACell, dst: PTACell) {
        if (src.node != getStack() && dst.node == getStack()) {
            throw PointerStackEscapingError(DevErrorInfo(locInst, null,"stack is escaping: $dst is being stored into $src"))
        }
    }

    /**
     *  Return all the partial overlap links with [c.offset, c.offset + width]
     *  Precondition: c.node is the stack
     */
    private fun getOverlapLinks(c: PTACell, width: Short): List<Pair<PTAField, PTACell>> {
        check(c.node == getStack()) {"getOverlapLinks expects only a stack node"}
        return c.node.getLinksInRange(c.offset, width.toLong(), isStrict = false, onlyPartial = true)
    }

    /** This function is public because it is used by TAC encoding **/
    fun getOverlapFields(c: PTACell, width: Short): List<Pair<PTANode, PTAField>>? {
        return if (c.node != getStack()) {
            if (c.node.isExactNode()) {
                c.node.getLinksInRange(c.offset, width.toLong(), isStrict = false, onlyPartial = true).
                map {Pair(c.node, it.first)}
            } else {
                // If the node is summarized then we cannot tell any precise information about overlaps.
                null
            }
        } else {
            getOverlapLinks(c, width).map { Pair(c.node, it.first) }
        }
    }

    private fun updateLink(locInst: LocatedSbfInstruction, src: PTACell, width: Short, dst: PTACell, isStore: Boolean) {
        checkStackDoesNotEscape(locInst, src, dst)

        val isStrongUpdate =
            if (src.node == getStack()) {
                /// Remove any overlapping field.
                val links = getOverlapLinks(src, width)
                src.node.removeLinks(links) { f ->
                    //sbfLogger.info {"Removed link at $f after updating link at ${src.offset} width=$width"}
                    untrackedStackFields = untrackedStackFields.add(f)
                }

                // LIMITATION: it's not enough to kill an overlapping field if it already exists.
                // We need to make innacessible any possible **overlapping** field even if it hasn't been accessed yet.
                if (isStore) {
                    for (size in usedMemoryBitwidths) {
                        untrackedStackFields = untrackedStackFields.add(PTAField(src.offset, size.toShort()))
                    }
                }
                true
            } else {
                false
            }

        src.node.mkLink(src.offset, width, dst, isStrongUpdate)

        if (src.node == getStack()) {
            // If this field was untracked then from now on, it will be tracked because
            // it has been overwritten.
            untrackedStackFields = untrackedStackFields.remove(PTAField(src.offset, width))
        }
    }

    /** Transfer function for *(baseReg + offset) = value **/
    fun doStore(locInst: LocatedSbfInstruction,
                baseReg: Value.Reg,
                offset: Short,
                width: Short,
                value: Value,
                baseRegType: SbfType,
                valueType: SbfType,
                globalsMap: GlobalVariableMap) {
        val inst = locInst.inst
        check(inst is SbfInstruction.Mem) {"doStore expects a memory instruction instead of $inst"}
        val baseC = getRegCell(baseReg, baseRegType, globalsMap, locInst)
                ?: throw UnknownPointerDerefError(
                    DevErrorInfo(locInst, PtrExprErrReg(baseReg), "store: the base $baseReg does not point to a graph node in $this"))
        baseC.node.setWrite()
        val newOffset = updateOffset(BinOp.ADD, baseC.node, baseC.offset, offset.toLong())
        /** Reification takes place here because we cannot delay anymore a symbolic offset **/
        val concreteC = reifyCell(baseC.node.createSymCell(newOffset),
                              "reification of $baseReg in *($baseReg + $offset) := $value", locInst)
        /** whether the store is on the stack or not **/
        val isStack = baseRegType is SbfType.PointerType.Stack
        check(!isStack || concreteC.node == getStack()) {"Scalar and pointer domain disagree on the stack"}
        if (value is Value.Imm) {
            /**
             * Create a cell (with integer node) for the immediate value and add an edge in the points-to graph
             * between the two cells.
             * Note that we always add the edge even if the source is not the stack because the cell can be
             * copied (via memcpy) later to the stack.
             **/
            val valueC = integerAlloc.alloc(locInst).reify() // this reify() is non-op
            updateLink(locInst, concreteC, width, valueC, true)
        } else {
            val valueReg = value as Value.Reg
            val valueSC = getRegCell(valueReg)
            if (valueSC != null) {
                /**
                 * Create an edge in the points-to graph between two existing cells
                 * We also need to reify valueCell.
                 **/
                val valueC = reifyCell(valueSC, "reification of $value in *($baseReg + $offset) := $value", locInst)
                updateLink(locInst, concreteC, width, valueC, true)
            } else {

                /**
                 * We don't have yet a cell for the value. We ask the scalar analysis
                 **/
                val valueC = when(valueType) {
                    is SbfType.NumType -> {
                        // Create a fresh cell for the integer value
                        integerAlloc.alloc(locInst).reify() // this reify() is non-op
                    }
                    is SbfType.PointerType.Global -> {
                        val gv = valueType.global
                        if (gv != null) {
                            // Create a fresh cell for the global variable
                            globalAlloc.alloc(gv, valueType.offset).reify()
                        } else {
                            null
                        }
                    }
                    else -> {
                        null
                    }
                }

                if (valueC == null) {
                    if (isStack) {
                        untrackedStackFields = untrackedStackFields.add(PTAField(concreteC.offset, width))
                    } else {
                        throw UnknownPointerStoreError(DevErrorInfo(locInst, PtrExprErrReg(valueReg), ""))
                    }
                } else {
                    /**
                     * Add an edge in the points-to graph between the two cells: concreteC and valueC
                     **/
                    updateLink(locInst, concreteC, width, valueC, true)
                }
            }
        }
    }

    private fun getOverwrittenLinksByLongCopy(c: PTACell, len: Long): List<Pair<PTAField, PTACell>> {
        check(c.node.isExactNode()) {"getOverlapLinksForLongCopy expects a exact PTA node"}
        return c.node.getLinksInRange(c.offset, len, isStrict = false)
    }

    /** This function is public because it is used by TAC encoding **/
    fun getOverwrittenFieldsByLongCopy(c: PTACell, len: Long): List<Pair<PTANode, PTAField>>? {
        return if (c.node.isExactNode()) {
            getOverwrittenLinksByLongCopy(c, len). map {
                Pair(c.node, it.first)
            }
        } else {
            // If the node is summarized then we cannot tell any precise information about overlaps.
            null
        }
    }

    /**
     * Remove any overwritten field on the destination (included partial overlaps)
     * Used by doMemcpy and doMemset.
     */
    private fun removeLinks(dstC: PTACell, len: Long) {
        // We make accessible again all fields on the destination
        val range = FiniteInterval.mkInterval(dstC.offset, len)
        untrackedStackFields = untrackedStackFields.removeAll {
            if (debugPTAMemTransfer) {
                sbfLogger.info { "\tRemoved link $it" }
            }
            range.includes(it.toInterval())
        }

        val dstLinks = getOverwrittenLinksByLongCopy(dstC, len)
        dstC.node.removeLinks(dstLinks) { f ->
            if (dstC.node == getStack()) {
                if (f.offset < dstC.offset || dstC.offset + len <= f.offset) {
                    // Make inaccessible any overlapping field
                    if (debugPTAMemTransfer) {
                        sbfLogger.info { "\tAdded link at $f" }
                    }
                    untrackedStackFields = untrackedStackFields.add(f)
                }
            }
        }


    }

    @TestOnly
    fun doMemcpy(scalars: ScalarDomain, globals: GlobalVariableMap) {
        doMemcpy(locInst = null, scalars, globals)
    }

    private fun doMemcpy(locInst: LocatedSbfInstruction?, scalars: ScalarDomain, globals: GlobalVariableMap) {
        /**
         * Copy links [srcLinks] to [dstC].node.
         * The caller ensures that [srcLinks] are actually links from [srcC].node
         * [adjustedOffset] allows translating offsets from the source to the destination.
         **/
        fun copyLinks(srcC: PTACell, dstC: PTACell,
                      srcLinks: List<Pair<PTAField, PTACell>>,
                      adjustedOffset: PTAOffset) {
            dstC.node.copyLinks(srcLinks, adjustedOffset) { f ->
                val srcField = f.copy(offset= f.offset - adjustedOffset)
                check(srcC.node.getSucc(srcField) != null) {"field $srcField should exist in ${srcC.node}"}
                checkStackDoesNotEscape(locInst, dstC.node.createCell(f.offset), srcC.node.getSucc(srcField)!!)
                if (dstC.node == getStack()) {
                    if (debugPTAMemTransfer) {
                        sbfLogger.info { "\tAdded link at $f" }
                    }
                }
            }
        }

        /** Unify each link in [links] with each other. [links] are links inside [n] **/
        fun unifyLinks(n: PTANode, links: List<PTAField>) {
            check(n.isExactNode()) {"unifyLinks expects exact node" }
            check(links.isNotEmpty()) {"unifyLinks expects a non-empty list"}

            var prevField = links.first()
            for (curField in links.drop(1)) {
                // Important (**): we need to call getSucc at each iteration because after we unify two cells,
                // one of them becomes "dead" because all links from one cell will be redirected to the other.
                val prevDstC = n.getSucc(prevField)
                check(prevDstC != null) { "unexpected null in unifyLinks (1)" }
                val curDstC = n.getSucc(curField)
                check(curDstC != null) { "unexpected null in unifyLinks (2)" }
                prevDstC.unify(curDstC)
                if (!getStack().isExactNode()) {
                    throw PointerDomainError("stack should not be summarized after unifyLinks")
                }
                prevField = curField
            }
        }


        /**
         * [srcC].node can be stack or not but if it's not the stack then its fields are tracked precisely.
         * Thus, it covers two cases:
         * - from stack to stack
         * - from exact, non-stack to stack
         **/
        fun memcpyExactToStack(srcC: PTACell, len: Long, dstC: PTACell) {
            check(srcC.node.isExactNode()) {"Precondition of memcpyExactToStack (1)"}
            check(dstC.node == getStack()) {"Precondition of memcpyExactToStack (2)"}

            val adjustedOffset = dstC.offset - srcC.offset

            if (debugPTAMemTransfer) {
                sbfLogger.info {
                    "memcpy [${dstC.offset},...,${dstC.offset + len - 1}] <- " +
                        "[${srcC.offset},...,${srcC.offset + len - 1}]" +
                        "(adjustedOffset=${adjustedOffset}) length=$len"
                }
            }

            // Remove any overlapping field on the destination.
            removeLinks(dstC, len)
            // Select the source's links to be transferred.
            // We only transfer those links from source that are strictly in the range
            // [srcC.offset, srcC.offset+length-1]. Note that transferring fewer links is sound.
            val srcLinks = srcC.node.getLinksInRange(srcC.offset, len)
            // The actual transfer of links
            copyLinks(srcC, dstC, srcLinks, adjustedOffset)

            if (srcC.node == getStack()) {
                // propagate untracked fields from source to destination
                val srcRange = FiniteInterval.mkInterval(srcC.offset, len)
                val untrackedFields = untrackedStackFields
                for (f in untrackedFields.iterator()) {
                    if (f.toInterval().overlap(srcRange)) {
                        val dstField = f.copy(offset = f.offset + adjustedOffset)
                        untrackedStackFields = untrackedStackFields.add(dstField)
                    }
                }
            }
        }

        /** memcpy from summarized memory to stack **/
        fun  memcpySummToStack(srcC: PTACell, len: Long, dstC: PTACell) {
            check(!srcC.node.isExactNode()) { "Precondition of memcpySummToStack (1)" }
            check(dstC.node == getStack()) { "Precondition of memcpySummToStack (2)" }

            if (srcC.node.getSuccs().values.isEmpty()) {
                // there is nothing to transfer, but we kill conservatively at the destination
                // This can cause later on PTA exceptions, but it's sound.
                removeLinks(dstC, len)
            } else {
                // -- weak update
                // unify(dstC, length, srcC)
                // -- strong update
                val dstLinks = dstC.node.getLinksInRange(dstC.offset, len)
                removeLinks(dstC, len)

                // LIMITATION: we only add a link in the source IF there was already a link before.
                // The reason is that we are transferring links from a summarized node which by definition we lost
                // field-sensitivity. As a result, we do not know which links we should create at the source: at any byte?, at any 2 bytes? at any word?
                // Missing links on the destination should either cause PTA exceptions or
                // spurious counterexamples (from reading non-deterministic memory) but it should not cause soundness issues.

                // src is summarized, so it can only have up to 4 successors: 0:u8, 0:u16, 0:u32, and 0:u64
                for ((srcField, succSrcC) in srcC.node.getSuccs()) {
                    check(srcField.offset == 0L) {"Summarized nodes can only have links at offset 0"}
                    val dstFields = dstLinks.filter { (f, _) -> f.size == srcField.size }.map { (f, _) -> f }
                    for (dstField in dstFields) {
                        dstC.node.addEdge(dstField, succSrcC)
                        checkStackDoesNotEscape(locInst, dstC.node.createCell(dstField.offset), succSrcC)
                    }
                }

                // Special case to the above LIMITATION:
                // destination does not have links but memcpy copies only up to 1 word (8 bytes)
                if (len <= 8) {
                    for ((srcField, succSrcC) in srcC.node.getSuccs()) {
                        if (srcField.size > len) {
                            continue
                        }
                        val dstField = PTAField(dstC.offset + 0, srcField.size)
                        if (dstC.node.getSucc(dstField) == null) {
                            dstC.node.addEdge(dstField, succSrcC)
                        }
                    }
                }

            }
        }

        /**
         *  Unify all links in the slice between [srcC].offset and [srcC].offset + [len] - 1, and then
         *  unify them with [dstC].
         */
        fun memcpyStackToSumm(srcC: PTACell, len: Long, dstC: PTACell) {
            check(srcC.node.isExactNode()) {"Precondition of memcpyStackToSumm (1)"}
            check(!dstC.node.isExactNode()) {"Precondition of memcpyStackToSumm (2)"}

            val stackLinks = srcC.node.getLinksInRange(srcC.offset, len)
            if (stackLinks.isNotEmpty()) {
                // Note that even if nonStackSumC is a summarized node then it will have one link per field's size.
                // We should have at most four links, each one for *i8, *i16, *i32, and *i64.
                // Thus, we iterate over each field's size of the summarized node.
                // This means that we will unify two links only if they have the same size.
                val nonStackFields = ArrayList<PTAField>()
                // We copy the fields to avoid invalidating iterators
                nonStackFields.addAll(dstC.node.getSuccs().keys)
                for (nonStackField in nonStackFields) {
                    check(nonStackField.offset == 0L) { "${dstC.node} is summarized so its offset should be 0" }
                    val links = stackLinks.filter { (f, _) -> f.size == nonStackField.size }.map { (f, _) -> f }
                    if (links.isEmpty()) {
                        continue
                    }
                    // First, we unify all links in the stack
                    unifyLinks(srcC.node, links)
                    // Second, we unify the unified stack links with the non-stack link
                    val unifiedStackSuccC = srcC.node.getSucc(links.first())
                    check(unifiedStackSuccC != null) { "unexpected null in memcpyStackToSumm (1)" }
                    val nonStackSumSuccC = dstC.node.getSucc(nonStackField)
                    if (nonStackSumSuccC != null) {
                        // It's possible that nonStackSumSuccC is null if nonStackSumC.node's links are redirected because
                        // of a previous unification.
                        unifiedStackSuccC.unify(nonStackSumSuccC)
                        if (!getStack().isExactNode()) {
                            throw PointerDomainError("stack unexpectedly summarized in memcpyStackToSumm")
                        }
                    }
                }
            }
        }

        /**
         * memcpy from [srcC] to [dstC] where the source is on the stack and
         * the destination is not on the stack, but its fields are being tracked precisely.
         */
        fun memcpyStackToExact(srcC: PTACell, len: Long, dstC: PTACell) {
            check(srcC.node == getStack()) { "Precondition of memcpyStackToExact (1)" }
            check(dstC.node.isExactNode()) { "Precondition of memcpyStackToExact (2)" }

            val srcLinks = srcC.node.getLinksInRange(srcC.offset, len, isStrict=true, onlyPartial = false)
            val dstLinks = dstC.node.getLinksInRange(dstC.offset, len, isStrict = true, onlyPartial = false)
            val adjustedOffset = dstC.offset - srcC.offset
            val unifications = ArrayList<Pair<PTASymCell, PTASymCell>>()
            val additions = ArrayList<Pair<PTAField, PTACell>>()
            // 1. If a link exists in both source and destination we unify them
            // 2. If a link doesn't exist on the source but exists on the destination we do nothing.
            //    Note that we don't remove on destination because that would be a strong update.
            // 3. If a link exists on the source but doesn't exist on the destination: we add on destination.
            for ((srcField, srcSuccC) in srcLinks) {
                val dstField =  srcField.copy(offset= srcField.offset + adjustedOffset)
                val dstLink = dstLinks.find { (f, _) -> dstField == f }
                if (dstLink != null) {
                    val dstSuccC = dstLink.second
                    unifications.add(Pair(srcSuccC.node.createSymCell(PTASymOffset(srcSuccC.offset)),
                                          dstSuccC.node.createSymCell(PTASymOffset(dstSuccC.offset)) ))
                } else {
                    // I pass srcField instead of dstField (already adjusted offset) because
                    // copyLinks will do the adjustment.
                    additions.add(Pair(srcField, srcSuccC))
                }
            }

            copyLinks(srcC, dstC, additions, adjustedOffset)
            UnificationBatch(this, unifications) { sc, msg -> (::reifyCell)(sc, msg, null) }.run()
        }

        /** memcpy from non-stack to non-stack **/
        fun memcpyNonStackToNonStack(srcC: PTACell, dstC: PTACell) {
            check(srcC.node != getStack()) { "Precondition of memcpyNonStackToNonStack (1)" }
            check(dstC.node != getStack()) { "Precondition of memcpyNonStackToNonStack (2)" }

            dstC.unify(srcC)
            if (!getStack().isExactNode()) {
                throw PointerDomainError("stack cannot be summarized after memcpy (1)")
            }
        }

        /**
         *  These are the cases covered:
         *     E: exact (i.e., non-summarized)
         *     S: summarized
         *     *: exact or summarized
         *
         *  ```
         *      src             dst            length      strong/weak updates
         *  -----------------------------------------------------------------
         *     stack           stack            known           strong
         *     non-stack-E     stack            known           strong
         *   ----------------------------------------------------------------
         *     non-stack-E  non-stack-E      known/unknown      weak
         *     non-stack-S  non-stack-S
         *     non-stack-E  non-stack-S
         *     non-stack-S  non-stack-E
         *   -----------------------------------------------------------------
         *     non-stack-S     stack            known           strong
         *   -----------------------------------------------------------------
         *     stack        non-stack-E         known           weak
         *     stack        non-stack-S
         *   ------------------------------------------------------------------
         *  ```
         *
         *  Therefore, if length is statically known then we implement all possible cases.
         *  However, if length is unknown then we only implement the cases where stack is not involved.
         *  If this is the case then we will throw a runtime exception.
         */

        val r1 = Value.Reg(SbfRegister.R1_ARG)
        val r2 = Value.Reg(SbfRegister.R2_ARG)
        val r3 = Value.Reg(SbfRegister.R3_ARG)
        val length = (scalars.getValue(r3).get() as? SbfType.NumType)?.value?.get()
        // For instance, RawVec can call memcpy with length == 0 and destination being a small number
        // (alignment of the data type being transferred)
        // https://github.com/anza-xyz/rust/blob/solana-1.79.0/library/alloc/src/raw_vec.rs#L148
        val dstSc = getRegCell(r1, scalars.getValue(r1).get(), globals, locInst, stopIfError = length != 0L)
            ?: throw UnknownPointerDerefError(DevErrorInfo(locInst, PtrExprErrReg(r1), "memcpy: r1 does not point to a graph node in $this"))
        val srcSc = getRegCell(r2, scalars.getValue(r2).get(), globals, locInst, stopIfError = true)
            ?: throw UnknownPointerDerefError(DevErrorInfo(locInst, PtrExprErrReg(r2),"memcpy: r2 does not point to a graph node in $this"))

        srcSc.node.setRead()
        dstSc.node.setWrite()

        if (dstSc.node == getStack() && dstSc.isReified() && srcSc.node.isExactNode() && srcSc.isReified() && length != null) {
            // destination is stack and source is either stack or non-summarized.
            val dstC = dstSc.reify() // it won't change anything
            val srcC = srcSc.reify() // it won't change anything
            memcpyExactToStack(srcC, length, dstC)
        } else if (dstSc.node != getStack() && srcSc.node != getStack()) {
            // If no stack is involved then we can just unify source links
            // with destination's links, even if length is not statically known.
            // This is sound but it can be imprecise.
            val dstC = dstSc.reify()
            val srcC = srcSc.reify()
            memcpyNonStackToNonStack(srcC, dstC)
        } else if (dstSc.node == getStack() && dstSc.isReified() && length != null) {
            // destination is stack and source is a summarized node
            val srcC = srcSc.reify() // it might collapse destination if its offset was already top
            val dstC = dstSc.reify() // it doesn't change anything
            check(!srcC.node.isExactNode()) {"Expected summarized node $srcC for source during PTA memcpy"}
            memcpySummToStack(srcC, length, dstC)
        }  else if (srcSc.node == getStack() && srcSc.isReified() && length != null) {
            // source is the stack and destination is a non-stack node (summarized or not)
            val dstC = dstSc.reify() // it might collapse destination if its offset was already top
            val srcC = srcSc.reify() // it doesn't change anything
            if (dstC.node.isExactNode()) {
                memcpyStackToExact(srcC, length, dstC)
            } else {
                memcpyStackToSumm(srcC, length, dstC)
            }
        } else {
            // Note that for non-stack memory, we cannot kill destination's fields because next time we
            // read from there we will return a fresh cell pretending that it is the first read.
            throw PointerDomainError("cannot analyze memcpy(${dstSc.node}, ${srcSc.node}, $length)")
        }
    }

    /**
     *  We model memcmp as a sequence of len / wordSize loads of wordSize each
     *  where len is the number of bytes being compared.
     **/
    private fun doMemcmp(locInst: LocatedSbfInstruction, scalars: ScalarDomain, globals: GlobalVariableMap) {
        fun readWords(c1: PTACell, c2: PTACell, len: Int) {
            c1.node.setRead()
            c2.node.setRead()
            val wordSize = SolanaConfig.WordSize.get()
            val numOfWords = len / wordSize
            for (i in 0 until numOfWords) {
                val offset = wordSize.toLong() * i
                val width = wordSize.toShort()
                val f1 = PTAField(c1.offset + offset, width)
                val succ1 = c1.node.getSucc(f1)
                if (succ1 == null) {
                    // we make sure that we assign a fresh, disjoint cell to each word
                    val allocC = reifyCell(externAlloc.alloc(locInst, i*2), "external allocation", locInst)
                    updateLink(locInst, c1.node.createCell(f1.offset), width, allocC, false)
                }
                val f2 = PTAField(c2.offset + offset, width)
                val succ2 = c2.node.getSucc(f2)
                if (succ2 == null) {
                    // we make sure that we assign a fresh, disjoint cell to each word
                    val allocC = reifyCell(externAlloc.alloc(locInst, (i*2)+1), "external allocation", locInst)
                    updateLink(locInst, c2.node.createCell(f2.offset), width, allocC, false)
                }
            }
        }

        val r1 = Value.Reg(SbfRegister.R1_ARG)
        val r2 = Value.Reg(SbfRegister.R2_ARG)
        val r3 = Value.Reg(SbfRegister.R3_ARG)

        val sc1 = getRegCell(r1, scalars.getValue(r1).get(), globals, locInst)
            ?: throw UnknownPointerDerefError(DevErrorInfo(locInst, PtrExprErrReg(r1), "memcmp: r1 does not point to a graph node in $this"))
        val sc2 = getRegCell(r2, scalars.getValue(r2).get(), globals, locInst)
            ?: throw UnknownPointerDerefError(DevErrorInfo(locInst, PtrExprErrReg(r2),"memcmp: r2 does not point to a graph node in $this"))
        val len = (scalars.getValue(r3).get() as? SbfType.NumType)?.value?.get()
        if (len != null) {
            val c1 = reifyCell(sc1, "reification of r1 in memcmp", locInst)
            val c2 = reifyCell(sc2, "reification of r2 in memcmp", locInst)
            readWords(c1, c2, safeLongToInt(len))
        }

        // the scalar domain already models that the return value is a number
        forget(Value.Reg(SbfRegister.R0_RETURN_VALUE))
    }

    @TestOnly
    fun doMemset(locInst: LocatedSbfInstruction, scalars: ScalarDomain, globals: GlobalVariableMap) {
        val r1 = Value.Reg(SbfRegister.R1_ARG)
        val r3 = Value.Reg(SbfRegister.R3_ARG)

        val sc1 = getRegCell(r1, scalars.getValue(r1).get(), globals, locInst)
            ?: throw UnknownPointerDerefError(DevErrorInfo(locInst, PtrExprErrReg(r1),"memset: r1 does not point to a graph node in $this"))
        val len = (scalars.getValue(r3).get() as? SbfType.NumType)?.value?.get()
        if (len != null) {
            val c1 = reifyCell(sc1, "reification of r1 in memset", locInst)
            if (c1.node == getStack()) {
                removeLinks(c1, len)
            } else {
                ptaWarning {"The pointer domain skipped ${locInst.inst} because it is not on the stack"}
            }
        } else {
            ptaWarning {"The pointer domain skipped ${locInst.inst} because length is not statically known"}
        }
    }


    private fun doSolMemInst(memInst: SolanaFunction,
                             globals: GlobalVariableMap,
                             scalars: ScalarDomain,
                             locInst: LocatedSbfInstruction) {
        val inst = locInst.inst
        check(inst is SbfInstruction.Call) {"doSolMemInst expects a call instead of $inst"}

        when (memInst) {
            SolanaFunction.SOL_MEMCPY -> {
                doMemcpy(locInst, scalars, globals)
            }
            SolanaFunction.SOL_MEMCMP -> {
                doMemcmp(locInst, scalars, globals)
            }
            SolanaFunction.SOL_MEMMOVE -> {
                ptaWarning {"The pointer domain skipped $memInst because it is unsupported"}
            }
            SolanaFunction.SOL_MEMSET -> {
                doMemset(locInst, scalars, globals)
            }
            else -> { }
        }
    }

    /** Transfer function for __CVT_save_scratch_registers **/
    private fun saveScratchRegisters() {
        pushScratchReg(registers[6])
        pushScratchReg(registers[7])
        pushScratchReg(registers[8])
        pushScratchReg(registers[9])
    }

    /**
     *  Any field that has an offset greater than the top of the stack is dead because
     *  a caller can never access to a callee stack.
     */
    private fun removeDeadStackFields() {
        val stack = getStack()
        if (!stack.isExactNode()) {
            return
        }
        val c = getRegCell(Value.Reg(SbfRegister.R10_STACK_POINTER))
        check(c != null) {"r10 should point always to a cell"}
        val topStack = c.offset.get() ?: return

        // 1. Remove all dead links
        val deadLinks = ArrayList<Pair<PTAField, PTACell>>()
        for ((field, succC) in stack.getSuccs()) {
            if (field.offset > topStack) {
                deadLinks.add(Pair(field, succC))
            }
        }
        stack.removeLinks(deadLinks)

        // 2. Remove all dead fields from the set of untracked fields
        untrackedStackFields = untrackedStackFields.removeAll {
            it.offset > topStack
        }

    }


    /**
     *  Transfer function for __CVT_restore_scratch_registers
     *  Invariant ensured by CFG construction: r10 has been decremented already.
     */
    private fun restoreScratchRegisters() {
        if (scratchRegisters.size < 4) {
            throw PointerDomainError("The number of calls to save/restore scratch registers must match")
        }
        setRegCell(Value.Reg(SbfRegister.R9), popScratchReg())
        setRegCell(Value.Reg(SbfRegister.R8), popScratchReg())
        setRegCell(Value.Reg(SbfRegister.R7), popScratchReg())
        setRegCell(Value.Reg(SbfRegister.R6), popScratchReg())
    }

    /**
     * dealloc(r1,r2,r3) where
     *  - r1 is a pointer that points to the memory to be deallocated
     *  - r2 is usize that contains the size
     *  - r3 is usize that contains the alignment
     *
     * Do nothing when we dealloc a pointer is sound, but it can be very imprecise because it might trigger unnecessary
     * unifications. The flow-sensitive components of the abstract domain can be "garbage-collected".
     * If we know that either a register or a stack field points to a **singleton** memory object then we can assume
     * that after the deallocation they point to unreachable memory.
     * Note that we always have the assumption of memory safety. Thus, the code shouldn't access to that unreachable memory.
     */
    private fun doDealloc() {
        fun isSingletonHeaplet(n: PTANode): Boolean {
            if (!SolanaConfig.OptimisticDealloc.get()) {
                /**
                 * Enable optimisticDealloc is potentially unsound.
                 * We need to prove that node is a singleton, i.e., it represents exactly one concrete memory object.
                 * For a node to be exact node is not enough to prove that.
                 * We need to extend the pointer analysis to keep track of this kind of information.
                 **/
                return false
            }
            return n.isExactNode() && n.isMayHeap && (!n.isMayInteger && !n.isMayStack && !n.isMayExternal)
        }

        val r1Sc = getRegCell(Value.Reg(SbfRegister.R1_ARG))
        if (r1Sc != null) {
            if (r1Sc.isReified()) {
                val n = r1Sc.reify().node
                if (isSingletonHeaplet(n)) {
                    // If some register rX points to the singleton object then we set it to top
                    for (i in 0 until NUM_OF_SBF_REGISTERS) {
                        val sc = registers[i]
                        if (sc != null && sc.isReified()) {
                            // Although it might look counterintuitive, if we skip the register because we don't want to
                            // reify its pointee that's sound. In fact, when we set the register to top is when we can
                            // gain precision by avoiding extra unifications.
                            if (sc.reify().node == n) {
                                setRegCell(Value.Reg(SbfRegister.getByValue(i.toByte())), null)
                            }
                        }
                    }

                    // If some stack field points to the singleton object then we can set it to top
                    val stackN = getStack()
                    val links = ArrayList<Pair<PTAField, PTACell>>()
                    for ((field, c) in stackN.getSuccs()) {
                        if (c.node == n) {
                            links.add(Pair(field, c))
                        }
                    }
                    stackN.removeLinks(links) { f ->
                        untrackedStackFields = untrackedStackFields.add(f)
                    }
                }
            }
        }
    }

    fun doCall(calleeLocInst: LocatedSbfInstruction,
               globals: GlobalVariableMap,
               memSummaries: MemorySummaries,
               scalars: ScalarDomain) {

        val callee = calleeLocInst.inst
        check(callee is SbfInstruction.Call) {"doCall expects a call instead of $callee"}
        val name = callee.name
        val solFunction = SolanaFunction.from(name)
        if (solFunction != null) {
            /** Solana syscall **/
            when (solFunction) {
                SolanaFunction.SOL_LOG, SolanaFunction.SOL_LOG_64 -> {
                    forget(Value.Reg(SbfRegister.R0_RETURN_VALUE))
                }
                SolanaFunction.SOL_MEMCPY, SolanaFunction.SOL_MEMMOVE, SolanaFunction.SOL_MEMSET, SolanaFunction.SOL_MEMCMP ->
                    doSolMemInst(solFunction, globals, scalars, calleeLocInst)
                SolanaFunction.SOL_ALLOC_FREE -> throw PointerDomainError("TODO(4): support sol_alloc_free")
                SolanaFunction.SOL_GET_CLOCK_SYSVAR -> summarizeCall(calleeLocInst, globals, scalars, memSummaries)
                else -> {
                    ptaWarning { "The pointer domain summarized $callee by only havocing r0" }
                    forget(Value.Reg(SbfRegister.R0_RETURN_VALUE))
                }
            }
        } else {
            val cvtFunction = CVTFunction.from(name)
            if (cvtFunction != null) {
                /** CVT call */
                when (cvtFunction) {
                    CVTFunction.SAVE_SCRATCH_REGISTERS -> saveScratchRegisters()
                    CVTFunction.RESTORE_SCRATCH_REGISTERS -> restoreScratchRegisters()
                    CVTFunction.ASSERT, CVTFunction.ASSUME -> {
                        throw PointerDomainError("unsupported call to $name. " +
                            "SimplifyBuiltinCalls::renameCVTCall was probably not called.")
                    }
                    CVTFunction.SATISFY, CVTFunction.SANITY,
                    CVTFunction.CEX_PRINT_i64_1, CVTFunction.CEX_PRINT_i64_2, CVTFunction.CEX_PRINT_i64_3,
                    CVTFunction.CEX_PRINT_TAG, CVTFunction.CEX_PRINT_LOCATION, CVTFunction.CEX_ATTACH_LOCATION,
                    CVTFunction.CEX_PRINT_STRING,
                    CVTFunction.CEX_PRINT_u64_1, CVTFunction.CEX_PRINT_u64_2, CVTFunction.CEX_PRINT_u64_3-> {}

                    CVTFunction.NONDET_i8, CVTFunction.NONDET_i16, CVTFunction.NONDET_i32, CVTFunction.NONDET_i64,
                    CVTFunction.NONDET_u8, CVTFunction.NONDET_u16, CVTFunction.NONDET_u32, CVTFunction.NONDET_u64,
                    CVTFunction.NONDET_usize, CVTFunction.NONDET_u128,
                    CVTFunction.NONDET_ACCOUNT_INFO,
                    CVTFunction.U128_LEQ, CVTFunction.U128_GT0, CVTFunction.U128_CEIL_DIV,
                    CVTFunction.NATIVEINT_EQ, CVTFunction.NATIVEINT_LT, CVTFunction.NATIVEINT_LE,
                    CVTFunction.NATIVEINT_ADD, CVTFunction.NATIVEINT_SUB,
                    CVTFunction.NATIVEINT_MUL, CVTFunction.NATIVEINT_DIV, CVTFunction.NATIVEINT_CEIL_DIV,
                    CVTFunction.NATIVEINT_MULDIV, CVTFunction.NATIVEINT_MULDIV_CEIL,
                    CVTFunction.NATIVEINT_NONDET,
                    CVTFunction.NATIVEINT_FROM_u128, CVTFunction.NATIVEINT_FROM_u256,
                    CVTFunction.NATIVEINT_u64_MAX, CVTFunction.NATIVEINT_u128_MAX, CVTFunction.NATIVEINT_u256_MAX,
                    CVTFunction.NONDET_SOLANA_ACCOUNT_SPACE -> {
                        summarizeCall(calleeLocInst, globals, scalars, memSummaries)
                    }
                    CVTFunction.ALLOC_SLICE -> {
                        summarizeAllocSlice(calleeLocInst, globals, scalars)
                    }
                }
            } else {
                /** SBF to SBF call */
                if (callee.isAllocFn()) {
                    setRegCell(Value.Reg(SbfRegister.R0_RETURN_VALUE), heapAlloc.highLevelAlloc(calleeLocInst))
                } else if (callee.isDeallocFn()) {
                    doDealloc()
                } else {
                    summarizeCall(calleeLocInst, globals, scalars, memSummaries)
                }
            }
        }
    }

    // precondition: function names have been already demangled
    private fun summarizeCall(locInst: LocatedSbfInstruction,
                              globals: GlobalVariableMap,
                              scalars: ScalarDomain,
                              memSummaries: MemorySummaries) {

        class PointerSummaryVisitor: SummaryVisitor {
            private var curArg: Int = 1
            override fun noSummaryFound(locInst: LocatedSbfInstruction) {
                forget(Value.Reg(SbfRegister.R0_RETURN_VALUE))
                ptaWarning { "The pointer domain summarized ${locInst.inst} by only havocing r0" }
            }

            override fun processReturnArgument(locInst: LocatedSbfInstruction, type: MemSummaryArgumentType) {

                val r0 = Value.Reg(SbfRegister.R0_RETURN_VALUE)
                when (type) {
                    MemSummaryArgumentType.PTR_EXTERNAL, MemSummaryArgumentType.PTR_INPUT  -> {
                        setRegCell(r0, externAlloc.alloc(locInst))
                    }
                    MemSummaryArgumentType.PTR_HEAP -> {
                        setRegCell(r0, heapAlloc.highLevelAlloc(locInst))
                    }
                    MemSummaryArgumentType.NUM -> {
                        setRegCell(r0, integerAlloc.alloc(locInst))
                    }
                    else -> {
                        forget(r0)
                    }
                }
            }

            override fun processArgument(
                locInst: LocatedSbfInstruction,
                reg: SbfRegister,
                offset: Long,
                width: Byte,
                @Suppress("UNUSED_PARAMETER") allocatedSpace: ULong,
                type: MemSummaryArgumentType
            ) {
                val call = locInst.inst
                check(call is SbfInstruction.Call) {"processArgument expects a call instead of $call"}
                curArg++
                when (type) {
                    MemSummaryArgumentType.PTR_EXTERNAL,
                    MemSummaryArgumentType.PTR_HEAP,
                    MemSummaryArgumentType.NUM -> {
                        val valReg = Value.Reg(reg)
                        val v = scalars.getValue(valReg)
                        val sc1 = getRegCell(valReg, v.get(), globals, locInst)
                        check(sc1 != null) { "unexpected situation while summarizing $call" }
                        val c1 = reifyCell(sc1, "$call (1)", locInst)

                        val c2 = c1.node.createCell(c1.offset + offset)
                        // Remove old link
                        val f2 = PTAField(c2.offset, width.toShort())
                        // We don't call removeField because it also removes predecessors of f2 which we want to keep
                        val succC2 = c2.node.getSucc(f2)
                        if (succC2 != null) {
                            c2.node.removeEdge(f2, succC2)
                        }
                        check(c2.node.getSucc(f2) == null){"Field $f2 was not removed properly from ${c2.node}"}
                        // Add new link
                        val allocatedC = when (type) {
                            MemSummaryArgumentType.PTR_HEAP -> {
                                reifyCell(heapAlloc.highLevelAlloc(locInst, curArg), "$call (2)", locInst)
                            }
                            MemSummaryArgumentType.PTR_EXTERNAL -> {
                                reifyCell(externAlloc.alloc(locInst, curArg), "$call (3)", locInst)
                            }
                            else -> {
                                reifyCell(integerAlloc.alloc(locInst, curArg), "$call (4)", locInst)
                            }
                        }
                        allocatedC.node.setWrite()
                        updateLink(locInst, c2, width.toShort(), allocatedC, false)

                    }
                    else -> {
                        throw PointerDomainError("Summary not supported for $call: argument $reg with type $type")
                    }
                }
            }
        }

        val vis = PointerSummaryVisitor()
        memSummaries.visitSummary(locInst, vis)
    }

    /**
     * `cvt_alloc_slice(base:ptr, offset:usize, size:usize) -> ptr`
     *
     *  Preconditions:
     *   1) `base` is the base of some allocated object `X`
     *   2) the size of object `X` must be greater than `offset` + `size`.
     *
     *  Return a pointer that points to a fresh allocated object of size `size` whose address is `base` + `offset`
     *
     *  **IMPORTANT**: precondition 2 cannot be checked by the pointer analysis so we will assume that it always holds.
     **/
    private fun summarizeAllocSlice(locInst: LocatedSbfInstruction,
                                   globals: GlobalVariableMap,
                                   scalars: ScalarDomain) {


        val r0 = Value.Reg(SbfRegister.R0_RETURN_VALUE)
        val r1 = Value.Reg(SbfRegister.R1_ARG)
        val r2 = Value.Reg(SbfRegister.R2_ARG)

        val offset = (scalars.getValue(r2).get() as? SbfType.NumType)?.value?.get() ?:
            throw PointerDomainError("cannot know statically the value of offset (r2)." +
                "\n\t$locInst\n" +
                "\t$this")

        val baseSc = getRegCell(r1, scalars.getValue(r1).get(), globals, locInst) ?:
            throw PointerDomainError("CVT_alloc_size: r1 does not point to a node" +
                "\t$locInst\n" +
                "\t$this")

        val baseC = reifyCell(baseSc, "CVT_alloc_size", locInst)
        if (baseC.node == getStack()) {
            throw PointerDomainError("The base pointer (r1) is a stack pointer and this is not supported.\n" +
                "\t$locInst\n" +
                "\tbase cell = $baseC\n" +
                "\toffset = $offset\n" +
                "\tPTA graph =$this")
        }
        if (baseC.offset != 0L) {
            throw PointerDomainError("The offset of the base pointer (r1) should be zero.\n" +
                "\t$locInst\n" +
                "\tbase cell = $baseC\n" +
                "\toffset = $offset\n" +
                "\tPTA graph = $this")
        }

        // We cannot tell for sure whether a node is allocated in a particular region because we keep track of that as may information.
        // If a node might be allocated in more than one region we allocated first in external and then heap.
        if (baseC.node.isMayExternal) {
            val returnedC = externAlloc.alloc(locInst).node.createSymCell(Constant(offset))
            baseC.node.copyFlags(returnedC.node)
            setRegCell(r0, returnedC)
        } else if (baseC.node.isMayHeap) {
            val returnedC = heapAlloc.highLevelAlloc(locInst).node.createSymCell(Constant(offset))
            baseC.node.copyFlags(returnedC.node)
            setRegCell(r0, returnedC)
        } else {
            throw PointerDomainError("The base pointer (r1) is from an unexpected region:\n" +
                "\t$locInst\n" +
                "\tbase cell = $baseC\n" +
                "\toffset = $offset\n" +
                "\tPTA graph = $this")
        }
    }



    private class PrettyPrinterVisitor(val sb: StringBuilder): PTAGraphVisitAction {
        var numNodes = 0
        val visited = mutableSetOf<PTANode>()

        override fun applyBeforeSuccessor(n: PTANode) {
            if (!visited.add(n)) {
                return
            }

            if (numNodes > 0) {
                sb.append(",")
            }
            sb.append("$n")
            if (n.getSuccs().isEmpty()) {
                sb.append("{}")
            } else {
                sb.append("{")
                var i = 0
                for ((field, succC) in n.getSuccs().toSortedMap()) {
                    sb.append("$field -> ")
                    sb.append(if (succC == null) {
                        "void"
                    } else {
                        "$succC"
                    })
                    i++
                    if (i < n.getSuccs().size) {
                        sb.append(",")
                    }
                }
                sb.append("}")
            }
            numNodes += 1
        }
        override fun applyAfterSuccessor(n: PTANode) {}
        override fun skipSuccessors(n: PTANode): Boolean {
            return false
            //  return (visited.contains(n))
        }
    }

    override fun toString(): String {
        fun registersToString(regs: List<PTASymCell?>, start: Int): String {
            val sb = StringBuilder()
            var numPrintedReg = 0
            for ((i, cell) in regs.withIndex()) {
                if (cell != null) {
                    if (numPrintedReg > 0) {
                        sb.append(",")
                    }
                    sb.append("r${i+start} -> $cell")
                    numPrintedReg += 1
                }
            }
            return sb.toString()
        }

        val sb = StringBuilder()

        sb.append("(\nRegs={${registersToString(registers, start = 0)}}")
        //sb.append(",\nScratchRegs={${registersToString(scratchRegisters, start = 6)}}")
        sb.append(",\nScratchRegs=$scratchRegisters")
        sb.append(",\nTop stack fields=$untrackedStackFields")
        sb.append(",\nGraph={")
        val vis = PrettyPrinterVisitor(sb)
        for (cell in registers) {
            if (cell != null) {
                ptaGraphVisit(cell.node, vis)
            }
        }
        sb.append("}\n)")
        return sb.toString()
    }

    // Precondition: graphName must be a single word without spaces in between
    fun toDot(isEmbedded: Boolean, graphName: String, bgColor:String = "lightblue"): String {
        fun nodeToId(n: PTANode): String {
            // assume graphName are unique
            // return System.identityHashCode(n)
            return graphName + "_PTA_NODE_" + n.id.toString()
        }

        fun regToId(reg: Int): String {
            // assume graphName are unique
            return graphName + "_REG_" + reg.toString()
        }

        fun normalizeField(field: Long, access: NodeAccess): String {
            return if (access == NodeAccess.None) {
                "0"
            } else {
                if (field >= 0) {
                    field.toString()
                } else {
                    "minus${field.absoluteValue}"
                }
            }
        }

        class DotVisitor(val sb: StringBuilder): PTAGraphVisitAction {
            val visited = mutableSetOf<PTANode>()

            fun skipNode(@Suppress("UNUSED_PARAMETER") n: PTANode): Boolean {
              return false
            }

            override fun applyBeforeSuccessor(n: PTANode) {

                if (!visited.add(n)) {
                    return
                }

                if (skipNode(n)) {
                    return
                }

                sb.append("Node${nodeToId(n)}  ")
                sb.append("[shape=record,fontname=Helvetica,fontsize=10,label=\"{")

                var addSep = false
                sb.append("Id=${n.id} ")

                if (n.access != NodeAccess.None) {
                    if (n is PTASummarizedNode) {
                        sb.append("SUMMARY ")
                    } else if (n is PTASummarizedWithStrideNode) {
                        sb.append("SUMMARY(stride=${n.getStride()}) ")
                    }
                }

                if (n.isMayGlobal) {
                    if (addSep) {
                        sb.append(":")
                    }
                    sb.append("Global")
                    addSep = true
                }
                if (n.isMayExternal) {
                    if (addSep) {
                        sb.append(":")
                    }
                    sb.append("Extern")
                    addSep = true
                }
                if (n.isMayInteger) {
                    if (addSep) {
                        sb.append(":")
                    }
                    sb.append("Int")
                    addSep = true
                }
                if (n.isMayHeap) {
                    if (addSep) {
                        sb.append(":")
                    }
                    sb.append("Heap")
                    addSep = true
                }
                if (n.isMayStack) {
                    if (addSep) {
                        sb.append(":")
                    }
                    sb.append("Stack")
                }

                when (n.access) {
                    NodeAccess.Any -> {
                        if (addSep) {
                            sb.append(":")
                        }
                        sb.append("RX")
                    }
                    NodeAccess.Read -> {
                        if (addSep) {
                            sb.append(":")
                        }
                        sb.append("R")
                    }
                    NodeAccess.Write -> {
                        if (addSep) {
                            sb.append(":")
                        }
                        sb.append("X")
                    }
                    NodeAccess.None -> {
                        if (addSep) {
                            sb.append(":")
                        }
                        sb.append("U")
                    }
                }


                sb.append("|{")

                val fields: MutableSet<PTAOffset> = mutableSetOf()
                fields.add(mkOffset(0L))

                if (n.access != NodeAccess.None) {
                    for ((field, succC) in n.getSuccs()) {
                        if (!skipNode(succC.node)) {
                            fields.add(field.offset)
                        }
                    }
                    for (o in n.getPreds().keys) {
                        fields.add(o)
                    }
                    for (c in registers) {
                        if (c != null) {
                            if (c.node == n) {
                                val o = c.offset.get()
                                if (o != null) {
                                    fields.add(o)
                                }
                            }
                        }
                    }
                }

                // If the node is summarized then the only field should be 0
                check(n !is PTASummarizedNode || fields.size == 1)
                {"summarized node can only have one field"}

                var i = 0
                for (field in fields.toSortedSet()) {
                    sb.append(if (n !is PTASummarizedNode || n.access == NodeAccess.None) {
                        "<f${normalizeField(field, n.access)}>${field}"
                    } else {
                        "<f${normalizeField(field, n.access)}>oo"
                    })
                    i++
                    if (i < fields.size) {
                        sb.append("|")
                    }
                }

                sb.append("}}\"]\n")

                for ((field, succC) in n.getSuccs().toSortedMap()) {
                    if (succC != null && !skipNode(succC.node)) {
                        sb.append("Node${nodeToId(n)}:f${normalizeField(field.offset, n.access)} -> ")
                        sb.append("Node${nodeToId(succC.node)}:f${normalizeField(succC.offset, succC.node.access)} [arrowsize=0.3,label=\"${succC.offset}\"]\n")
                    }
                }
            }

            override fun applyAfterSuccessor(n: PTANode) {}
            override fun skipSuccessors(n: PTANode): Boolean {
                return false
            }
        }

        val sb = StringBuilder()
        if (!isEmbedded) {
            sb.append("digraph \"PTA graph for \'$graphName\'\"{\n")
            sb.append("\tlabel=\"PTA graph for \'$graphName\'\";\n")
            sb.append("graph [center=true,ratio=true,bgcolor=${bgColor},fontname=Helvetica,minlen=0];\n")
        }

        //vis.str += "rank=same;\n"

        if (isEmbedded) {
            // this node is an invisible one used to connect from outside to this subgraph
            sb.append("Node${graphName}_ENTRY [shape=plaintext,label=\"\"];\n")
        }


        val vis = DotVisitor(sb)
        for (cell in registers) {
            if (cell != null) {
                ptaGraphVisit(cell.node, vis)
            }
        }

        for ((i, cell) in registers.withIndex()) {
            if (cell == null) {
                continue
            }
            sb.append("Node${regToId(i)} ")
            sb.append("[shape=plaintext,fontname=Helvetica,fontsize=10,label=\"r${i}\"]\n")
            val o = cell.offset.get()
            if (o != null) {
                sb.append("Node${regToId(i)} -> Node${nodeToId(cell.node)}:f${normalizeField(o, cell.node.access)} [arrowtail=tee,arrowsize=0.3]\n")
            } else {
                sb.append("Node${regToId(i)} -> Node${nodeToId(cell.node)}:f0 [arrowtail=tee,arrowsize=0.3,style=\"dashed\",color=\"red\",label=\"top\"]\n")
            }
        }

        if (!isEmbedded) {
            sb.append("}\n")
        }
        return sb.toString()
    }
}

interface PTAGraphVisitAction {
    fun applyBeforeSuccessor(n: PTANode)
    fun applyAfterSuccessor(n: PTANode)
    fun skipSuccessors(n: PTANode): Boolean
}

fun ptaGraphVisit(n: PTANode, vis:PTAGraphVisitAction) {
    val visited = mutableSetOf<PTANode>()
    val worklist = ArrayList<PTANode>()
    worklist.add(n)
    visited.add(n)
    while (worklist.isNotEmpty()) {
        val x = worklist.last()
        worklist.removeLast()
        vis.applyBeforeSuccessor(x)
        if (!vis.skipSuccessors(x)) {
            for (field in x.getSuccs()) {
                val c = field.value
                val succ = c.node
                if (visited.add(succ)) {
                    worklist.add(succ)
                }
            }
        }
        vis.applyAfterSuccessor(x)
    }
}

/*********** Only for debugging  **************/

@Suppress("UtilityClassWithPublicConstructor")
class OpCounter {
    companion object {
        var value:ULong = 0UL
    }
}

class BinaryOperationToDot(private val opName:String) {
    private var strDot:String = ""
    private var lastOpId = 0UL

    fun addOperands(g1: PTAGraph, g2: PTAGraph, b1: Label?, b2: Label?) {
        lastOpId = OpCounter.value
        val leftOp = if (b1 != null) {
            "Block $b1"
        } else {
            "Left operand"
        }
        val rightOp =
                if (b2 != null) {
                    "Block $b2"
                } else {
                    "Right operand"
                }

        strDot = "digraph \"PTA Graphs for \'$opName\'\"{\n" +
                "\tlabel=\"PTA Graphs for \'$opName\'\";\n" +
                "graph [center=true,ratio=true,bgcolor=lightyellow,fontname=Helvetica,minlen=0];\n" +
                "subgraph cluster_left {\n" +
                "label=\"${leftOp}\";\n" +
                g1.toDot(true, "leftOp") +
                "}\n" +
                "subgraph cluster_right {\n" +
                "label=\"${rightOp}\";\n" +
                g2.toDot(true, "rightOp") +
                "}\n"
        OpCounter.value++
    }

    // If the binary operation returns a graph
    fun addResultAndPrint(g: PTAGraph, b1: Label?, b2: Label?) {
        strDot += "subgraph cluster_result {\n" +
                "label=\"Result\";\n" +
                g.toDot(true, "result") +
                "}\n" +
                "}\n"
        val outFile = opName + "_${lastOpId}" + "-$b1#$b2"
        printToFile("$outFile.dot", strDot)
    }

    // If the binary operation does not return another graph
    fun print(): String {
        strDot += "}\n"
        val outfile = opName +"_${lastOpId}.dot"
        printToFile(outfile, strDot)
        return outfile
    }
}
