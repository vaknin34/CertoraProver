/*
 *     The Certora Prover
 *     Copyright (C) 2025  Certora Ltd.
 *
 *     This program is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU General Public License as published by
 *     the Free Software Foundation, version 3 of the License.
 *
 *     This program is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU General Public License for more details.
 *
 *     You should have received a copy of the GNU General Public License
 *     along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

package statistics.data

import analysis.CmdPointer
import analysis.asSnippetCmd
import kotlinx.serialization.Serializable
import utils.`to?`
import vc.data.CoreTACProgram
import vc.data.SnippetCmd
import datastructures.stdcollections.*

@Serializable
data class LoopStats(
    val global: Data,
    val perCallId: List<Pair<CallIdWithName, Data>>?
): PrettyPrintableStats {

    override val asText: String
        get() = "Loops: " +
            global.toString()

    override val liveStatsSummaryText get() =
        global.asValueText

    override val severityGlobal: PrettyPrintableStats.Severity
        get() = global.longestLoop.let { globallyLongestLoop ->
            when {
                (globallyLongestLoop == null) -> PrettyPrintableStats.Severity.UNKNOWN
                globallyLongestLoop <= 1 -> PrettyPrintableStats.Severity.LOW
                globallyLongestLoop <= 3 -> PrettyPrintableStats.Severity.MEDIUM
                else -> PrettyPrintableStats.Severity.HIGH
            }
        }

    /**
     * The LoopStats [Data] object is counting:
     * - what is the longest loop in the program, namely, the loop with the biggest number of unrollings
     * - the number of loops in the program (including, for example, compiler-generated loops - that can confuse users who thought
     *      their code has no loops, but an exponent operation led to a fast-exponentiation loop generated by the compiler,
     *      copy loops, storage-to-memory copies, and other mysterious sources of loops).
     */
    @Serializable
    class Data(val longestLoop: Int?, val numberOfLoops: Int?) {
        override fun toString(): String {
            return longestLoop?.let { longestLoop -> "Longest loop: $longestLoop " }.orEmpty() +
                numberOfLoops?.let { numOfLoops -> "#loops: $numOfLoops" }.orEmpty()
        }

        val asValueText get() =
            listOfNotNull(
                longestLoop?.let { longestLoop -> "longest loop: $longestLoop" },
                numberOfLoops?.let { numOfLoops -> "loops: $numOfLoops" }
            ).joinToString("\n")
    }
    companion object {
        fun compute(
            prog: CoreTACProgram,
            callIdNames: Map<Int, String>?
        ): LoopStats {
            val g = prog.analysisCache.graph
            val endLoops = g.commands
                .mapNotNull { lcmd ->
                    lcmd.ptr `to?` lcmd.asSnippetCmd().let { it as? SnippetCmd.EVMSnippetCmd.LoopSnippet.EndLoopSnippet }
                }
                .toList()
            // for each end loop, try to find the last iteration.
            val endIters = g.commands
                .mapNotNull { lcmd ->
                    lcmd.ptr `to?` lcmd.asSnippetCmd().let { it as? SnippetCmd.EVMSnippetCmd.LoopSnippet.EndIter }
                }.toList()
            val lastIters = endLoops
                .mapNotNull { (_, endLoopSnip) ->
                    endIters.filter { it.second.loopId == endLoopSnip.loopId }.maxByOrNull { it.second.iteration }
                }.toList()

            fun getNumOfLoops(filter: (Pair<CmdPointer,SnippetCmd.EVMSnippetCmd.LoopSnippet.EndLoopSnippet>) -> Boolean)
                = endLoops.filter(filter).size

            fun getLongestLoop(filter: (Pair<CmdPointer, SnippetCmd.EVMSnippetCmd.LoopSnippet.EndIter>) -> Boolean)
                = lastIters.filter(filter).maxOfOrNull { it.second.iteration } ?: 0

            // global number of loops
            val globalNumOfLoops = getNumOfLoops { true }
            // globally longest loop
            val globallyLongestLoop = getLongestLoop { true }
            // per call stats
            val perCallId = mutableListOf<Pair<CallIdWithName, Data>>()
            callIdNames?.forEachEntry { (calleeIdx, name) ->
                val callIdWithName = CallIdWithName(calleeIdx, name)
                // number of loops
                val numOfLoops = getNumOfLoops { it.first.block.calleeIdx == calleeIdx }
                // longest loop
                val longestLoop = getLongestLoop { it.first.block.calleeIdx == calleeIdx }
                perCallId.add(callIdWithName to Data(longestLoop, numOfLoops))
            }

            return LoopStats(Data(globallyLongestLoop, globalNumOfLoops), perCallId)
        }
    }

}
