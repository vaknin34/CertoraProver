/*
 *     The Certora Prover
 *     Copyright (C) 2025  Certora Ltd.
 *
 *     This program is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU General Public License as published by
 *     the Free Software Foundation, version 3 of the License.
 *
 *     This program is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU General Public License for more details.
 *
 *     You should have received a copy of the GNU General Public License
 *     along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

package instrumentation

import analysis.*
import analysis.alloc.AllocationAnalysis
import analysis.smtblaster.*
import parallel.*
import parallel.ParallelPool.Companion.runInherit
import parallel.Scheduler.complete
import parallel.Scheduler.rpc
import smtlibutils.data.SmtExp
import solver.SolverConfig
import tac.MetaMap
import tac.NBId
import utils.*
import vc.data.*
import vc.summary.ComputeTACSummaryTransFormula
import vc.summary.SummarizeProgram
import vc.summary.TACSummaryVar
import java.math.BigInteger

/**
 * Summarizes code generated by the solidity compiler to decode
 * the packed length representation used in storage for bytes/strings.
 */
object StoragePackedLengthSummarizer {
    private const val lengthField = "LEN_FIELD"

    @KSerializable
    data class StorageLengthReadSummary(
        override val skipTarget: NBId,
        override val originalBlockStart: NBId,
        override val modifiedVars: Set<TACSymbol.Var>,
        override val summarizedBlocks: Set<NBId>,
        val readSort: AllocationAnalysis.Alloc.StorageUnpack.SizeReadSort,
        val outputVar: TACSymbol.Var
    ) : ConditionalBlockSummary {
        override val variables: Set<TACSymbol.Var>
            get() = setOf()
        override val annotationDesc: String
            get() = "Read length field from $readSort => $outputVar"

        override fun transformSymbols(f: (TACSymbol.Var) -> TACSymbol.Var): TACSummary {
            return StorageLengthReadSummary(
                skipTarget = skipTarget,
                originalBlockStart = originalBlockStart,
                modifiedVars = modifiedVars.mapToSet(f),
                summarizedBlocks = summarizedBlocks,
                readSort = when(readSort) {
                    is AllocationAnalysis.Alloc.StorageUnpack.SizeReadSort.UnpackRead -> {
                        AllocationAnalysis.Alloc.StorageUnpack.SizeReadSort.UnpackRead(
                            read = f(readSort.read)
                        )
                    }
                    is AllocationAnalysis.Alloc.StorageUnpack.SizeReadSort.WordLoad -> {
                        AllocationAnalysis.Alloc.StorageUnpack.SizeReadSort.WordLoad(
                            indexSym = (readSort.indexSym as? TACSymbol.Var)?.let(f) ?: readSort.indexSym
                        )
                    }
                },
                outputVar = f(outputVar)
            )
        }


        override fun remapBlocks(f: (NBId) -> NBId?): ConditionalBlockSummary {
            return StorageLengthReadSummary(
                skipTarget = f(skipTarget)!!,
                originalBlockStart = f(originalBlockStart)!!,
                modifiedVars = modifiedVars,
                summarizedBlocks = summarizedBlocks.mapNotNullTo(mutableSetOf(), f),
                readSort = readSort,
                outputVar = outputVar
            )
        }
    }

    private sealed class SummarizationMutSpec {
        abstract val output: TACSymbol.Var
        abstract val readSort: AllocationAnalysis.Alloc.StorageUnpack.SizeReadSort
        abstract val mutVariables: Set<TACSymbol.Var>

        /**
         * The storage decode is entirely contained in a single block between [startPoint] and [endPointer].
         * Commands in [commute] need to be moved out to [commuteTarget]
         */
        data class SimpleSplit(
            val startPoint: CmdPointer,
            val endPointer: CmdPointer,
            override val mutVariables: Set<TACSymbol.Var>,
            override val readSort: AllocationAnalysis.Alloc.StorageUnpack.SizeReadSort,
            override val output: TACSymbol.Var,
            val commute: List<LTACCmdView<TACCmd.Simple.AssigningCmd>>,
            val commuteTarget: LTACCmd
        ) : SummarizationMutSpec()

        /**
         * The code for decoding starts from [headSplit] and continues to include all of the code in [intermediateBlocks].
         * The first block that consumes the result of decoding is [decodeSuccessor]
         */
        data class MultiBlockSplit(
            val headSplit: CmdPointer,
            override val mutVariables: Set<TACSymbol.Var>,
            override val readSort: AllocationAnalysis.Alloc.StorageUnpack.SizeReadSort,
            override val output: TACSymbol.Var,
            val intermediateBlocks: Set<NBId>,
            val decodeSuccessor: NBId
        ) : SummarizationMutSpec()
    }


    private class Worker(val g: TACCommandGraph) {
        private val eqZeroPatt by lazy {
            PatternMatcher.compilePattern(graph = g, patt = PatternDSL.build {
                (BigInteger.ZERO() `==` Var).commute.locSecond
            })
        }

        val readFrom =
            PatternMatcher.Pattern.Or(
                PatternMatcher.Pattern.AssigningPattern0(
                    f = { where, it ->
                        if(it is TACCmd.Simple.AssigningCmd.WordLoad && it.base.meta.containsKey(
                                TACMeta.STORAGE_KEY)) {
                            PatternMatcher.ConstLattice.Match(where to AllocationAnalysis.Alloc.StorageUnpack.SizeReadSort.WordLoad(it.loc))
                        } else {
                            PatternMatcher.ConstLattice.NoMatch
                        }
                    }
                ),
                { it },
                PatternMatcher.Pattern.FromVar(
                    extractor = { w, v ->
                        if(v.meta.find(TACMeta.STORAGE_KEY) != null) {
                            PatternMatcher.VariableMatch.Match(w to AllocationAnalysis.Alloc.StorageUnpack.SizeReadSort.UnpackRead(v))
                        } else {
                            PatternMatcher.VariableMatch.Continue
                        }
                    }
                ),
                { it }
            )
        val maskedStorageRead = PatternDSL.build {
            (1() and readFrom.asBuildable()).commute.withAction { loc, _, pair ->
                StorageBitTest(
                    maskLocation = loc.narrow(),
                    readLoc = pair.first,
                    readSort = pair.second
                )
            }
        }

        private val maskStorageMatcher = PatternMatcher.compilePattern(g, patt = maskedStorageRead)

        data class StorageBitTest(
            val maskLocation: LTACCmdView<TACCmd.Simple.AssigningCmd.AssignExpCmd>,
            val readLoc: LTACCmd,
            val readSort: AllocationAnalysis.Alloc.StorageUnpack.SizeReadSort
        )

        fun summarizeDecode(p: SimplePatchingProgram, mut: SummarizationMutSpec) {
            val (reroute, tacSumm) = when(mut) {
                is SummarizationMutSpec.SimpleSplit -> {
                    val (block, succ) = p.splitBlockRange(
                        mut.startPoint, mut.endPointer
                    )
                    check(succ.size == 1)
                    if(mut.commute.isNotEmpty()) {
                        p.addBefore(mut.commuteTarget.ptr, mut.commute.map {
                            it.cmd
                        })
                    }
                    block to StorageLengthReadSummary(
                        readSort = mut.readSort,
                        outputVar = mut.output,
                        originalBlockStart = block,
                        skipTarget = succ.first(),
                        summarizedBlocks = setOf(block),
                        modifiedVars = mut.mutVariables
                    )
                }
                is SummarizationMutSpec.MultiBlockSplit -> {
                    val head = if(mut.headSplit.pos == 0) {
                        mut.headSplit.block
                    } else {
                        p.splitBlockAfter(g.pred(mut.headSplit).single())
                    }
                    head to StorageLengthReadSummary(
                        readSort = mut.readSort,
                        modifiedVars = mut.mutVariables,
                        summarizedBlocks = mut.intermediateBlocks + head,
                        skipTarget = mut.decodeSuccessor,
                        originalBlockStart = head,
                        outputVar = mut.output
                    )
                }
            }
            p.reroutePredecessorsTo(reroute, listOf(
                TACCmd.Simple.SummaryCmd(tacSumm, meta = MetaMap())
            ))
        }

        fun compute(c: CoreTACProgram) : CoreTACProgram {
            val spec = ParallelPool.allocInScope(SolverConfig.cvc5.default, { solverConf -> Z3BlasterPool(fallbackSolverConfig = solverConf, z3TimeoutMs = 2000) }) { blaster ->
                g.blocks.forkEvery {
                    it.commands.mapNotNull {
                        it.maybeNarrow<TACCmd.Simple.AssigningCmd.AssignExpCmd>()?.let {
                            maskStorageMatcher.queryFrom(it).toNullableResult()
                        }
                    }.forkEvery {
                        checkCandidate(it, blaster).commute()
                    }.pcompute().map {
                        it.filterNotNull()
                    }
                }.pcompute().runInherit()
            }.flatten()
            if(spec.isEmpty()) {
                return c
            }
            return c.patching {
                for(summ in spec) {
                    summarizeDecode(it, summ)
                }
            }
        }

        fun checkCandidate(bitTest: StorageBitTest, blaster: IBlaster) : Parallel<SummarizationMutSpec?>? {
            /*
              Find the use sites within the same block
             */
            val useSite = g.cache.use.useSitesAfter(bitTest.maskLocation.cmd.lhs, bitTest.maskLocation.ptr).singleOrNull {
                it.block == bitTest.maskLocation.ptr.block
            } ?: return null
            /*
              Is that use a binary relation?
             */
            val checkUse = g.elab(useSite).maybeNarrow<TACCmd.Simple.AssigningCmd.AssignExpCmd>()?.takeIf {
                it.cmd.rhs is TACExpr.BinRel
            }?.let {
                g.cache.use.useSitesAfter(it.cmd.lhs, it.ptr)
            }?.singleOrNull()?.let(g::elab) ?: return null
            /*
              Is it used in a ite? then this "looks like" an old style solc7<= check
             */
            return if(checkUse.cmd is TACCmd.Simple.AssigningCmd.AssignExpCmd && checkUse.cmd.rhs is TACExpr.TernaryExp.Ite) {
                // old style, solc <= 7, "inline" check
                inlineCheck(bitTest, blaster)
            /*
               New style check
             */
            } else if(checkUse.cmd is TACCmd.Simple.JumpiCmd) {
                // new style, solc 8+, multi block check
                multiBlockCheck(bitTest, blaster)
            } else {
                null
            }
        }

        private fun multiBlockCheck(bitTest: StorageBitTest, blaster: IBlaster) : Parallel<SummarizationMutSpec?>? {
            /*
              Expect a diamond control flow...
             */
            val diamond = g.succ(bitTest.maskLocation.ptr.block).takeIf {
                it.size == 2
            } ?: return null
            val joinPoint = diamond.monadicMap {
                g.succ(it).singleOrNull()
            }?.uniqueOrNull() ?: return null
            /*
              Followed by a revert check (I found this bug, so I suffer for it I guess)
             */
            val (revert, goodPath) = g.succ(joinPoint).takeIf {
                it.size == 2
            }?.partition {
                it in g.cache.revertBlocks
            }?.takeIf {
                it.second.size == 1 && it.first.size == 1
            } ?: return null
            /*
              To summarize with TACTransFormula, we need a self-contained subgraph.
             */
            val subG = g.toSubGraph(
                diamond + joinPoint + bitTest.maskLocation.ptr.block,
                /*
                   Lop off the prefix before our read
                 */
                prefixFilter = {
                    it.ptr.pos >= bitTest.readLoc.ptr.pos
                },
                /*
                  Pretend that we don't have the jump to the revert block (we will check this later)
                 */
                sinkModel = {
                    it.takeIf { it !is TACCmd.Simple.JumpiCmd } ?: TACCmd.Simple.NopCmd
                }
            )
            val readSpec = bitTest.readSort
            val summarization = SummarizeProgram.summarizeTAC(subG, ComputeTACSummaryTransFormula())
            val exp = summarization.transFormula.exp
            /*
               Which of the variables defined in this code is live? That is our candidate decoded length. If there is
               more than one, give up
             */
            val resultVar = summarization.transFormula.assignedVars.singleOrNull {
                g.cache.lva.isLiveAfter(g.elab(joinPoint).commands.last().ptr, it.sym)
            } ?: return null
            val smtVar = summarization.transFormula.outVars[resultVar]
                ?: error("TransFormula class invariant violated: assigned var must be an outVar.")
            /*
              Translate the summary expression into a smt expression. When translating, replace the split out storage
              slot or the slot with the symbolic length field name
             */
            val assertStmt = if(readSpec is AllocationAnalysis.Alloc.StorageUnpack.SizeReadSort.UnpackRead) {
                SmtExpBitBlaster().blastExpr(exp) { it: TACSymbol.Var ->
                    if(it == readSpec.read) {
                        lengthField
                    } else {
                        it.smtRep
                    }
                }
            } else {
                check(readSpec is AllocationAnalysis.Alloc.StorageUnpack.SizeReadSort.WordLoad)
                object : SmtExpBitBlaster() {
                    override fun blastExpr(e: TACExpr, vm: (TACSymbol.Var) -> String?): SmtExp? {
                        return if(e is TACExpr.Select && e.base is TACExpr.Sym.Var &&
                            summarization.transFormula.inVars.reverseGet(e.base)?.sym?.meta?.find(TACMeta.STORAGE_KEY) != null &&
                            e.loc is TACExpr.Sym && when(e.loc) {
                                is TACExpr.Sym.Const -> e.loc.s
                                is TACExpr.Sym.Var -> summarization.transFormula.inVars.reverseGet(e.loc)?.sym ?: e.loc.s
                            } == readSpec.indexSym) {
                                lifter.toIdent(lengthField)
                            } else {
                            super.blastExpr(e, vm)
                        }
                    }
                }.blastExpr(exp) { it -> it.smtRep }
            } ?: return null
            val script = SmtExpScriptBuilder(SmtExpBitVectorTermBuilder)
            /*
               Assume that the summary is true (it is!)
             */
            script.assert {
                eq(assertStmt, const(1))
            }
            summarization.transFormula.outVars.values.forEach {
                script.declare(it.s.smtRep)
            }
            summarization.transFormula.auxVars.forEach {
                script.declare(it.s.smtRep)
            }
            summarization.transFormula.inVars.values.forEach {
                script.declare(it.s.smtRep)
            }
            script.declare(lengthField)
            /*
              Now check that the result after the block is the decoded field
             */
            val maskCheck = script.fork()
            maskCheck.assert {
                val lSlot = toIdent(lengthField)
                lnot(
                    eq(
                        toIdent(smtVar.s.smtRep),
                        ite(
                            eq(const(1), bwAnd(const(1), lSlot)!!),
                            div(lSlot, const(2)),
                            bwAnd(
                                const(0x7f),
                                div(lSlot, const(2))
                            )!!
                        )
                    )
                )
            }
            maskCheck.checkSat()
            val check1 = rpc { blaster.blastSmt(maskCheck.cmdList) }


            /*
              now check that we revert if the packed length is greater than 31
             */
            val revertCondCheck = script.fork()
            val nonRevertCond = g.pathConditionsOf(joinPoint)[goodPath.single()] ?: return null
            /*
              If our jump is not a eqzero or nonzero, or we don't have a summary of how the condition variable is defined,
              give up
             */
            if(nonRevertCond !is TACCommandGraph.PathCondition.ConditionalOn || TACSummaryVar(nonRevertCond.v) !in summarization.transFormula.outVars) {
                return null
            }
            /*
              Assume the non-revert path condition
             */
            val condVar = summarization.transFormula.outVars[TACSummaryVar(nonRevertCond.v)]!!
            if(nonRevertCond is TACCommandGraph.PathCondition.EqZero) {
                revertCondCheck.assert {
                    eq(
                        toIdent(condVar.s.smtRep),
                        const(0)
                    )
                }
            } else {
                check(nonRevertCond is TACCommandGraph.PathCondition.NonZero)
                revertCondCheck.assert {
                    lnot(eq(
                        toIdent(condVar.s.smtRep),
                        const(0)
                    ))
                }
            }
            /*
              assert that if we have a packed length, then the decoded
              length is greater than 31 (this should be impossible)
             */
            revertCondCheck.assert {
                land(
                    eq(
                        bwAnd(
                            toIdent(lengthField),
                            const(1)
                        )!!,
                        const(0)
                    ),
                    lt(
                        const(31),
                        toIdent(smtVar.s.smtRep)
                    )
                )
            }
            revertCondCheck.checkSat()
            val check2 = rpc { blaster.blastSmt(revertCondCheck.cmdList) }
            return check1.parallelBind(check2) { r1, r2 ->
                complete(r1 && r2)
            }.bindFalseAsNull {
                /*
                    If the two checks succeed, then this is a multi-block decode
                 */
                complete(SummarizationMutSpec.MultiBlockSplit(
                    readSort = bitTest.readSort,
                    mutVariables = summarization.transFormula.outVars.keys.map {
                        it.sym
                    }.toSet(),
                    output = resultVar.sym,
                    headSplit = bitTest.readLoc.ptr,
                    intermediateBlocks = setOf(
                        joinPoint,
                        revert.first()
                    ) + diamond,
                    decodeSuccessor = goodPath.single()
                ))
            }
        }

        private fun inlineCheck(
            bitTest: StorageBitTest,
            blaster: IBlaster
        ): Parallel<SummarizationMutSpec?>? {
            /*
              In order to check the storage decoding, we have to know what variable we expect to hold the decoded
              length. Do this heuristically, if we write a value to memory or jump on a comparison with 0, that's
              our candidate
             */
            val (stopPoint, lenDefPoint) = g.iterateBlock(bitTest.maskLocation.ptr).firstOrNull {
                it.cmd is TACCmd.Simple.AssigningCmd.ByteStore || it.cmd is TACCmd.Simple.JumpiCmd
            }?.let {
                /*
                   make sure we're writing a value with a unique definition site
                 */
                it `to?` if(it.cmd is TACCmd.Simple.AssigningCmd.ByteStore &&
                    it.cmd.base == TACKeyword.MEMORY.toVar() &&
                    it.cmd.loc is TACSymbol.Var &&
                        it.cmd.value is TACSymbol.Var) {
                    g.cache.def.defSitesOf(it.cmd.value, it.ptr).singleOrNull()?.let(g::elab)?.maybeNarrow<TACCmd.Simple.AssigningCmd>()
                /*
                   Or we're comparing some candidate variable with zero
                 */
                } else if(it.cmd is TACCmd.Simple.JumpiCmd && it.cmd.cond is TACSymbol.Var) {
                    eqZeroPatt.query(it.cmd.cond, it).toNullableResult()?.let {
                        g.cache.def.defSitesOf(it.second, it.first.ptr)
                    }?.singleOrNull()?.let(g::elab)?.maybeNarrow<TACCmd.Simple.AssigningCmd>()
                } else {
                    null
                }
            } ?: return null
            val block = g.elab(lenDefPoint.ptr.block)
            val commuteTarget = g.succ(lenDefPoint.wrapped).singleOrNull() ?: return null
            val writeValue = lenDefPoint.cmd.lhs
            /* check "liveness": the only values defined in this range are:
               1. the writeValue
               2. dead at the end of the block (intermediates that can be safely "wrapped" in the summary)
               3. live at the end, but not used in the block (can be commuted/moved out of the range)
             */
            val def = mutableSetOf<TACSymbol.Var>()
            val defRange = (bitTest.readLoc.ptr.pos .. lenDefPoint.ptr.pos).map {
                block.commands[it].ptr
            }.toSet()
            val liveAfter = g.cache.lva.liveVariablesAfter(lenDefPoint.ptr)
            val commute = mutableListOf<LTACCmdView<TACCmd.Simple.AssigningCmd>>()
            for(i in bitTest.readLoc.ptr.pos .. lenDefPoint.ptr.pos) {
                val ltac = block.commands[i]
                val v = ltac.maybeNarrow<TACCmd.Simple.AssigningCmd>()?.cmd?.lhs ?: continue
                /*
                   1
                 */
                if(v == writeValue) {
                    continue
                }
                /* 2 */
                if(v !in liveAfter) {
                    continue
                }
                /* 3 */
                if(g.cache.use.useSitesAfter(v, ltac.ptr).containsAny(defRange)) {
                    return null
                }
                commute.add(ltac.narrow())
            }
            return rpc {
                /*
                  check that the range from the read to the use site gives the expected value in writeValue
                 */
                BitBlaster.blastCode(
                    block = block,
                    start = bitTest.readLoc.ptr.pos,
                    end = stopPoint.ptr.pos,
                    blaster = blaster,
                    env = mapOf(),
                    synthAssign = mapOf(
                        bitTest.readLoc.ptr to lengthField
                    ),
                    vcGen = vc@{ m ->
                        val actual = m[writeValue] ?: return@vc false
                        assert {
                            lnot(
                                eq(
                                    toIdent(actual),
                                    ite(
                                        eq(
                                            bwAnd(const(1), toIdent(lengthField))!!,
                                            const(1)
                                        ),
                                        div(toIdent(lengthField), const(2)),
                                        div(bwAnd(toIdent(lengthField), const(255))!!, const(2))
                                    )
                                )
                            )
                        }
                        true
                    }
                )
            }.bindFalseAsNull {
                /* then the range from the read to the definition of the length is
                   - A decode of a storage field
                   - the commands in the range from where the value in storage is read to the point where the decode is done
                     only defines the decoded length (in writeValue)

                   with the above, we have that the sub-block can be summarized
                */
                complete(SummarizationMutSpec.SimpleSplit(
                    startPoint = bitTest.readLoc.ptr,
                    endPointer = lenDefPoint.ptr,
                    output = writeValue,
                    mutVariables = def + writeValue,
                    readSort = bitTest.readSort,
                    commute = commute,
                    commuteTarget = commuteTarget
                ))
            }
        }
    }

    fun rewrite(c: CoreTACProgram) : CoreTACProgram = Worker(c.analysisCache.graph).compute(c)
}
