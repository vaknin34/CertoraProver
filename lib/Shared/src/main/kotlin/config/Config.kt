/*
 *     The Certora Prover
 *     Copyright (C) 2025  Certora Ltd.
 *
 *     This program is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU General Public License as published by
 *     the Free Software Foundation, version 3 of the License.
 *
 *     This program is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU General Public License for more details.
 *
 *     You should have received a copy of the GNU General Public License
 *     along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

package config

import annotations.PollutesGlobalState
import cache.CachePolicy
import cli.*
import datastructures.stdcollections.*
import evm.MAX_EVM_UINT256
import kotlinx.serialization.encodeToString
import kotlinx.serialization.json.Json
import log.*
import org.apache.commons.cli.Option
import org.jetbrains.annotations.TestOnly
import smt.*
import solver.SolverChoice
import solver.SolverChoice.Companion.AllCommonAvailableSolversWithClOptions
import solver.SolverConfig
import spec.EVMConfig
import spec.VMConfig
import utils.*
import java.io.File
import java.io.FileWriter
import java.lang.management.ManagementFactory
import java.math.BigInteger
import kotlin.io.path.Path
import kotlin.io.path.exists
import kotlin.time.Duration
import kotlin.time.Duration.Companion.seconds

const val OUTPUT_NAME_DELIMITER = "-"

const val SOURCES_SUBDIR = ".certora_sources"

const val CERTORA_BUILD_FILE_PATH = ".certora_build.json"
const val CERTORA_VERIFY_FILE_PATH = ".certora_verify.json"
const val CERTORA_METADATA_FILE_PATH = ".certora_metadata.json"

private val logger = Logger(LoggerTypes.COMMON)

/**
 * A static object for storing CVT's command line arguments and various options.
 * Refer to [ConfigType] to see how flags, int, string and custom type options are defined.
 */
object Config {
    /* CertoraBuildDirectory is the directory where all client intermediate files generated by certora scripts
    and server runs are stored. Keeping all files in a single directory makes it easy to remove these files
    when they are not needed and guarantees that these files are not added by mistake to the customer's git repository.
    If the directory was not given as an arg the directory path is `.` string (i.e. all files are stored in current
    working directory)
    */
    val CertoraBuildDirectory: ConfigType.StringCmdLine = object :
        ConfigType.StringCmdLine(
            ".", Option(
                "buildDirectory", true,
                "the location of the internal files that are created during build (such as .certora_build, .certora_verify etc."
            )
        ), RuleCacheAgnosticConfig {}

    private val RuleChoice: ConfigType.StringSetCmdLine = object : ConfigType.StringSetCmdLine(
        null,
        Option("rule", true, "Rules to check from spec file"),
        pythonName = "--rule"
    ),
        RuleCacheAgnosticConfig {}

    private val ExcludeRuleChoice: ConfigType.StringSetCmdLine = object : ConfigType.StringSetCmdLine(
        null,
        Option("excludeRule", true, "Rules to exclude from check of spec file"),
        pythonName = "--exclude_rule"
    ),
        RuleCacheAgnosticConfig {}

    /** @return true iff at least one of [RuleChoice] and [ExcludeRuleChoice] was set */
    fun areRulesFiltered() = RuleChoice.getOrNull() != null || ExcludeRuleChoice.getOrNull() != null

    /**
     * Returns the subset of [allRules] that match the patterns provided by [RuleChoice] and [ExcludeRuleChoice].
     */
    @Suppress("ForbiddenMethodCall")
    fun getRuleChoices(allRules: Set<String>): Set<String> {
        fun String.toRulePattern() =
            // A bit of weirdness to accommodate the fact that '$' is a valid character for rule names.
            this.split("*").joinToString(".*", transform = Regex.Companion::escape).toRegex()

        val ruleChoices = RuleChoice.getOrNull() ?: setOf()
        val ruleExcludeChoices = ExcludeRuleChoice.getOrNull() ?: setOf()
        val excludeMatchers = ruleExcludeChoices.map { it.toRulePattern() }
        val matchers = ruleChoices.map { it.toRulePattern() }

        return allRules.filterToSet { rule ->
            (matchers.isEmpty() || matchers.any { it.matchEntire(rule) != null }) &&
                excludeMatchers.all { it.matchEntire(rule) == null }
        }
    }

    /**
     * Returns the values provided via `-rule` flags that are _not_ patterns (i.e. don't contain an `*`)
     * Returns null if the flag wasn't set at all.
     */
    @Suppress("ForbiddenMethodCall")
    fun getNonPatternRuleChoices(): HashSet<String>? {
        return RuleChoice.getOrNull()?.filter { "*" !in it }?.toHashSet()
    }

    /**
     * Prepend internal dir
     *
     * @param path
     *
     * If 'path' is relative path from build directory root, we prepend the root of the build directory.
     * We return the path itself if the path points to a file or if the path starts with '.certora_internal'
     */
    fun prependInternalDir(path: String): String {
        return Path(CertoraBuildDirectory.get()).resolve(path).toString()
    }

    val Foundry = object : ConfigType.BooleanCmdLine(
        false,
        Option(
            "foundry",
            true,
            "verify a Foundry fuzz test"
        ),
        pythonName = "--foundry_tests_mode"
    ) {}

    val AutoDispatcher = object : ConfigType.BooleanCmdLine(
        false,
        Option(
            "autoDispatcher",
            true,
            "Sets the default summary to be an optimistic dispatcher (aka `DISPATCHER(true)`)"
        ),
        pythonName = "--auto_dispatcher"
    ) {}

    /* If not given, the typechecker will only check the syntax of the specification files.
    using this option requires the existence of a build JSON file in the build directory.
    */
    val IsTypeChecking = object :
            ConfigType.BooleanCmdLine(
                false, Option(
                "typeCheck", false,
                "Type check the specification file"
            )
    ) {}

    val ListRules = object :
        ConfigType.BooleanCmdLine(
            false, Option(
            "listRules", false,
            "Prints a list of rules to the command line after type checking succeeded. " +
                "This option is only used by the TypeChecker.jar"
        )
    ) {}

    val AllowSolidityQuantifierCalls = object : ConfigType.BooleanCmdLine(
            false,
            Option(
                "allowSolidityQuantifierCalls",
                true,
                "Allow calls to Solidity quantifier functions. [default:false]"
            ),
            pythonName = "--allow_solidity_calls_in_quantifiers"
    ) {}

    // TODO(sg): consider grouping in sub-objects?
    // General

    // set to true when we run the main jar's entrypoint
    object MainJarRun : ConfigType<Boolean>(
        false,
        "MainJarRun"
    ) {
        override fun check(newValue: Boolean): Boolean = true
        override fun illegalArgMessage(newValue: Boolean): String = ""
    }

    val ShowHelp = "Show usage".let { desc ->
        object : ConfigType.BooleanCmdLine(
            false,
            Option("h", false, desc),
            aliases = listOf(Option(null, "help", false, desc))
        ) {}
    }

    // "helpAdvanced" can be used with one or two dashes in front
    val ShowAdvancedHelp =
        object :
            ConfigType.BooleanCmdLine(false, Option("helpAdvanced", false, "Show advanced usage")) {}

    // "helpAdvanced" can be used with one or two dashes in front
    val ShowVersion =
        object : ConfigType.BooleanCmdLine(false, Option("version", false, "Show version information")) {}

    val SimpleTaskTimeout = object :
        ConfigType.IntCmdLine(10, Option("taskTimeout", true, "Set timeout for auxiliary tasks like graphviz")) {}
    val ShowPingInStderr =
        object : ConfigType.BooleanCmdLine(false, Option("ping", false, "Ping time to stderr [default: false]")) {}
    val PingFrequency =
        object : ConfigType.IntCmdLine(
            60,
            Option("pingFrequency", true, "Ping frequency in seconds [default: 60 seconds]")
        ) {}

    val CustomBuildScript = object : ConfigType.StringCmdLine(
        "",
        Option(
            "customBuildScript",
            true,
            "Script file to run in order to build or perform any kind of preprocessing prior to the tool"
        )
    ) {}

    /**
     * Finds the given [filename] in the relevant `.certora_sources` directory, specifically, the one inside the build
     * directory.
     * Therefore:
     * if .certora_sources is inside the build directory (it should be - we should consider asserting this),
     * and the file we look at is not already giving the path inside .certora_sources, we will try to resolve the
     * file in the path to .certora_sources.
     *
     * I (SG) suspect this method requires some more TLC and can be shortened.
     */
    fun prependSourcesDir(filename: String): String {
        val potentialDir = Path(CertoraBuildDirectory.get()).resolve(SOURCES_SUBDIR)
        val internalDir = if (potentialDir.exists()
            && Path(filename).getName(0).toString() != SOURCES_SUBDIR
        ) {
            potentialDir
        } else {
            Path(".")
        }
        return internalDir.resolve(filename).toString()
    }

    val VMConfig: VMConfig = EVMConfig

    val PatienceSeconds = object : ConfigType.IntCmdLine(
        1,
        Option(
            "patient",
            true,
            "Be patient for auxiliary tasks (e.g. graphviz) to finish and wait X seconds (default: 1)"
        )
    ) {}

    fun getSourcesSubdirInInternal(): String {
        return prependInternalDir(SOURCES_SUBDIR)
    }

    val LowFootprint = object : ConfigType.BooleanCmdLine(
        false,
        Option(
            "lowFootprint",
            true,
            "Set whether to be in low footprint mode (ignore debug flags and do not output debug html files or debug ir files) [default: false]"
        )
    ) {}
    val DisablePopup = object : ConfigType.BooleanCmdLine(
        false,
        Option("disablePopup", true, "Set whether to disable browser popup when run ends [default: false]")
    ) {}
    val QuietMode = object : ConfigType.BooleanCmdLine(
        false,
        Option("quiet", false, "Quiet mode where the results table is not printed to the console [default: false]")
    ) {}

    val GlobalTimeout: ConfigType.IntCmdLine = object : ConfigType.IntCmdLine(
        0,
        Option(
            "globalTimeout",
            true,
            "Set global timeout for the entire run, in seconds. " +
                "Reserved for ProverContainer or local runs [default: 0, meaning infinite]"


        ),
        pythonName = "--cloud_global_timeout"
    ), RuleCacheAgnosticConfig {}
    val UserGlobalTimeout: ConfigType.IntCmdLine = object : ConfigType.IntCmdLine(
        0,
        Option(
            "userGlobalTimeout",
            true,
            "Set global timeout for the entire run, in seconds. [default: 0, meaning infinite]"
        ),
        pythonName = "--global_timeout"
    ), RuleCacheAgnosticConfig {}

    val ShutdownTimeout = object : ConfigType.IntCmdLine(
        60,
        Option(
            "shutdownTimeout",
            true,
            "Time to wait for background tasks to complete after main processing is complete, in seconds [default: 60]"
        )
    ) {}

    /**
     * The actual global timeout should be the minimal between original [GlobalTimeout] and the new
     * [UserGlobalTimeout]
     */
    fun actualGlobalTimeout(globalTimeout: Int = GlobalTimeout.get(), userGlobalTimeout: Int = UserGlobalTimeout.get()) =
        if (globalTimeout == 0) {
            // we're probably not in cloud. so user global timeout can only be smaller
            userGlobalTimeout
        } else if (userGlobalTimeout == 0) {
            // we're in cloud and user didn't specify a global timeout,
            // OR we're running locally with the old flag. So we take the original flag's value.
            globalTimeout
        } else {
            // take the minimum between User/Original global timeout
            Math.min(globalTimeout, userGlobalTimeout)
        }

    val IsCIMode = object : ConfigType.BooleanCmdLine(
        false,
        Option("ciMode", true, "Set whether to auto-set configurations suitable for running in CI. [default: false]"),
        pythonName = "--short_output"
    ) {}

    val TacEntryPoint = object : ConfigType.TacEntryPointCmdLine(
        default = null,
        Option(
            "tacEntryPoint",
            true,
            "When providing a .tac file, specify the entry point in the Prover pipeline from which the file should be" +
                " run. The entry point is specified as a ReportType. Example: A tac file that was dumped via " +
                "`-Dreport.presolver.rule` can be re-run using `-tacEntryPoint presolver.rule` (or alternatively " +
                "`-tacEntryPoint presolver_rule`). Current working options are `presimplified.rule`, " +
                "`presolver.rule`, and `generic.flow`. [default: presimplified.rule]"
        )
    ) {}

    val OptimisticContractRecursion = object : ConfigType.BooleanCmdLine(
        false,
        Option(
            "optimisticContractRecursion", true,
            "When set to [true] the contract (inlining) recursion limit will be assumed, and not asserted [default: false]"
        ),
        pythonName = "--optimistic_contract_recursion"
    ) {}

    val SQSEventTimeoutMilliseconds = object : ConfigType.IntCmdLine(
        default = 5000,
        Option(
            "sqsEventTimeoutMilliseconds",
            true,
            "How long to wait for SQS events to send before canceling.  Default: 5000ms"
        )
    ) {}

    val ContractRecursionLimit = object : ConfigType.IntCmdLine(
        default = 0,
        Option(
            "contractRecursionLimit",
            true,
            "The number of recursive external calls to consider in inlining"
        ),
        pythonName = "--contract_recursion_limit"
    ) {}

    val MaxConcurrentRules: ConfigType.IntCmdLine = object : ConfigType.IntCmdLine(
        default = Runtime.getRuntime().availableProcessors(),
        Option(
            "maxConcurrentRules",
            true,
            "The maximum number of concurrent rule evaluations.  Default: number of processors."
        )
    ), RuleCacheAgnosticConfig {
        override fun check(newValue: Int): Boolean = newValue > 0
    }

    val MaxConcurrentTransforms: ConfigType.PerTransformConcurrencyLimitConfig =
        object : ConfigType.PerTransformConcurrencyLimitConfig(
            default = arrayOf(),
            Option(
                "maxConcurrentTransforms",
                true,
                "Concurrency limit for each transform type. E.g.: 'INLINED_HOOKS:4,OPTIMIZE_BITWISE_CLEANING:10,...'"
            )
        ), RuleCacheAgnosticConfig {}

    private val maxConcurrentTransforms by lazy { MaxConcurrentTransforms.get().toMap() }

    fun concurrencyLimit(type: ReportTypes) =
        maxConcurrentTransforms[type] ?: Runtime.getRuntime().availableProcessors()

    val JFR: ConfigType.BooleanCmdLine = object : ConfigType.BooleanCmdLine(
        !DevMode.isLocalDevRun(), // Enable JFR in production by default, but go easy on devs' hard drives.
        Option("jfr", true, "Enable Java Flight Recorder (for execution profiling)")
    ), RuleCacheAgnosticConfig {}

    val JFRStackSampleInterval: ConfigType.IntCmdLine = object : ConfigType.IntCmdLine(
        1000,
        Option(
            "stackInterval",
            true,
            "JFR profile stack sampling interval, in milliseconds [default: 1000]."
        )
    ), RuleCacheAgnosticConfig {}

    val StackAnnotationConfig: ConfigType.StackAnnotationConfig = object : ConfigType.StackAnnotationConfig(
        default = arrayOf(StackAnnotation.CODE, StackAnnotation.TRANSFORM),
        Option("stackAnnotations", true, "Items to include in stack traces for profiling: 'code,transform,all,none'")
    ), RuleCacheAgnosticConfig {}

    // decompiler
    val DumpCodeSizeAnalysis: ConfigType.BooleanCmdLine = object : ConfigType.BooleanCmdLine(
        false,
        Option("dumpCodeSizeAnalysis", true, "Output code size analysis dumps. [default: false]")
    ), RuleCacheAgnosticConfig {}

    val MaxCommandCount = "Maximum number of TAC commands per method (default: 1,000,000)".let { desc ->
        object : ConfigType.IntCmdLine(
            1_000_000,
            Option("maxCommandCount", true, desc),
            aliases = listOf(Option("maxDecompiledCommandCount", true, desc))
        ) {}
    }
    val MaxBlockCount = "Maximum number of TAC blocks per method (default: 100,000)".let { desc ->
        object : ConfigType.IntCmdLine(
            100_000,
            Option("maxBlockCount", true, desc),
            aliases = listOf(Option("maxDecompiledBlockCount", true, desc))
        ) {}
    }
    val MaxUnfoldedBlockCount = object : ConfigType.IntCmdLine(
        10_000_000,
        Option(
            "maxUnfoldedBlockCount",
            true,
            "Maximum number of unfolded EVM blocks prior to deduplication (default: 10,000,000)"
        )
    ) {}
    val RecursionLimitHeuristic = object : ConfigType.IntCmdLine(
        900,
        Option(
            "recursionLimitHeuristic",
            true,
            "Minimal 'stack-top' value allowed to avoid long-running runs due to recursion (default: 900)"
        )
    ) {}
    val JumpThunkDepthLimit = object : ConfigType.IntCmdLine(
        0,
        Option(
            "jumpThunkDepthLimit",
            true,
            "Number of jump thunk uses allowed along any unfolded CFG path (default: 0)."
        )
    ) {}
    val RecursionEntryLimit = object : ConfigType.IntCmdLine(
        3,
        Option(
            "recursionEntryLimit",
            true,
            "Number of unfolding for a recursive function (default: 3)"
        )
    ) {}
    val RecursionErrorAsAssertInAllCases = object : ConfigType.BooleanCmdLine(
        true,
        Option(
            "recursionErrorAsAssert",
            true,
            "Determine if to always set recursion errors as assert failures and not as plain throws (default: true)"
        )
    ) {}

    val EnableCalldataSplitting = object : ConfigType.BooleanCmdLine(
        true,
        Option(
            "enableCalldataSplitting",
            true,
            "If true, will attempt to split calldata access to scalar variables for better performance. If false, " +
                "will preserve original access pattern to calldata. [default: true]"
        )
    ) {}

    val MaxMergedBranchSize = object : ConfigType.IntCmdLine(
        200,
        Option(
            "maxMergedBranchSize",
            true,
            "Limits the size of merged control-flow branches.  Higher numbers result in less complex graphs, " +
                "lower numbers result in more solver splitting opportunities."
        )
    ) {}

    // output related
    val MainOutputFolder = "Directory prefix for outputs and auxiliary files".let { desc ->
        object : ConfigType.StringCmdLine(
            "emv",
            Option("o", true, desc),
            aliases = listOf(Option("output", true, desc))
        ) {
            override fun check(newValue: String): Boolean {
                return newValue.matches(Regex("[a-zA-Z0-9_]+"))
            }

            override fun illegalArgMessage(newValue: String): String = "Output directory name is illegal"
        }
    }
    val ReportsDir = object :
        ConfigType.StringCmdLine("Reports", Option("reportsDir", true, "Set path of directory for produced reports")) {}
    val TreeViewReportsSubdir = object :
        ConfigType.StringCmdLine(
            "treeView",
            Option("treeViewSubdir", true, "Set subdirectory of reports directory for produced treeView reports")
        ) {

        override fun check(newValue: String): Boolean {
            return !File(newValue).isAbsolute
        }
    }

    val VerifierResultsReportsSubdir = object :
        ConfigType.StringCmdLine(
            "verifierResults",
            Option(
                "verifierResultsReportsSubdir",
                true,
                "Set subdirectory of reports directory for produced prover results"
            )
        ) {

        override fun check(newValue: String): Boolean {
            return !File(newValue).isAbsolute
        }
    }

    val OutputsDir = object :
        ConfigType.StringCmdLine("outputs", Option("outputsDir", true, "Set path of directory for produced outputs")) {}
    val AvoidAnyOutput = object : ConfigType.BooleanCmdLine(
        false,
        Option(
            "noOutput",
            false,
            "Do not write any output to the filesystem (not recommended unless you really know what you're doing) [default: false]"
        )
    ) {}
    val OverwriteMainOutputDir = object : ConfigType.BooleanCmdLine(
        false,
        Option(
            "overwrite",
            false,
            "Overwrite output directory contents. In that case -o may have only alphanumeric and underscore characters."
        )
    ) {}
    val MaxNumOfAttemptsToCreateMainOutputDir = object : ConfigType.IntCmdLine(
        10,
        Option(
            "maxNumAttemptsToCreateMainDir",
            true,
            "The maximum number of attempts to create the main emv directory. [default: 10]"
        )
    ) {
        override fun check(newValue: Int): Boolean = newValue >= 1
        override fun illegalArgMessage(newValue: Int): String = "Must be >= 1, got $newValue"
    }
    val FormulasFolder = object : ConfigType.StringCmdLine(
        "formulas",
        Option("formulaFolder", true, "Choose folder storing formula files [default: \${OUT}/formulas]")
    ) {}
    val DebugOutputsFolder = object : ConfigType.StringCmdLine(
        "debugs",
        Option("debugFolder", true, "Choose folder storing debug files [default: \${OUT}/debug")
    ) {}
    val InputBackupFolder = object : ConfigType.StringCmdLine(
        "inputs",
        Option("inputBackupFolder", true, "Choose folder where to backup the inputs [default: \${OUT}/inputs]")
    ) {}
    val AsciiTableMultiplier = object : ConfigType.IntCmdLine(
        100,
        Option("asciiTableMult", true, "Percentage multiplier to width of ascii tables, default is 100%")
    ) {}
    val OutputJSONFile = object : ConfigType.StringCmdLine(
        "output.json",
        Option("json", true, "JSON output file"),
        pythonName = "--tool_output"
    ) {}
    val FeaturesJSONFile = object : ConfigType.StringCmdLine(
        "featuresResults.json",
        Option("featuresJson", true, "Function features report file")
    ) {}
    val PrettyTreeViewReports = object : ConfigType.BooleanCmdLine(
        false,
        Option(
            "prettyTreeViewReports",
            false,
            "Pretty print the Tree view status and output json files to make those more human-readable"
        )
    ) {}
    val OutputRegressionFile = object : ConfigType.StringCmdLine(
        "regressionOutput.txt",
        Option("regressionOutputFile", true, "RegressionTest output file")
    ) {}

    @Deprecated("Remove in next major version v8")
    val OutputJSONForHTMLFile =
        object : ConfigType.StringCmdLine(
            "data.json",
            Option("dataJson", true, "JSON for HTML data output file")
        ) {}
    val OutputFinalResultsHTML =
        object : ConfigType.StringCmdLine(
            "FinalResults.html",
            Option("finalResults", true, "An HTML report of the old kind [default: FinalResults.html]")
        ) {}
    val OutputJSONStatsDataFilePrefix = object : ConfigType.StringCmdLine(
        "statsdata",
        Option("statisticsJson", true, "JSON for statistics output file")
    ) {}
    val OutputProgressUpdater =
        object : ConfigType.StringCmdLine(
            "progress.json",
            Option("progressJson", true, "Name of progress json file [default: progress.json]")
        ) {}
    val ShowInternalFunctions: ConfigType.BooleanCmdLine = object : ConfigType.BooleanCmdLine(
        false,
        Option("showInternalFunctions", false, "Show a tree of internal functions and their summarization status")
    ), RuleCacheAgnosticConfig {}

    val TreeViewLiveStats = object : ConfigType.BooleanCmdLine(
        true,
        Option(
            "treeViewLiveStats", true, "Log live statistics in treeView_x.json files " +
                "for displaying \"Live Statistics\" in the html report."
        )
    ) {}
    val TreeViewLiveStatsPerSplit = object : ConfigType.BooleanCmdLine(
        false,
        Option(
            "treeViewLiveStatsPerSplit",
            true,
            "Log live statistics " +
                ",as enabled via ${TreeViewLiveStats.name}, for each split. If this is set to `false`, we only " +
                "log those stats once per rule. Setting this to true can incur a small performance overhead. " +
                "[default: false]"
        )
    ) {}

    // Compilation related
    val Solc = object : ConfigType.StringCmdLine(
        "solc",
        Option("solidityexec", true, "Executable name for the solidity compiler"),
        listOf(Option("solc", true, "Executable name for the solidity compiler"))
    ) {}
    val SolcAllowedPath =
        object : ConfigType.StringCmdLine(null, Option("path", true, "Allowed path for solc compiler")) {}

    // Graph draw related
    val GraphDrawLimit : ConfigType.IntCmdLine = object :
        ConfigType.IntCmdLine(
            900,
            Option("graphDrawLimit", true, "Set maximal number of nodes in graph image"),
            pythonName = "--max_graph_depth"
        ), RuleCacheAgnosticConfig {}
    val IsGenerateDotFiles = object : ConfigType.BooleanCmdLine(
        false,
        Option("enableGenerateDotfiles", true, "Generate dot files [default: false]")
    ) {}
    val IsGenerateGraphs = object :
        ConfigType.BooleanCmdLine(true, Option("generateGraphs", true, "Whether to generate graphs or not")) {}

    // Rule related

    // This is a [StringCmdLine] and not [StringSetCmdLine] because we split such sets on commas which wouldn't work for
    // this case of method signatures (think `foo(uint,uint)`. Instead, we read it as a string and do the slightly-more-complex
    // splitting when calculating [MethodChoices].
    private val MethodChoicesInput: ConfigType.StringCmdLine = "Method to check".let { desc ->
        object :
            ConfigType.StringCmdLine(
                null,
                Option("method", true, desc),
                aliases = listOf(Option("m", true, desc)),
                pythonName = "--method"
            ),
            RuleCacheAgnosticConfig {}
    }

    // Split the [MethodChoicesInput] string on the commas that separate function signatures
    // so e.g. `"foo(int256,bool),bar(uint256,(bool,bool))"` will become `["foo(int256,bool)", "bar(uint256,(bool,bool))"]`.
    // This code assumes the string is well-formed - the Python side should catch malformed inputs.
    val MethodChoices by lazy {
        MethodChoicesInput.getOrNull()?.let { input ->
            var (depth, start) = 0 to 0

            input.foldIndexed(listOf<String>()) { i, l, c ->
                when (c) {
                    '(' -> l.also { depth++ }
                    ')' -> l.also { depth-- }
                    ',' -> if (depth == 0) {
                        l + input.substring(start, i).trim().also { start = i + 1 }
                    } else {
                        l
                    }

                    else -> l
                }
            }.let { it + input.substring(start).trim() }
        }?.toSet()
    }

    val contractChoice: ConfigType.StringSetCmdLine = "contract(s) to check in parameterized rules".let { desc ->
        object :
            ConfigType.StringSetCmdLine(
                hashSetOf(),
                Option("contract", true, desc),
                pythonName = "--parametric_contracts"
            ),
            RuleCacheAgnosticConfig {}
    }

    val SpecFile =
        object : ConfigType.StringCmdLine(
            null,
            Option("spec", true, "Set specification file"),
            listOf(Option("cvl", true, "Set specification file")),
            pythonName = "--bytecode_spec"
        ) {}
    val BytecodeFiles =
        object : ConfigType.StringSetCmdLine(
            null,
            Option(
                "bytecode",
                true,
                "List of files with contract bytecode JSON descriptors. First entry is for the main contract."
            ),
            pythonName = "--bytecode_jsons"
        ) {}

    val SubContract = object : ConfigType.StringCmdLine(
        null,
        Option("subContract", true, "A contract from a Solidity file to be verified")
    ) {}

    val ResourceFiles: ConfigType.StringSetCmdLine = object : ConfigType.StringSetCmdLine(
        null,
        Option("resourceFiles", true, "Resource files for the prover"),
        pythonName = "--prover_resource_files"
    ) {}

    val DoSanityChecksForRules = object : ConfigType.SanityMode(
        SanityValues.NONE,
        Option(
            "ruleSanityChecks",
            true,
            "Gives alerts when rules have sanity check failures"
        ),
        pythonName = "--rule_sanity"
    ) {}

    val FindReachabilityFailurePoint = object : ConfigType.BooleanCmdLine(
        default = false,
        option = Option(
            "verboseReachabilityChecks", false,
            "for tests failing reachability check (requires 'ruleSanityChecks' != 'none') searches for the first assumption that breaks reachability"
        )
    ) {}

    val MultiAssertCheck = object : ConfigType.BooleanCmdLine(
        false,
        Option(
            "multiAssertCheck",
            false,
            "Checks each assert statement in a rule separately by generating a subrule for each assert"
        ),
        pythonName = "--multi_assert_check"
    ) {}

    val IndependentSatisfies = object : ConfigType.BooleanCmdLine(
        false,
        Option(
            "independentSatisfies",
            true,
            "Checks each satisfy statement by itself, disregarding previous satisfy statements."
        ),
        pythonName = "--independent_satisfy"
    ) {}

    val MaxNumberOfReachChecksBasedOnDomination = object : ConfigType.IntCmdLine(
        10,
        Option(
            "maxNumberOfReachChecksBasedOnDomination",
            true,
            "Number of reachability checks to have based on the domination score. [default: 10]"
        )
    ) {}

    val IgnoreViewFunctionsInParametricRules = object : ConfigType.BooleanCmdLine(
        false,
        Option(
            "ignoreViewFunctions",
            false,
            "Skip view (and pure) functions in parametric rules"
        )
    ) {}
    val CoinbaseFeaturesMode = object : ConfigType.BooleanCmdLine(
        false,
        Option(
            "coinbaseFeaturesMode",
            false,
            "Run CVT in Coinbase features' verification mode [default: false]"
        ),
        pythonName = "--coinbase_mode"
    ) {}

    @Deprecated("Remove in next major version v8")
    val DoReturnSizeChecksInCVL = object : ConfigType.BooleanCmdLine(
        true,
        Option(
            "enableReturnSizeChecksInCVL",
            true,
            "In every CVL invocation will check that number of returned words is as expected [default: true]"
        )
    ) {}

    // this option is for the equivalence checker to disable. if we have 2 distinct contracts, the only way to ensure
    // automatically that something like balanceOf[address(this)] is the same for both, is to have address(this) be the same
    // for both contracts under check (and allow no inter-calls, as this doesn't make sense anyway for equivalence checking)
    val AssumeContractsAreUnique = object : ConfigType.BooleanCmdLine(
        true,
        Option(
            "assumeContractsHaveUniqueAddresses",
            true,
            "If enabled, assumes every contract declared in the scene has a unique address [default: true]"
        )
    ) {}

    val TraceCVLAssignments = object : ConfigType.BooleanCmdLine(
        true,
        Option(
            "traceCVLAssignments",
            true,
            "If true (the default) add low-level traces of value movement in CVL. This can prevent some optimizations from applying, but otherwise should be left on."
        )
    ) {}

    private const val noCreateCollision2Name = "assumeNoCreate2Collision"
    val AssumeNoCreateCollision = object : ConfigType.BooleanCmdLine(
        true,
        Option(
            "assumeNoCreateCollision",
            true,
            "If enabled, assume that all addresses generated by `CREATE` (not `CREATE2`, use `-${noCreateCollision2Name}` instead) do not already exist (i.e., their codesize is 0) [default: true]"
        )
    ) {}

    val UseComputedAddressForCreate = object : ConfigType.BooleanCmdLine(
        true,
        Option(
            "useComputedAddressForCreate",
            true,
            "If enabled, use the result of the hash operation as the address of a contract constructed via `CREATE` instead of the internal address chosen by the prover [default: true]"
        )
    ) {}

    val UseNonceForCollisionChecks = object : ConfigType.BooleanCmdLine(
        false,
        Option(
            "useNonceForCollisionChecks",
            true,
            "If enabled, check that a created address has nonce of zero in addition to a zero codesize. Warning: May give difficult to avoid, uninteresting counter-examples [default: false]"
        )
    ) {}

    val AssumeNoCreate2Collision = object : ConfigType.BooleanCmdLine(
        false,
        Option(
            noCreateCollision2Name,
            true,
            "If enabled UNSOUNDLY assume that all addresses constructed via `CREATE2` (not `CREATE`, use `-${AssumeNoCreateCollision.name}` instead) do not already exist (i.e., their codesize is 0). Can lead to vacuity if multiple `create2` with the same parameters are used [default: false]"
        )
    ) {}

    val PreciseCodedataSemantics = object : ConfigType.BooleanCmdLine(
        true,
        Option(
            "preciseCodedataSemantics",
            true,
            "If enabled, constructors will (mutably) set the codedata and codesize for the corresponding contract [default: true]"
        )
    )  {}

    // TODO(CERT-7707): We plan to switch to this for good and remove this flag entirely in the future once supported,
    val CvlFunctionRevert = object : ConfigType.BooleanCmdLine(
        false,
        Option(
            "cvlFunctionRevert",
            true,
            "If enabled, CVL functions are treated like solidity functions on revert, bubbling up reverts of calls inside them. This allows modelling reverts in summaries. [default: false]"
        )
    )  {}

    // this option adds the assumption that no code is deployed at address(0) and therefore address(0).code.length
    // returns 0.
    val assumeAddressZeroHasNoCode = object : ConfigType.BooleanCmdLine(
        true,
        Option(
            "assumeAddressZeroHasNoCode",
            true,
            "If enabled, assumes that address(0).code.length is equal to zero"
        )
    ) {}

    // enabling this may incur somewhat more expensive SMT formulas combining BV and NIA,
    // disabling this is less precise in case of setting strings copied from memory to storage
    val EnableCleanCVLStrings = object : ConfigType.BooleanCmdLine(
        true,
        Option(
            "assumeCleanCVLStrings",
            true,
            "If enabled, assumes the last word of strings declared in CVL " +
                "is zeroed out after the expected length of the string, if the length is not word-aligned [default: true]"
        )
    ) {}

    val CopyLoopSizeHeuristic = object : ConfigType.IntCmdLine(
        default = -1,
        Option(
            "copyLoopSizeHeuristic",
            true,
            "Do not perform copy loop detection for loops with more than the given size [default: unlimited]"
        )
    ) {}

    // Loop related
    val LoopUnrollConstant = "Choose number of times to unroll loops".let { desc ->
        object : ConfigType.IntCmdLine(
            1,
            Option("b", true, desc),
            aliases = listOf(Option("bmc", true, desc)),
            pythonName = "--loop_iter"
        ) {
            override fun check(newValue: Int): Boolean {
                return newValue >= 0
            }

            override fun illegalArgMessage(newValue: Int): String = "Argument to -bmc should be a non-negative integer"
        }
    }
    val CopyLoopUnrollConstant =
        object : ConfigType.IntCmdLine(
            4,
            Option("copyLoopUnroll", true, "Choose number of times to unroll compiler-generated copy loops")
        ) {
            override fun check(newValue: Int): Boolean {
                return newValue >= 0
            }

            override fun illegalArgMessage(newValue: Int): String =
                "Argument to ${option.realOpt()} should be a non-negative integer"
        }

    val IsAssumeUnwindCondForLoops = object : ConfigType.BooleanCmdLine(
        false,
        Option(
            "assumeUnwindCond",
            false,
            "Assume unwinding condition for loops (default is asserting unwinding condition)"
        ),
        pythonName = "--optimistic_loop"
    ) {}
    val LoopUnrollBoundGuessingUpperLimit = object : ConfigType.IntCmdLine(
        default = Int.MAX_VALUE /* 2**31 - 1 */,
        Option(
            "loopUnrollBoundGuessUpperLimit",
            true,
            "Any loop that was inferred to have at least this number of iterations will be unrolled using" +
                " the usual loop_iter bound instead of the guessed number of iterations. [default: 2^31-1]"
        )
    ) {}

    val AssumeDeadStorageIsZero = object : ConfigType.BooleanCmdLine(
        default = false,
        Option(
            "assumeDeadStorageIsZero",
            true,
            "Whether to assume storage that is definitely never read before being overwritten must be zero [default: false]"
        )
    ) {}

    // Theory related
    val MaxStringSizeForComparison = object : ConfigType.IntCmdLine(
        32 * 10,
        Option("maxStringCmpSize", true, "Set max string size allowed for precise comparisons")
    ) {}

    // solc modeling
    // Q(alex): why is this related to structs? arrays are laid out contiguously in storage as well ... (and then the number looks low (?))
    val StructSizeLimit = object : ConfigType.IntCmdLine(
        4,
        Option("structSizeLimit", true, "Set max struct size in slots [default: 16]")
    ) {}  // Log scale  BigInteger.TWO.pow(4).toInt() // 16 // 16 is a nice number because it is 0x10 in hexa so cexs' are readable // TODO : (1) affects cache


    val MaxBaseStorageSlot =
        ("This needs to be set to a higher value than the index of the highest \"basic\" storage slot that is " +
            "assigned by the smart contract compiler on the given run. A basic storage slot is one that is not " +
            "computed via hashing (usually used for all statically allocated contract fields, so everything besides " +
            "mappings and dynamic arrays, anything that contains those).").let { desc ->
                object : ConfigType.BigIntCmdLine(
                    10000.toBigInteger(),
                    Option(
                        "maxBasicStorageSlot",
                        true,
                        desc,
                    ),
                    aliases = listOf(Option("maxSoliditySlot", true, desc))
                ) {
                    // force folks to leave a reasonable amount of address space for hashed addresses (not sure what's
                    // a good number, and not claiming to give a definitive threshold here; just making sure we're
                    // rejecting absurdly large values; in the end, hash collisions have to be extremely improbable,
                    // other factors are relevant, the usual math applies...)
                    val minLeftOverSpace = BigInteger.TWO.pow(100)

                    override fun check(newValue: BigInteger): Boolean {
                        return newValue >= BigInteger.ZERO
                            && newValue < (MAX_EVM_UINT256 - minLeftOverSpace)
                    }

                    override fun illegalArgMessage(newValue: BigInteger): String =
                        "Argument to ${option.realOpt()} must be a non-negative integer < (2^256-1 - $minLeftOverSpace)"
                }
            }

    val Mem0x0To0x40AsScalar = object : ConfigType.BooleanCmdLine(
        true,
        Option(
            "mem0x0To0x40AsScalar",
            true,
            "Treats all accesses to hash scratch space [0x0-0x40) in memory as scalars, ignoring any conflicting aliases from unresolved locations"
        )
    ) {}

    val HavocInitEVMMemory = object : ConfigType.BooleanCmdLine(
        false,
        Option(
            "havocInitEVMMemory",
            true,
            "Havoc each memory array on initialization. Useful for debugging purposes. [default: false]"
        )
    ) {}

    val AssumeFPIsStrictlyMonotonic = object : ConfigType.BooleanCmdLine(
        true,
        Option(
            "assumeFPStrictlyMonotonic",
            true,
            "If set to true, assumes the FP in memory is strictly monotonic increasing, and in particular, has no overflows [default: true]"
        )
    ) {}

    val BalanceCondCheckIfCallerIsCalleeForOverflow = object : ConfigType.BooleanCmdLine(
        false,
        Option(
            "checkIfCallerIsCalleeInTransferBalance",
            true,
            "Treat explicitly the src=trg case when transferring balance [default: false]"
        )
    ) {}

    // inlining
    val EnableSolidityBasedInlining = object : ConfigType.BooleanCmdLine(
        false,
        Option(
            "enableSolidityBasedInlining",
            true,
            "Decide if to use the Solidity source code to inline for _all_ methods"
        )
    ) {}
    val EnableSolidityBasedInliningInConstructor = object : ConfigType.BooleanCmdLine(
        true,
        Option(
            "enableSolidityBasedInliningInConstructor",
            true,
            "Decide if to use the Solidity source code to inline but applies just to the constructor"
        )
    ) {}

    // Optimizations
    val MaxHeuristicalFoldingTime =
        object : ConfigType.IntCmdLine(
            60, Option(
                "maxHeuristicalFoldingTimeSec",
                true,
                "Set the timeout for heuristical folding optimization, in seconds. [default: 60 seconds]"
            )
        ) {}

    val UnsatCoreFriendlyLeino = object : ConfigType.BooleanCmdLine(
        false,
        Option(
            "unsatCoreFriendlyLeino",
            true,
            "Make a top-level conjunct for the definition of each TAC statement in the Leino-style control " +
                "flow encoding. This makes individual statements visible in unsat core and similar things." +
                "The runtime overhead of this should be negligible in theory; according to experiments, it seems " +
                "to be negligible in the majority of cases." +
                "[default: false]"
        )
    ) {}
    val InlineReachVarDefs = object : ConfigType.BooleanCmdLine(
        true,
        Option(
            "inlineReachVarDefinitions",
            true,
            "Choose whether to replace each use of a ReachVar in the TACProgram with its simplified definition in the VC [default: true]"
        )
    ) {}
    val AggressiveSimpleRevertPathsPruning = object : ConfigType.BooleanCmdLine(
        false,
        Option(
            "aggressiveSimpleRevertPathsPruning",
            true,
            "When using sinvoke, prune all reverting paths in all inlined functions (assumes no calls will check reverting in internal calls) [default: false]"
        )
    ) {}

    val DisableInputSizeValidation = object : ConfigType.BooleanCmdLine(
        false,
        Option(
            "disableInputSizeValidation",
            true,
            "Choose whether to disable sanity checks on the size of external function input buffers. [default: false]"
        )
    ) {}

    val OptimisticReturnsize = object : ConfigType.BooleanCmdLine(
        false,
        Option(
            "optimisticReturnsize",
            true,
            "Choose whether to optimistically assume return size matches the detected call's signature, if it is known. [default: false]"
        )
    ) {}
    val SuperOptimisticReturnsize = object : ConfigType.BooleanCmdLine(
        false,
        Option(
            "superOptimisticReturnsize",
            true,
            "Choose whether return value havocs are assuming returnsize is call's requested outsize (unsound!) [default: false]"
        )
    ) {}
    val OptimisticExtcodesize = object : ConfigType.BooleanCmdLine(
        true,
        Option(
            "optimisticExtcodesize",
            true,
            "Choose whether to optimistically assume extcodesize of the receiver contract is positive. [default: true]"
        )
    ) {}
    val EnabledInitializationAnalysis = object : ConfigType.BooleanCmdLine(
        true,
        Option(
            "enableInitializationAnalysis",
            true,
            "Choose whether to enable initialization annotation analysis. [default: true]"
        )
    ) {}

    val EnabledABIAnalysis = object : ConfigType.BooleanCmdLine(
        false,
        Option(
            "enableABIAnalysis",
            true,
            "Enable (EXTREMELY EXPERIMENTAL) ABI encoder/decoder analyses and instrumentation"
        )
    ) {}

    val OptimisticBufferContents = object : ConfigType.BooleanCmdLine(
        false,
        Option(
            "optimisticBufferContents",
            true,
            "Don't discard buffer contents that only appear in one path of execution (unsound)"
        )
    ) {}

    val EnableAggressiveABIOptimization = object : ConfigType.BooleanCmdLine(
        false,
        Option(
            "enableAggressiveABIOptimization",
            true,
            "When enabled, try to aggressively optimize away unneeded ABI ser/de code. This disables call family opcode hooks, and will impact call trace quality"
        )
    ) {}

    val AttemptToFixMemoryOverlaps = object : ConfigType.BooleanCmdLine(
        true,
        Option(
            "enableMemoryOverlapsFixer",
            true,
            "Enables the memory overlap fixer. [default: true]"
        )
    ) {}

    val EnabledMemorySplitting = object : ConfigType.BooleanCmdLine(
        true,
        Option(
            "enableMemorySplit",
            true,
            "Flag added for understanding the effect of PTA guided memory splitting on SMT times / precision"
        )
    ) {}

    val EnablePTABasedOptimizations = object : ConfigType.BooleanCmdLine(
        true,
        Option(
            "enablePTABasedOptimizations",
            true,
            "Flag added for understanding the effect of PTA guided optimizations on SMT times / precision"
        )
    ) {}

    val EnabledFlowSensitivePartitioning = object : ConfigType.BooleanCmdLine(
        default = false,
        Option(
            "enableFlowSensitivePartitioning",
            true,
            "Enable flow-sensitive splitting of partitions that are heuristically indicated to not interfere. Experimental, and potentially unsound"
        )
    ) {}

    /**
     * It's very good for soundness - dispatch lists on .call, CALL hooks on raw buffers, encodeCall with complex types
     * + we think it's good for performance
     */
    val EnabledCopyLoopRewrites = object : ConfigType.BooleanCmdLine(
        default = true,
        Option(
            "enableCopyLoopRewrites",
            true,
            "Enable replacing validated copy loops with byte long copies [default: true]"
        )
    ) {}

    val RewriteMSizeAllocations = object : ConfigType.BooleanCmdLine(
        false, Option(
            "rewriteMSizeAllocations",
            true, "Rewrite allocations that use the msize() built-in"
        )
    ) {}

    val EnabledAggressivePartitionPruning = object : ConfigType.BooleanCmdLine(
        default = true,
        Option(
            "enableAggressivePartitionPruning",
            true,
            "Enable aggressively removing all writes to partitions that are never read"
        )
    ) {}

    val EnabledAggressivePathPruning = object : ConfigType.BooleanCmdLine(
        default = true,
        Option(
            "enableAggressivePathPruning",
            true,
            "Enable statically pruning the graph whenever possible as determined by the VRA [default: true]"
        )
    ) {}

    val EnableSimpleContractMatching = object : ConfigType.BooleanCmdLine(
        default = true,
        Option(
            "enableSimpleContractMatching",
            true,
            "When de-duplicating contracts in the scene, assume all contracts with the same name are the same [default: true]"
        )
    ) {}

    val SummaryResolutionMode = object : ConfigType.SummaryResolutionMode(
        default = SummaryResolutionPolicy.SIMPLE,
        Option(
            "summaryResolutionMode",
            true,
            "Controls the strategy for inlining summaries. `${SummaryResolutionPolicy.SIMPLE.name.lowercase()}` (the legacy strategy) inlines all summaries eagerly." +
                " `${SummaryResolutionPolicy.TIERED.name.lowercase()}` uses an intermediate callee analysis and defers dispatch summary" +
                "inlining as late as possible to improve intermediate code size [default: ${SummaryResolutionPolicy.SIMPLE.name.lowercase()}]"
        )
    ) {}

    /*
      XXX(jtoman): there is some overlap here with the equality saturation flag below, but they affect different
      things
     */
    val EnabledEqualityReasoning = object : ConfigType.BooleanCmdLine(
        default = false,
        option = Option(
            "enableEqualityReasoning",
            true,
            "Choose whether to enable aggressive saturation when interpreting equality expressions [default: false]"
        )
    ) {}

    val EnabledEqualitySaturation = object : ConfigType.BooleanCmdLine(
        default = true,
        option = Option(
            "enableEqualitySaturation",
            true,
            "Choose whether to enable saturating points-to qualifier information with equality information [default: true]"
        )
    ) {}

    val LinearInvariantBound = object : ConfigType.IntCmdLine(
        default = 3,
        option = Option(
            "linearInvariantBound",
            true,
            "Bound the size of linear invariants during analysis to include no greater than N variables [default: 3]"
        )
    ) {}

    val defaultInvariantType = ConfigType.CmdLine(
        converter = InvariantTypeConverter,
        default = InvariantType.WEAK,
        option = Option(
            "defaultInvariantType",
            true,
            "The type of an invariant to use when declaring an invariant without weak or strong keyword.  [default: weak]"
        )
    )

    val GloballyRelaxedPointsToSemantics = object : ConfigType.BooleanCmdLine(
        default = false,
        option = Option(
            "globallyRelaxedPointerSemantics",
            true,
            "Allow relaxed bounds checking for points-to analysis for all methods. " +
                "WARNING: Can introduce unsoundness into the results."
        )
    ) {}

    val RelaxedPointsToSemantics = object : ConfigType.RelaxedSemantics(
        default = arrayOf(),
        option = Option(
            "relaxedPointerSemantics",
            true,
            "A comma-separated list of contract:method pairs, where method is the name of an external function defined in contract (without parameters). " +
                "For these methods, allow relaxed bounds checking for points-to analysis. WARNING: Can introduce unsoundness into the results."
        )
    ) {}

    val SceneConstructionOnly: ConfigType.BooleanCmdLine = object : ConfigType.BooleanCmdLine(
        default = false,
        option = Option(
            "sceneConstructionOnly",
            true,
            "Choose whether to stop CVT after scene-construction. [default: false]"
        )
    ), TransformationAgnosticConfig {}
    val EnabledTriangleSimplification = object : ConfigType.BooleanCmdLine(
        true,
        Option(
            "enableTriangleSimplification",
            true,
            "Choose whether to enable triangle simplification. [default: true]"
        )
    ) {}

    val PreprocessOnly: ConfigType.BooleanCmdLine = object : ConfigType.BooleanCmdLine(
        default = false,
        option = Option(
            "preprocessOnly",
            true,
            "Choose whether to stop CVT after initial scene pre-processing [default: false]"
        )
    ), TransformationAgnosticConfig {}

    val SimplificationDepth = object : ConfigType.IntCmdLine(
        -1,
        Option(
            "simplificationDepth",
            true,
            "Maximum depth of expression trees to traverse during expression simplification, -1 for unlimited [default: -1]"
        )
    ) {}

    val DefAnalysisPreproceesingThreshold = object : ConfigType.IntCmdLine(
        100,
        Option(
            "defThreshold",
            true,
            "The number of def analysis queries that trigger a full dataflow analysis of the program [default: 100]"
        )
    ) {}

    val LogInitializationStatus = object : ConfigType.BooleanCmdLine(
        false,
        Option(
            "logInitializationStatus",
            true,
            "Log the results of the initialization analysis [default: false]"
        )
    ) {}

    val EnableStorageAnalysis = object : ConfigType.BooleanCmdLine(
        true,
        Option(
            "enableStorageAnalysis",
            true,
            "Choose whether to enable storage analysis. [default: true]"
        )
    ) {}

    val EnableStorageSplitting = object : ConfigType.BooleanCmdLine(
        true,
        Option(
            "enableStorageSplitting",
            true,
            "Choose whether to enable storage splitting (depends on storage analysis). [default: true]"
        )
    ) {}

    val MatchStorageLikeHashesInUnreservedSlots = object : ConfigType.BooleanCmdLine(
        true,
        Option(
            "matchStorageLikeHashes",
            true,
            "Choose whether to interpret as 'storage hashes' hashes that are of buffers of length 32 or 64 bytes, " +
                "even if not necessarily within the memory reserved slots. [default: true]"
        )
    ) {}

    val OptimisticVyperArrayLengthWrites = object : ConfigType.BooleanCmdLine(
        false,
        Option(
            "optimisticVyperStorageLengthWrites",
            true,
            "Assume that all writes to the length of a vyper array in storage are less than " +
                "the array's allocated size"
        )
    ) {}

    val PeelVyperStorageLoops = object : ConfigType.BooleanCmdLine(
        true,
        Option(
            "peelVyperStorageLoops",
            true,
            "Peel iterations of vyper-generated loops that appear to copy arrays to and from storage"
        )
    ) {}

    val EnabledDisciplinedHashModel = object : ConfigType.BooleanCmdLine(
        true,
        Option(
            "enabledDisciplinedHashModel",
            true,
            "Enables or disabled the disciplined hash model allowing for more precise hashing based on " +
                "memory write patterns, hashes each written component separately instead of word-by-word. " +
                "Usually disabled for testing purposes only. [default: true]"
        )
    ) {}

    val EvaluateLiteralHashLength = object : ConfigType.IntCmdLine(
        default = 16,
        Option(
            "evaluateLiteralHashLength",
            true,
            "Evaluate keccak256() commands when they are given literal strings that are at least this long. " +
                "[default: 16]"
        )
    ) {}

    val FullWordLinking = object : ConfigType.BooleanCmdLine(
        false,
        Option(
            "fullWordLinking",
            true,
            "Choose whether to fall back to full word (32 bytes) linking constraint (that is potentially unsound)" +
                "when the storage analysis is either disabled, failed, or we otherwise try " +
                "to link to a non-160-bit wide variable. [default: false]"
        )
    ) {}

    val EnableHeuristicalFolding = object : ConfigType.BooleanCmdLine(
        true,
        Option(
            "enableHeuristicalFolding",
            true,
            "Choose whether to eagerly fold variable definitions inside Stores and Selects. [default: true]"
        )
    ) {}

    val SummarizeExtLibraryCallsAsNonDetPreLinking = object : ConfigType.BooleanCmdLine(
        false,
        Option(
            "summarizeExtLibraryCallsAsNonDetPreLinking",
            true,
            "Choose whether to set all external delegate calls to be nondet"
        )
    ) {}

    val SummarizeUnresolvedAsNondet = object : ConfigType.BooleanCmdLine(
        false,
        Option(
            "summarizeUnresolvedAsNondet",
            true,
            "Choose whether ALL unresolved external calls should be treated as pure, nondeterministic operations (potentially unsound) [default: false]"
        )
    ) {}

    val AutoNondetMinimalDifficulty = object : ConfigType.IntCmdLine(
        50,
        Option(
            "autoNondetMinimalDifficulty",
            true,
            "The minimal 'difficulty' of a pure/view internal method that should be summarized as NONDET [default: 50]"
        ),
        pythonName = "--nondet_minimal_difficulty"
    ) {}

    val AutoNondetDifficultInternalFuncs = object : ConfigType.BooleanCmdLine(
        false,
        Option(
            "autoNondetDifficultInternalFuncs",
            true,
            "If enabled, will summarize as NONDET all value-type returning internal functions which are view or pure, " +
                "with minimal difficulty threshold set by ${AutoNondetMinimalDifficulty.name} [default: false]"
        ),
        pythonName = "--nondet_difficult_funcs"
    ) {}

    // // splitting

    /** A flag to switch splitting off altogether -- internally, `false` will set [SplittingDepth] to 0, so it's enough
     * to look at [SplittingDepth] for solver-internal purposes. */
    @TestOnly
    val EnableSplitting: ConfigType.BooleanCmdLine = object : ConfigType.BooleanCmdLine(
        true,
        Option("split", true, "Enable subproblem splitting during TAC to SMT translation [default: true]")
    ), RuleCacheAgnosticConfig {}

    val EnableResplitting: ConfigType.BooleanCmdLine = object : ConfigType.BooleanCmdLine(
        true,
        Option(
            "resplitting", true,
            "Enable immediate resplitting of TAC Programs when the sibling split was solved easily [default: true]"
        )
    ), RuleCacheAgnosticConfig {}

    @TestOnly
    val SplittingDepthPrivate: ConfigType.IntCmdLine =
        object : ConfigType.IntCmdLine(10, Option("depth", true, "Set max depth of splitting problem trees")),
            RuleCacheAgnosticConfig {}

    val MediumSplitTimeout: ConfigType.IntCmdLine =
        object :
            ConfigType.IntCmdLine(10, Option("mediumTimeout", true, "Set timeout [seconds] for medium score splits")),
            RuleCacheAgnosticConfig {}
    val LowSplitTimeout: ConfigType.IntCmdLine =
        object : ConfigType.IntCmdLine(5, Option("lowTimeout", true, "Set timeout [seconds] for low score splits")),
            RuleCacheAgnosticConfig {}
    val TinySplitTimeout: ConfigType.IntCmdLine =
        object :
            ConfigType.IntCmdLine(2, Option("tinyTimeout", true, "Set timeout [seconds] for very low score splits")),
            RuleCacheAgnosticConfig {}
    val DontStopAtFirstSplitTimeout: ConfigType.BooleanCmdLine = object : ConfigType.BooleanCmdLine(
        false,
        Option(
            "dontStopAtFirstSplitTimeout",
            true,
            "If true, do not stop at first timeout of split and continue to other branches if possible [default: false]"
        )
    ), TransformationAgnosticConfig {}

    val SplitOrder = ConfigType.CmdLine(
        converter = SplitOrderConverter,
        default = SplitOrderEnum.DFS,
        option = Option(
            "splitOrder",
            true,
            "What's the algorithm for going over the splits of the program we generate [default: dfs]"
        )
    )

    val SplitHeuristic = ConfigType.CmdLine(
        converter = SplitHeuristicConverter,
        default = SplitHeuristicEnum.NON_LINEAR,
        option = Option(
            "splitHeuristic",
            true,
            "The heuristic for choosing the pivot to split programs on [default: nonlinear]"
        )
    )

    val UnderApproxStartDepth = ConfigType.IntCmdLine(
        -1,
        Option(
            "underApproxStartDepth",
            true,
            "Start under-approximating at given depth, -1 stands for never do it [default = -1]"
        )
    )


    val ParallelSplitting: ConfigType.BooleanCmdLine = object : ConfigType.BooleanCmdLine(
        false,
        Option(
            "splitParallel", true,
            "Enable parallelised control-flow splitting during TAC to SMT translation [default: false]"
        )
    ), RuleCacheAgnosticConfig {}
    val OldParallelSplitting: ConfigType.BooleanCmdLine = object : ConfigType.BooleanCmdLine(
        false,
        Option(
            "oldSplitParallel", true,
            "Enable old parallelised control-flow splitting during TAC to SMT translation [default: false]"
        )
    ), RuleCacheAgnosticConfig {}
    val ParallelSplittingStepSize: ConfigType.IntCmdLine = object : ConfigType.IntCmdLine(
        2,
        Option(
            "splitParallelStepSize", true,
            "Number of splits done at once without checking the intermediate sub problems [default: 2]"
        )
    ), RuleCacheAgnosticConfig {}
    val ParallelSplittingTimelimit: ConfigType.IntCmdLine = object : ConfigType.IntCmdLine(
        3600,
        Option(
            "splitParallelTimelimit", true,
            "Overall timelimit for the parallelised splitting approach [default: 3600sec]"
        )
    ), RuleCacheAgnosticConfig {}
    val ParallelSplittingInitialDepth: ConfigType.IntCmdLine = object : ConfigType.IntCmdLine(
        0,
        Option(
            "splitParallelInitialDepth", true,
            "Possibly immediately split the input program to the given depth [default: 0]"
        )
    ), RuleCacheAgnosticConfig {}

    val NumOfParallelisedSplits: ConfigType.IntCmdLine = object : ConfigType.IntCmdLine(
        5,
        Option("numOfParallelSplits", true, "[default: 5]")
    ), RuleCacheAgnosticConfig {}

    val ParallelSplitterLIASolvers: ConfigType.SolverProgramCmdLine = object : ConfigType.SolverProgramCmdLine(
        SolverChoice(listOf(SolverConfig.z3.lia1)).toTypedArray(),
        Option(
            "smt_parallelLIASolvers", true, "LIA solvers that will be used " +
                "within the parallelised splitter (if enabled). [default: z3:lia1]"
        ),
    ), TransformationAgnosticConfig {}

    val ParallelSplitterNIASolvers: ConfigType.SolverProgramCmdLine = object : ConfigType.SolverProgramCmdLine(
        SolverChoice(listOf(SolverConfig.z3.def)).toTypedArray(),
        Option(
            "smt_parallelNIASolvers", true, "NIA solvers that will be used " +
                "within the parallelised splitter (if enabled). [default: z3:def]"
        ),
    ), TransformationAgnosticConfig {}


    /**
     * Autoconfig settings
     */
    val AutoconfigUseDigests = object : ConfigType.BooleanCmdLine(
        false,
        Option(
            "autoconfig_digest", true,
            "Store digest for TAC split statistics [default: false]"
        )
    ) {}
    val AutoconfigLearnFromCurrent = object : ConfigType.BooleanCmdLine(
        false,
        Option(
            "autoconfig_learn_from_current", true,
            "Learn from already solved splits [default: false]"
        )
    ) {}
    val AutoconfigSoftCmdsThreshold = object : ConfigType.IntCmdLine(
        0,
        Option("acSoft", true, "[default: 0]")
    ) {}
    val AutoconfigHardCmdsThreshold = object : ConfigType.IntCmdLine(
        0,
        Option("acHard", true, "[default: 0]")
    ) {}


    // // cache
    val CacheKeyName = object :
        ConfigType.StringCmdLine("invalid", Option("cache", true, "Enable caching, provide name of cache key")) {
        override fun check(newValue: String): Boolean =
            newValue != default

        override fun illegalArgMessage(newValue: String): String = "Cache key name must not be \"invalid\""
    }

    val UsePerRuleCache = object : ConfigType.BooleanCmdLine(
        true,
        Option("usePerRuleCache", true, "Enable per-rule cache [default: true]"),
        pythonName = "--use_per_rule_cache"
    ) {}

    val DeleteCache = object : ConfigType.BooleanCmdLine(
        false,
        Option("deleteCache", true, "Delete the cache in this execution [default: false]")
    ) {}

    val CachePolicyType: ConfigType.StringCmdLine = object : ConfigType.StringCmdLine(
        default = CachePolicy.Standard.ALWAYS.name.lowercase(),
        option = Option("cachepolicy", true, "Use the specified caching policy")
    ), TransformationAgnosticConfig {
        override fun check(newValue: String): Boolean {
            return CachePolicy.Standard.entries.any {
                it.name.equals(newValue, ignoreCase = true)
            }
        }
    }

    val CacheDirName: ConfigType.StringCmdLine = object : ConfigType.StringCmdLine(
        if (ArtifactFileUtils.hasCertoraDir()) {
            "${ArtifactFileUtils.getCertoraDir()}${File.separator}cache"
        } else { // if no CERTORA path, user current working directory
            "${System.getProperty("user.dir")}${File.separator}cache"
        }, Option("cacheDir", true, "Global cache directory (DEFAULT: \$CERTORA/cache)")
    ), RuleCacheAgnosticConfig {}

    val VerifyCache = object : ConfigType.BooleanCmdLine(
        default = false,
        option = Option(
            "verifyCache", false, "Enable cache serialization verification mode (do not use in production)"
        )
    ) {}
    val dumpCacheStatistics = object : ConfigType.BooleanCmdLine(
        default = false,
        option = Option(
            "dumpCacheStats", false, "Store TAC stats to statsdata.json when touching " +
            "the AnalysisCache [default: false]"
        )
    ) {}
    val SaveVerifierResults = object : ConfigType.BooleanCmdLine(
        default = false,
        option = Option(
            "saveVerifierResults", false, "Enable serialization of the verifier results"
        ),
        pythonName = "--save_verifier_results"
    ) {}
    val AssertCacheHits: ConfigType.BooleanCmdLine = object : ConfigType.BooleanCmdLine(
        default = false,
        option = Option(
            "assertCacheHits", false, "Asserts that the run will hit on the cache every time (testing-only flag)"
        )
    ), TransformationAgnosticConfig {}

    val AssertNoJavaBlobSerializer: ConfigType.BooleanCmdLine = object : ConfigType.BooleanCmdLine(
        default = false,
        option = Option(
            "assertNoJavaBlobSerializer", false, "Asserts that JavaBlobSerializer is not used at runtime"
        )
    ), RuleCacheAgnosticConfig {}

    val CheckRuleDigest: ConfigType.BooleanCmdLine = object : ConfigType.BooleanCmdLine(
        default = false,
        option = Option("checkRuleDigest", false, "Check the digest for each rule [default: false]")
    ) {}

    val CanonicalizeTAC: ConfigType.BooleanCmdLine = object : ConfigType.BooleanCmdLine(
        default = true,
        option = Option(
            "canonicalizeTAC", true, "Canonicalize TAC before calling the solver." +
                "Note that --coverage_info advanced disables the canonicalization. [default: true]"
        )
    ) {}

    val TestMode = object : ConfigType.BooleanCmdLine(
        default = false,
        option = Option(
            "testMode", false, "Run extra checks in CI. Currently used to check Z3 against the fried-egg solver."
        )
    ) {}


    val VerifyTACDumps = object : ConfigType.BooleanCmdLine(
        default = false,
        option = Option(
            "verifyTACDumps", false, "Enable TAC serialization verification mode (do not use in production)"
        )
    ) {}

    // declaring the names here, so we can mutually use them in the descriptions
    const val optimisticUnboundedHashingName = "optimisticUnboundedHashing"
    const val hashingLengthBoundName = "hashingLengthBound"

    val PreciseHashingLengthBound = run {
        val desc = "If an array has a non-constant size, our modelling of the array's hash is precise " +
            "only up the length given in this option. There are two modes for handling the hashing of longer" +
            "arrays, \"optimistic\" and \"pessimistic\". See the option $optimisticUnboundedHashingName for" +
            "more information. The unit used in this option is 'byte'. So if this option is set to \"10\", " +
            "we precisely model hashing of arrays up to and including the size of 10 bytes. " +
            "[default: 224] (224 bytes precisely correspond to 7 EVM words)"
        object : ConfigType.IntCmdLine(
            224,
            Option(
                hashingLengthBoundName,
                true,
                desc,
            ),
            pythonName = "--hashing_length_bound"
        ) {}
    }

    val OptimisticUnboundedHashing = object : ConfigType.BooleanCmdLine(
        default = false,
        option = Option(
            optimisticUnboundedHashingName,
            true,
            "If an array has a non-constant size, our modelling of the array's hash is precise " +
                "only up to a certain length (set in the option $hashingLengthBoundName). " +
                "This option lets the user choose between two modes for handling the hashing of longer arrays, " +
                "pessimistic and optimistic. " +
                "In pessimistic mode, an assertion will fail whenever something is being hashed " +
                "whose length exceeds the bound set in the option $hashingLengthBoundName.  " +
                "In optimistic mode, it is assumed that whatever is being hashed does not exceed said bound.  " +
                " When this flag is set to true, CVT will run in optimistic mode, otherwise it will run " +
                "in pessimistic mode. [default: false]"
        ),
        pythonName = "--optimistic_hashing"
    ) {}

    val MaskOddBytesWhenHashing = object : ConfigType.BooleanCmdLine(
        default = false,
        option = Option(
            "hashing_maskOddBytes",
            true,
            "When hashing a part of an array of non-constant length, where the length is not word-aligned " +
                "(i.e. not divisible by 32), we need to apply a bitmask to the last word being hashed in order to be " +
                "precise. Switching this on might gain some precision but might lose some performance. [default: false]"
        )
    ) {}

    val ternaryCalculatorHighPrecision = object : ConfigType.BooleanCmdLine(
        default = true,
        option = Option(
            "ternary_high_precision",
            true,
            "when false, even if TernaryCalculator is called in high precision mode, it works in low precision mode" +
                " [default : true]"
        )
    ) {}

    val exactByteMaps = object : ConfigType.BooleanCmdLine(
        default = false,
        option = Option(
            "exactByteMaps",
            true,
            "if true, then bytemaps are modeled correctly w.r.t. overlapping writes. Currently this only" +
                "affects one inlining optimization we have... [default = false]"
        )
    ) {}

    val inliningVarCheckThreshhold = object : ConfigType.IntCmdLine(
        default = 30,
        option = Option(
            "inliningVarCheckThreshHold",
            true,
            "determines how many assignments must a var have so that we don't even bother checking if its" +
                "inlineable. [default = 30]"
        )
    ) {}


    val intervalsRewriter = object : ConfigType.IntCmdLine(
        default = 2,
        option = Option(
            "intervalsRewriter",
            true,
            "How many times to run IntervalsRewriter in sequence [default : 2]"
        )
    ) {}


    val patternRewriter = object : ConfigType.IntCmdLine(
        default = 10,
        option = Option(
            "patternRewriter",
            true,
            "The maximal number of times to run PatternRewriter in sequence [default : 4]"
        )
    ) {}


    val LastIntervalsRewriter = object : ConfigType.IntCmdLine(
        default = 1,
        option = Option(
            "lastIntervalsRewriter",
            true,
            "How many times to run IntervalsRewriter in sequence at the very end of the pipeline [default : 1]"
        )
    ) {}

    val OptimizeAfterSplits = ConfigType.IntCmdLine(
        default = 0,
        option = Option(
            "optimizeAfterSplits",
            true,
            "runs the intervals rewriter optimization after every split this number of times [default : 0]"
        )
    )

    // Solver related

    val SolverTimeout: ConfigType.IntCmdLine = "Solver timeout (seconds)".let { desc ->
        object : ConfigType.IntCmdLine(
            300,
            Option("t", true, desc),
            aliases = listOf(Option("timeout", true, desc)),
            pythonName = "--smt_timeout"
        ),
            RuleCacheAgnosticConfig {}
    }

    /** Get a solver timeout that respects the global timeout -- leading to more graceful shutdowns in some cases.
     * (This is a very lightweight-but-partial solution to the soft timeout problem.)
     * TODO: this isn't queried at just the right time right now -- it's queried at job creation time, but should be queried at solver start time .. (since the parallel job may have to wait its turn) */
    fun getSolverTimeout(globalTimeout: Int = GlobalTimeout.get(),
                         userGlobalTimeout: Int = UserGlobalTimeout.get(),
                         solverTimeout: Int = SolverTimeout.get()): Duration {
        val startTimeMillis = ManagementFactory.getRuntimeMXBean().getStartTime()
        if (actualGlobalTimeout(globalTimeout, userGlobalTimeout) == 0)
            return solverTimeout.seconds
        val timeRemainingSeconds =
            (actualGlobalTimeout(globalTimeout, userGlobalTimeout)-
                ((System.currentTimeMillis() - startTimeMillis) / 1000)).toInt()

        /** give some time to shutdown before hard timeout hits */
        val pad = 20
        val timeoutSeconds = timeRemainingSeconds - pad
        if (timeoutSeconds < 0) {
            return 1.seconds
        }
        return solverTimeout.coerceAtMost(timeoutSeconds).seconds
    }

    private const val solverProgramChoiceDesc = "Choose solver configurations to be used. If a solver name is used, " +
        "all configurations of the given solver will be used, e.g. -solvers=[z3,cvc5] allow all configurations of" +
        "z3 and cvc5. To use only some configurations of individual solvers, you can also specify them, e.g., " +
        "-solvers=[z3:def,cvc5:nl,z3:lia1] (see e.g. Z3SolverInfo.kt for all configs of z3). Any configuration can" +
        "be modified via -solvers=[z3{randomSeed=4},cvc5:def]." +
        "default: [All configurations from solvers from this set { z3, cvc4, cvc5, yices, bitwuzla } that are available on this system }]"
    val SolverProgramChoice: ConfigType.SolverProgramCmdLine = object : ConfigType.SolverProgramCmdLine(
        AllCommonAvailableSolversWithClOptions.toTypedArray(),
        Option("solver", true, solverProgramChoiceDesc),
        aliases = listOf(
            Option("s", true, solverProgramChoiceDesc),
            Option("solvers", true, solverProgramChoiceDesc)
        )
    ), TransformationAgnosticConfig {}

    val cegarConfig: ConfigType.CEGARConfigCmdLine = object : ConfigType.CEGARConfigCmdLine(
        CEGARConfig.default,
        Option("cegarConfig", true, "Choose CEGAR configuration."),
    ), TransformationAgnosticConfig {}

    val FormulaFileBasename = object :
        ConfigType.StringCmdLine("generic", Option("formulaFile", true, "Base name for debugged output file")) {}
    val SolverMemLimit = object : ConfigType.IntCmdLine(
        0,
        Option(
            "solverMemLimit", true, "memory limit in MegaBytes for the solver executable, choose " +
                "0 stands for \"no limit\" (if availableRam is set and this is set to 0, we auto-compute limits)" +
                " [default: 0]"
        )
    ) {}
    val AvailableRam = object : ConfigType.IntCmdLine(
        0,
        Option(
            "availableRam", true, "available RAM in MegaBytes, this number is assumed in " +
                "computing memory limits for individual (solver) processes, 0 stands for \"no information given\" " +
                "[default: 0]"
        )
    ) {}
    val SkipCallsToSolver = object : ConfigType.BooleanCmdLine(
        false,
        Option("skipFormulaChecking", false, "Do not check formulas (skip calling to solver)")
    ) {}
    val ShouldDeleteSMTFiles: ConfigType.BooleanCmdLine = object : ConfigType.BooleanCmdLine(
        true,
        Option(
            "deleteSMTFile",
            true,
            "set whether to delete SMT-LIB files (or, alternatively, not dump them in the first place) [default: true]"
        )
    ), TransformationAgnosticConfig {}
    val SkipCounterExamples = object : ConfigType.BooleanCmdLine(
        false,
        Option(
            "skipCounterExamples",
            true,
            "Set whether to skip counterexamples fetching and parsing [default: false]"
        )
    ) {}

    val PostProcessCEXTimeoutSeconds = object : ConfigType.IntCmdLine(
        10,
        Option(
            "postProcessCEXTimeout",
            true,
            "minimum timeout for counterexample postprocessing (prettification and diversification), " +
                "in seconds [default: 10]"
        )
    ) {}
    val MultipleCEXStrategy = object : ConfigType.MultipleCEXStrategyCmdLine(
        MultipleCEXStrategyEnum.NONE,
        Option(
            "multipleCEX",
            true,
            "Use a strategy to construct multiple counterexamples to have better code coverage." +
                "Available heuristics are: " +
                "${MultipleCEXStrategyEnum.entries.forEach { it.name.lowercase() }}" +
                "[default: ${MultipleCEXStrategyEnum.NONE.name.lowercase()}]"
        ),
        pythonName = "--multi_example"
    ) {}
    val prettifyCEX = object : ConfigType.PrettifyCEXCmdLine(
        PrettifyCEXEnum.BASIC,
        Option(
            "prettifyCEX",
            true,
            "Attempt to make counterexamples prettier by looking " +
                "for nicer (e.g., non-huge, non-aliasing) values. Available prettification strategies are: " +
                "${PrettifyCEXEnum.entries.forEach { it.name.lowercase() }}" +
                "[default: ${PrettifyCEXEnum.BASIC.name.lowercase()}]"
        )
    ) {}
    val PrettifyCEXVariables = object : ConfigType.StringListCmdLine(
        emptyArray(),
        Option(
            "prettifyCEXVariables", true, "Variables to prioritise" +
                " during model post-processing."
        )
    ) {}
    val EnableStatistics = object : ConfigType.BooleanCmdLine(
        true,
        Option("enableStatistics", true, "set whether to collect statistics [default: true]")
    ) {}

    // example usage: `-disabledTransformations OPTIMIZE_BITWISE_CLEANING`
    val DisabledTransformations = object : ConfigType.StringListCmdLine(
        emptyArray(),
        Option(
            "disabledTransformations", true, "Report-types to disable"
        )
    ) {}

    @Deprecated("unneeded, now that SolverProgramConfig takes a collection of solvers")
    val CheckAllSolvers = object : ConfigType.BooleanCmdLine(
        false,
        Option(
            "checkAllSolvers", true, "set whether to execute all SMT solvers; " +
                "overrides \"solver\" (aliases: \"s\", \"solvers\") option [default: false]"
        )
    ) {}

    val EmitSoliditySourceAnnotations = object : ConfigType.BooleanCmdLine(
        false,
        Option(
            "emitSoliditySourceAnnotations", false,
            "Emit annotations derived from Solidity source code disassembly. " +
                "This feature is currently in development, and may produce incorrect results " +
                "or negatively affect performance. [default: false]"
        )
    ) {}

    val EnableConditionalSnippets: ConfigType.BooleanCmdLine = object : ConfigType.BooleanCmdLine(
        true,
        Option(
            "enableConditionalSnippets", true,
            "Enabled entries in the calltrace informing about branching in the code. " +
                "Can be disabled if too noisy. [default: true]"
        )
    ) {}

    val CallTraceDecimalLimit = object : ConfigType.BigIntCmdLine(
        1_000.toBigInteger(),
        Option(
            "callTraceDecimalLimit",
            true,
            "For the Call Trace, controls the maximum value that will be displayed in decimal. " +
                "Values whose absolute value is larger than this will display in hexadecimal."
        )
    ) {}

    val CallTraceHardFail = object : ConfigType.HardFailCmdLine(
        HardFailMode.OFF,
        Option(
            "callTraceHardFail",
            true,
            "Hard fail when an exception occurs while attempting to build the Call Trace. " +
                "Available options:\n ${HardFailMode.paramDescriptions()}" +
                "[default: ${HardFailMode.OFF.configString}]"
        )
    ) {}

    val CallTraceTextDump = object : ConfigType.BooleanCmdLine(
        true,
        Option(
            "callTraceTextDump",
            true,
            "Dump a text file with a pretty-printing of each call trace to the `Reports` directory. " +
                "The files are called `ctpp_<rule name>.txt`." +
                "(useful for debugging without going through the web-based reports)" +
                "[default: true]"
        )
    ) {}

    val UnusedSummaryHardFail = object : ConfigType.HardFailCmdLine(
        HardFailMode.OFF,
        Option(
            "unusedSummaryHardFail",
            true,
            "Hard fail when an unused summary is detected. " +
                "Available options:\n ${HardFailMode.paramDescriptions()}" +
                "[default: ${HardFailMode.OFF.configString}]"
        ),
        pythonName = "--unused_summary_hard_fail"
    ) {}

    val OptimisticSummaryRecursion = object : ConfigType.BooleanCmdLine(
        false,
        Option(
            "optimisticSummaryRecursion", true,
            "When set to [true] the summary recursion limit will be assumed, and not asserted [default: false]"
        ),
        pythonName = "--optimistic_summary_recursion"
    ) {}

    val EnableWholeContractProxyInlining = object : ConfigType.BooleanCmdLine(
        default = false,
        option = Option(
            "enableWholeContractProxyInlining",
            true,
            "When set to [true], unresolved sighashes in a contract's fallback function are replaced with the whole contract version of the callee. [default: false]"
        )
    ) {}

    val SummaryRecursionLimit = "Choose number of times to unroll loops".let { desc ->
        object : ConfigType.IntCmdLine(
            0,
            Option("summaryRecursionLimit", true, desc),
            pythonName = "--summary_recursion_limit"
        ) {
            override fun check(newValue: Int): Boolean {
                return newValue >= 0
            }

            override fun illegalArgMessage(newValue: Int): String =
                "Argument to -summaryRecursionLimit should be a non-negative integer"
        }
    }

    /** The solvers we actually used, based on user input and defaults, and availability of each solver executable on
     * the machine we're running on. */
    val ActualSolverProgramChoice: SolverChoice by lazy {
        SolverChoice.fromFlags(
            @Suppress("DEPRECATION") CheckAllSolvers.get(),
            SolverProgramChoice.get().toList()
        )
    }

    val HashingScheme = Smt.HashingScheme

    val LiaBeforeBv = Smt.LiaBeforeBv

    val GetDifficulties = Smt.GetDifficulties

    val UseZ3WithPreprocessor = Smt.UseZ3WithPreprocessor

    val Z3PreprocessorTimeout = Smt.Z3PreprocessorTimeout

    val NIAsolvers = Smt.NIASolvers

    val LIAsolvers = Smt.LIASolvers

    val BVsolvers = Smt.BVSolvers

    val PreciseByteMaps = Smt.PreciseByteMaps

    val PartialNIASolvers = Smt.PartialNIASolvers

    val PartialNIASelectorDepth = Smt.PartialNIASelectorDepth

    val TimeoutCores = Smt.TimeoutCores
    val TimeoutCoreTimeout get() = Smt.TimeoutCoreTimeout.get().seconds

    // Do not set this value from a unit test; it causes the prover code to foul the global config.
    @PollutesGlobalState
    val TimeoutCracker = Smt.TimeoutCracker

    // Helper to get the TimeoutCracker value.  Getting the value doesn't foul global config.
    @OptIn(PollutesGlobalState::class)
    fun getTimeoutCracker() = TimeoutCracker.get()

    val NumOfUnsatCores = Smt.NumOfUnsatCores
    val UnsatCoresRequireUnion = Smt.UnsatCoresRequireUnion
    val UnsatCoresEnumerationTimeout get() = Smt.UnsatCoresEnumerationTimeout.get().seconds
    val TotalUnsatCoresEnumerationTimeout get() = Smt.TotalUnsatCoresEnumerationTimeout.get().seconds
    val UnsatCoresForAllAsserts get() = Smt.UnsatCoresForAllAsserts

    val SignedMulAxioms = Smt.AddSignedMulAxioms

    val GroundQuantifiers = Smt.GroundQuantifiers

    val CoverageInfoMode = object : ConfigType.CoverageInfoCmdLine(
        CoverageInfoEnum.NONE,
        Option(
            "coverageInfo",
            true,
            "Controls whether we compute a .spec and .sol coverage information (via unsat cores)." +
                "We currently support three modes: ${CoverageInfoEnum.entries.map { it.name.lowercase() }}. " +
                "In particular, ${CoverageInfoEnum.BASIC.name.lowercase()} computes the unsat cores and provide the coverage info " +
                "relatively quickly, however, it might be quite imprecise." +
                "On contrary, ${CoverageInfoEnum.ADVANCED.name.lowercase()} takes more time but should be more precise." +
                "[default: ${CoverageInfoEnum.NONE.name.lowercase()}]"
        ),
        pythonName = "--coverage_info"
    ) {}

    val CoverageInfoForTimeouts = object : ConfigType.BooleanCmdLine(
        false,
        Option(
            "coverageInfoForTimeouts",
            true,
            "If a rule is timing out, compute unsat core coverage info for the splits that have already " +
                "been solved (if any). [default: false]"
        )
    ) {}

    val SimpleOverflowPattern = object : ConfigType.BooleanCmdLine(
        true,
        Option(
            "simpleOverflowPatterns",
            true,
            "rewrite even trivial overflow patterns [default: true]"
        )
    ) {}

    /** SMT backend options */
    object Smt {
        /**
         * Make it so that using [PreciseBitwiseOps] requires a special [OptIn] annotation. This is meant as a purely
         * user-facing option, the code should use [UseBV] instead
         */
        @RequiresOptIn(
            level = RequiresOptIn.Level.ERROR,
            message = "Use Config.Smt.UseBV to check whether BV solvers should be used."
        )
        annotation class PreciseBitwiseOpsOption

        @PreciseBitwiseOpsOption
        val PreciseBitwiseOps: ConfigType.BooleanCmdLine = object : ConfigType.BooleanCmdLine(
            false,
            Option("smt_preciseBitwiseOps", false, "Show precise bitwise operation counter examples. Models mathints as unit256 that may over/underflow"),
            pythonName = "--precise_bitwise_ops"
        ), TransformationAgnosticConfig {}

        val BackendStrategy: ConfigType.CmdLine<BackendStrategyEnum> = object : ConfigType.CmdLine<BackendStrategyEnum>(
            BackendStrategyEnum.ADAPTIVE,
            BackendStrategyEnumConverter,
            Option(
                "backendStrategy", true,
                "chooses the backend solving strategy: adaptive, cegar or singlerace. [default: adaptive]"
            )
        ), TransformationAgnosticConfig {
            @Suppress("DEPRECATION")
            override fun get(): BackendStrategyEnum {
                if (!CEGAR.UseCEGAR.isDefault()) {
                    logger.warn { "Using deprecated option -${CEGAR.UseCEGAR.name}. Please use -${this.name}=cegar instead." }
                }
                if (!AdaptiveSolverConfig.isDefault()) {
                    logger.warn { "Using deprecated option -${AdaptiveSolverConfig.name}. Please use -${this.name}=adaptive instead." }
                }

                return when {
                    !isDefault() -> super.get()
                    CEGAR.UseCEGAR.get() -> BackendStrategyEnum.CEGAR
                    SingleRaceSolverConfig.get() -> BackendStrategyEnum.SINGLE_RACE
                    // if we leave adaptive on in the PreciseBitwiseOps case, we run LIA, which leads to suprising behavior
                    // (surprising results can happen since LIA is not an overapproximation of BV, due to mathints)
                    AdaptiveSolverConfig.isDefault() && AdaptiveSolverConfig.get() &&
                        @OptIn(PreciseBitwiseOpsOption::class) PreciseBitwiseOps.get() -> BackendStrategyEnum.SINGLE_RACE
                    !AdaptiveSolverConfig.isDefault() && AdaptiveSolverConfig.get() -> BackendStrategyEnum.ADAPTIVE
                    !AdaptiveSolverConfig.isDefault() && !AdaptiveSolverConfig.get() -> BackendStrategyEnum.SINGLE_RACE
                    else -> super.get()
                }.also {
                    if (it == BackendStrategyEnum.SINGLE_RACE) {
                        check(UseLIA.get() != UseLIAEnum.WITHOUT_VERIFIER || !UseNIA.get()) {
                            "We shouldn't run NIA solvers and non-verifying LIA solvers at the same time, as they can produce conflicting results."
                        }
                        check(!UseBV.get() || (UseLIA.get() == UseLIAEnum.NONE && !UseNIA.get())) {
                            "We shouldn't run BV solvers and (LN)IA solvers at the same time, as they can produce conflicting results."
                        }
                    }
                }
            }
        }

        @Deprecated("Use Config.Smt.BackendStrategy instead.")
        val SingleRaceSolverConfig: ConfigType.BooleanCmdLine = object : ConfigType.BooleanCmdLine(
            false,
            Option(
                "singleRaceSolverConfig", true,
                "set whether CVT should run solvers using multiple encodings (linear, non-linear, bit vector) " +
                    "in a single race." +
                    " [default: false]"
            )
        ), TransformationAgnosticConfig {}

        @Deprecated("Use Config.Smt.BackendStrategy instead.")
        val AdaptiveSolverConfig: ConfigType.BooleanCmdLine = object : ConfigType.BooleanCmdLine(
            true,
            Option(
                "adaptiveSolverConfig", true,
                "chooses the backend solving strategy. True will use our default strategy, false is an alias for -singleRaceSolverConfig true" +
                    " [default: true]"
            )
        ), TransformationAgnosticConfig {}

        val UseLIA: ConfigType.CmdLine<UseLIAEnum> = object : ConfigType.CmdLine<UseLIAEnum>(
            UseLIAEnum.WITH_VERIFIER,
            UseLIAEnumConverter,
            Option(
                "smt_useLIA",
                true,
                "Include LIA solvers in the race. If set to true, Solvers specified in \"LIASolvers\" " +
                    "will be included. [default: true, unless -preciseBitwiseOps is set]"
            )
        ), TransformationAgnosticConfig {
            @OptIn(PreciseBitwiseOpsOption::class)
            override fun get(): UseLIAEnum = when {
                !isDefault() -> super.get()
                PreciseBitwiseOps.get() -> UseLIAEnum.NONE
                else -> UseLIAEnum.WITH_VERIFIER
            }
        }

        val UseNIA: ConfigType.BooleanCmdLine =
            "Include NIA solvers in the race. If set to true, Solvers specified in \"NIASolvers\" will be included. [default: true, unless -preciseBitwiseOps is set]".let { desc ->
                object : ConfigType.BooleanCmdLine(
                    true,
                    Option("smt_useNIA", true, desc),
                    aliases = listOf(
                        Option("useNonLinearArithmetic", true, desc),
                        Option("smt_nonLinearArithmetic", true, desc),
                    )
                ), TransformationAgnosticConfig {
                    @OptIn(PreciseBitwiseOpsOption::class)
                    override fun get(): Boolean = when {
                        !isDefault() -> super.get()
                        else -> !PreciseBitwiseOps.get()
                    }
                }
            }

        val UseBV: ConfigType.BooleanCmdLine =
            """Use bit-vector encoding and bit-vector solvers in the race. If set to true, Solvers specified in \"-smt_BVSolvers\" will be used.
                Best used via \"-preciseBitwiseOps\", otherwise make sure to disable LIA and NIA via \"-smt_useLIA false -smt_useNIA false\".
                [defaults to -preciseBitwiseOps]""".trimMargin().let { desc ->
                object : ConfigType.BooleanCmdLine(
                    false,
                    Option("smt_useBV", false, desc),
                    aliases = listOf(
                        Option("useBitVectorTheory", true, desc),
                        Option("smt_bitVectorTheory", true, desc),
                    ),
                    pythonName = "--smt_use_bv"
                ), TransformationAgnosticConfig {
                    @OptIn(PreciseBitwiseOpsOption::class)
                    override fun get(): Boolean = when {
                        !isDefault() -> super.get()
                        else -> PreciseBitwiseOps.get()
                    }
                }
            }

        val PartialNIASolvers: ConfigType.SolverProgramCmdLine = object : ConfigType.SolverProgramCmdLine(
            default = emptyArray(),
            option = Option(
                "smt_partialNIASolver",
                true,
                "Choose solver configurations to be used for partial over-approximation of NIA with LIA. " +
                    "If empty or not given, partial LIA over-approximation is not used."
            )
        ), TransformationAgnosticConfig {}

        val PartialNIASelectorDepth: ConfigType.IntCmdLine = object : ConfigType.IntCmdLine(
            default = 20,
            option = Option(
                "smt_closeToAssertSelectorDepth",
                true,
                "Set the depth for the CloseToAssertSelector [default: 20]. This selector makes multiplications " +
                    "precise when that have a direct data flow into an assertion. This setting specifies the maximum length " +
                    "(as a number of assignment commands) that a data flow can have to activate this selector. Used together " +
                    "with the smt_partialNIASolver option."
            )
        ), TransformationAgnosticConfig {}

        val LIASolvers: ConfigType.SolverProgramCmdLine = object : ConfigType.SolverProgramCmdLine(
            emptyArray(), // default is based on target theory and timeout
            Option(
                "smt_LIASolvers",
                true,
                "LIA solvers that will be used if \"UseLIA\" is set to true. [default: predefined LIA solvers]"
            ),
        ), TransformationAgnosticConfig {}

        val NIASolvers: ConfigType.SolverProgramCmdLine = object : ConfigType.SolverProgramCmdLine(
            emptyArray(), // default is based on target theory and timeout
            Option(
                "smt_NIASolvers",
                true,
                "NIA solvers that will be used if \"UseNIA\" is set to true. [default: predefined NIA solvers]"
            ),
        ), TransformationAgnosticConfig {}

        val BVSolvers: ConfigType.SolverProgramCmdLine = object : ConfigType.SolverProgramCmdLine(
            emptyArray(), // default is based on target theory and timeout
            Option(
                "smt_BVSolvers",
                true,
                "BV solvers that will be used if \"UseBV\" is set to true. [default: predefined BV solvers]"
            ),
        ), TransformationAgnosticConfig {}

        val OverrideSolvers: ConfigType.BooleanCmdLine = object : ConfigType.BooleanCmdLine(
            false,
            Option(
                "smt_overrideSolvers", true, "Override solver lists instead of filtering predefined solver lists. " +
                    "I.e., it changes order of solvers configuration based on the user's choice and eventually " +
                    "adds configurations selected by user which are not presented in the predefined lists. [default: false]"
            )
        ), TransformationAgnosticConfig {}

        val HashingScheme: ConfigType.HashingSchemeCmdLine = object : ConfigType.HashingSchemeCmdLine(
            smt.HashingScheme.DefaultInt,
            Option(
                "smt_hashingScheme",
                true,
                "selects the scheme how we model and axiomatize hashing, options are: " +
                    "${
                        listOf(
                            smt.HashingScheme.Legacy.CONFIG_KEYWORD,
                            smt.HashingScheme.PlainInjectivity.CONFIG_KEYWORD,
                            smt.HashingScheme.Datatypes.CONFIG_KEYWORD,
                        ).joinToString(" ")
                    } " +
                    "[default: ${smt.HashingScheme.DefaultInt}]"
            )
        ), TransformationAgnosticConfig {}

        val LiaBeforeBv: ConfigType.BooleanCmdLine = object : ConfigType.BooleanCmdLine(
            true,
            Option(
                "smt_liaBeforeBv",
                true,
                "Try to solve [A][UF]BV problems using our [A][UF]LIA overapproximation before running the " +
                    "bv solver. [default: false]"
            )
        ), TransformationAgnosticConfig {}

        val SkipDelayedSolvers: ConfigType.BooleanCmdLine = object : ConfigType.BooleanCmdLine(
            true,
            Option(
                "smt_skipDelayedSolvers",
                true,
                "Allows to skip some Executables (SMT solver configurations) if there are not enough " +
                    "available cores/threads in a race. [default: true]"
            )
        ), TransformationAgnosticConfig {}

        val SolverWaitingRoundsBeforeSkip: ConfigType.IntCmdLine = object : ConfigType.IntCmdLine(
            3,
            Option(
                "smt_solverWaitingRoundsBeforeSkip", true,
                "Sets the number of 'rounds' a solver configuration can be waiting before it is skipped " +
                    "(if could be skipped).  In particular, 1 round is equal to the timeout for the solver configuration. " +
                    "Works only if -smt_skipDelayedSolvers is true. [default: 3 (rounds)]"
            )
        ), TransformationAgnosticConfig {}

        val GetDifficulties: ConfigType.BooleanCmdLine = object : ConfigType.BooleanCmdLine(
            false,
            Option(
                "smt_getDifficulties",
                true,
                "On timeout, retrieve per-assertion difficulties from solvers that support it. [default: false]"
            )
        ), TransformationAgnosticConfig {}

        val BlockIsDifficultThreshold: ConfigType.IntCmdLine = object : ConfigType.IntCmdLine(
            5,
            Option(
                "smt_blockDifficultyThreshold",
                true,
                "Minimum difficulty score for a TAC block to be marked as difficult. [default: 5]"
            )
        ), TransformationAgnosticConfig {}

        val UseZ3WithPreprocessor: ConfigType.BooleanCmdLine = object : ConfigType.BooleanCmdLine(
            false,
            Option(
                "smt_usePz3",
                true,
                "Include the solver variant 'CVC5 preprocessor + Z3 solver'. Available only in the adaptive mode. [default: false]"
            )
        ), TransformationAgnosticConfig {}

        val Z3PreprocessorTimeout: ConfigType.IntCmdLine = object : ConfigType.IntCmdLine(
            3,
            Option(
                "smt_z3PreprocessorTimeout", true, "timeout of the z3 preprocessor (flag -smt_use_pz3) " +
                    "in seconds [default: 3]"
            )
        ), TransformationAgnosticConfig {}

        val noLIAAxioms : ConfigType.BooleanCmdLine = object : ConfigType.BooleanCmdLine(
            false,
            Option(
                "smt_noLIAAxioms",
                true,
                "Inhibits the generation of all LIA axioms. Details: \"LIA axioms\" here means ones " +
                    "generated by `LinearMathAxiomGenerator`. The axioms coming from `IntMathAxiomGenerator`, e.g. for" +
                    "exponentiation, are still added. This can be seen as an extreme form of `smt_easyLia`. We consider " +
                    "it an experimental flag for expert users. " +
                    "[default : false]"
            )
        ), TransformationAgnosticConfig {}

        val easyLIA: ConfigType.BooleanCmdLine = object : ConfigType.BooleanCmdLine(
            true,
            Option(
                "smt_easy_LIA",
                true,
                "Inhibits the generation of LIA axioms for pairs of var by var multiplications [default : false]"
            )
        ), TransformationAgnosticConfig {}

        val bitwisePrecision: ConfigType.IntCmdLine = object : ConfigType.IntCmdLine(
            4,
            Option(
                "smt_bitwisePrecision",
                true,
                "sets precision of bitwise-ops modeling: 0 - no axioms, 1 - simple axioms (commutativity, etc), 2 - precise for masks like 0x00ff, 3 - also precise for 0xff00, 4 - also precise for 0xff00ff [default: 4]"
            )
        ), TransformationAgnosticConfig {
            val validValues = setOf(0, 1, 2, 3, 4)
            override fun check(newValue: Int): Boolean =
                newValue in validValues

            override fun illegalArgMessage(newValue: Int): String =
                "Invalid option for ${option.realOpt()}. Expected one of ${
                    validValues.joinToString(
                        prefix = "[",
                        postfix = "]"
                    )
                }"
        }

        val bitwisePrecisionLIAoverride: ConfigType.IntCmdLine = object : ConfigType.IntCmdLine(
            -1,
            Option(
                "smt_bitwisePrecisionLIAoverride",
                true,
                "if not -1, then gives a different precision to the LIA solver only, according to: 0 - no axioms, 1 - trivial axioms, 2 - precise for mask like 0x00ff, 3 - also precise for 0xff00, 4 - also precise for 0xff00ff [default: -1]"
            )
        ), TransformationAgnosticConfig {
            val validValues = setOf(-1, 0, 1, 2, 3, 4)
            override fun check(newValue: Int): Boolean =
                newValue in validValues

            override fun illegalArgMessage(newValue: Int): String =
                "Invalid option for ${option.realOpt()}. Expected one of ${
                    validValues.joinToString(
                        prefix = "[",
                        postfix = "]"
                    )
                }"
        }

        val NumOfUnsatCores: ConfigType.IntCmdLine = object : ConfigType.IntCmdLine(
            1,
            Option(
                "numOfUnsatCores",
                true,
                "Maximal number of minimal unsat cores to compute. Applies only when the flag " +
                    "-coverage_info is used with a value different than ${CoverageInfoEnum.NONE.name.lowercase()}."
            )
        ), TransformationAgnosticConfig {}

        val UnsatCoresRequireUnion: ConfigType.BooleanCmdLine = object : ConfigType.BooleanCmdLine(
            true,
            Option(
                "unsatCoresRequireUnion",
                true,
                "Add the union of MUSes from already processed splits as hard constraints when " +
                    "computing cores for the subsequent splits. This should speed up the enumeration " +
                    "but reduce the number of unique unsat cores. [default: true]"
            )
        ), TransformationAgnosticConfig {}

        val UnsatCoresForAllAsserts: ConfigType.BooleanCmdLine = object : ConfigType.BooleanCmdLine(
            false,
            Option(
                "unsatCoresForAllAsserts",
                true,
                "By default, we assume in the unsat core analysis only user defined asserts (from CVL). " +
                    "Using this flag, we include all asserts in the analysis. [default: false]"
            )
        ), TransformationAgnosticConfig {}

        val TimeoutCores: ConfigType.BooleanCmdLine = object : ConfigType.BooleanCmdLine(
            false,
            Option(
                "timeoutCores",
                true,
                "Compute detailed timeout root cause information using CVC5's (get-timeout-core) feature. " +
                    "The results will be visualized through extra colorings/tooltips in the tac graph. [default: false]"
            )
        ), TransformationAgnosticConfig {}

        val TimeoutCoreTimeout = object : ConfigType.IntCmdLine(
            60,
            Option(
                "timeoutCoreTimeout",
                true,
                "The timelimit for timeout core computation (as handed to CVC5), in seconds [default: 30]"
            )
        ) {}

        // Do not use this from a unit test; it causes the prover code to foul the global config.
        @PollutesGlobalState
        val TimeoutCracker: ConfigType.BooleanCmdLine = object : ConfigType.BooleanCmdLine(
            false,
            Option(
                "timeoutCracker",
                true,
                "Timeout Cracker mode on."
            )
        ), TransformationAgnosticConfig {}


        val UnsatCoresEnumerationTimeout = object : ConfigType.IntCmdLine(
            120,
            Option(
                "unsatCoresTimeout",
                true,
                "The timelimit for unsat core enumeration for a single split in seconds [default: 120]"
            )
        ) {}

        val TotalUnsatCoresEnumerationTimeout: ConfigType.IntCmdLine = object : ConfigType.IntCmdLine(
            900,
            Option(
                "totalUnsatCoresTimeout",
                true,
                "The timelimit for unsat core enumeration for all splits in total in seconds [default: 900]"
            )
        ), TransformationAgnosticConfig {}

        // configure axiomatization

        val AddSignedMulAxioms: ConfigType.BooleanCmdLine = object : ConfigType.BooleanCmdLine(
            true,
            Option(
                "smt_signedMulAxioms",
                true,
                "Generate LIA axioms for signed multiplication [default:true]"
            )
        ), TransformationAgnosticConfig {}

        val AddSafeMathAxioms : ConfigType.BooleanCmdLine = object : ConfigType.BooleanCmdLine(
            false,
            Option(
                "smt_safeMathAxioms",
                true,
                "Generate LIA axioms for safe math axioms. This is needed only if static analysis misses these" +
                    "patterns. These originate from the old safe-math library, and since solc8, solidity's auto " +
                    "generated overflow detection patterns. [default:false]"
            )
        ), TransformationAgnosticConfig {}

        val MaxPreciseConstantExponent : ConfigType.IntCmdLine = object : ConfigType.IntCmdLine(
            5,
            Option(
                "smt_maxPreciseConstantExponent",
                true,
                "For exponentiations with a constant exponent, e.g. `x^3`, we create an axiom that reduces " +
                    "them to multiplications, e.g. `x * x * x`. But only if they are below or equal to the bound set " +
                    "here. Above the bound, we overapproximate the exponentiation by an uninterpreted function. " +
                    "[default:true]"
            )
        ), TransformationAgnosticConfig {}

        val GroundQuantifiers = object : ConfigType.BooleanCmdLine(
            true,
            Option(
                "smt_groundQuantifiers",
                true,
                "Over-approximates quantifiers by using a grounding strategy [default:true]"
            )
        ) {} // NOT Transformation agnostic

        // configure splitting

        val InitialSplitDepth: ConfigType.IntCmdLine = object : ConfigType.IntCmdLine(
            0,
            Option(
                "smt_initialSplitDepth",
                true,
                "Splits all rules up to the given depth without trying to solve them. Also updates the \"depth\" param" +
                    " if needed such that \"depth\" >= \"smt_initialSplitDepth\" [default:0]"
            )
        ), TransformationAgnosticConfig {}

        val SplittingDepth get() =
            if (EnableSplitting.get()) {
                maxOf(SplittingDepthPrivate.get(), InitialSplitDepth.get())
            } else {
                0
            }

        val DumpAll: ConfigType.CmdLine<SmtDumpEnum> = object : ConfigType.CmdLine<SmtDumpEnum>(
            SmtDumpEnum.DISABLED,
            SmtDumpEnumConverter,
            Option(
                "smt_dump",
                true,
                "Dump all SMT sessions with solvers [default: false]"
            )
        ), TransformationAgnosticConfig {}

        val PreciseByteMaps: ConfigType.BooleanCmdLine = object : ConfigType.BooleanCmdLine(
            false,
            Option(
                "smt_preciseBytemaps",
                true,
                "Support precise bytemap semantic (unaligned reads, overlapping, etc.) [default: false]"
            )
        ), TransformationAgnosticConfig {}
    }

    /**
     * CEGAR settings.
     */
    val CEGARConstraintChooser = CEGAR.ConstraintChooser
    val CEGARSolvers = CEGAR.Solvers
    val CEGARExactSolvers = CEGAR.ExactSolvers
    val CEGARPlusNIA = CEGAR.ExactNIA
    val CEGARNIARelaxations = CEGAR.NIARelaxations
    val CEGARModelDiff = CEGAR.ModelDiff
    val CEGARLearn = CEGAR.Learn
    val CEGARModelDiffThreshold = CEGAR.ModelDiffThreshold

    object CEGAR {
        @Deprecated("Use Config.Smt.BackendStrategy instead.")
        val UseCEGAR: ConfigType.BooleanCmdLine = object : ConfigType.BooleanCmdLine(
            false,
            Option(
                "cegar",
                true,
                "Use CEGAR instead of the adaptive (or non-adaptve) mode. [default: false]"
            )
        ), TransformationAgnosticConfig {}

        val ConstraintChooser: ConfigType.ConstraintChooserCmdLine = object : ConfigType.ConstraintChooserCmdLine(
            ConstraintChooserEnum.justBools,
            Option(
                "cegar_CC",
                true,
                "CEGAR constraint chooser, options are: " +
                    "${ConstraintChooserEnum.entries.toTypedArray()} " +
                    "[default: ${ConstraintChooserEnum.justBools}]"
            )
        ), TransformationAgnosticConfig {}

        val Solvers: ConfigType.IntCmdLine = object : ConfigType.IntCmdLine(
            2,
            Option(
                "cegar_solvers", true, "Number of solver configurations to use (1-3) [default: 2]"
            )
        ), TransformationAgnosticConfig {}

        val ExactSolvers: ConfigType.IntCmdLine = object : ConfigType.IntCmdLine(
            2,
            Option(
                "cegar_exactSolvers", true, "Number of solver exact NIA configurations to use (1-3). " +
                    "These run in parallel with the CEGAR workflow. [default: 2]"
            )
        ), TransformationAgnosticConfig {}

        val ExactNIA: ConfigType.BooleanCmdLine = object : ConfigType.BooleanCmdLine(
            true,
            Option(
                "cegar_plusNIA",
                true,
                "Run NIA in parallel with the CEGAR. [default: true]"
            )
        ), TransformationAgnosticConfig {}

        val NIARelaxations: ConfigType.IntCmdLine = object : ConfigType.IntCmdLine(
            10,
            Option(
                "cegar_NIARelaxations", true, "Number of times a single LIA model is relaxed in CEGAR." +
                    "Note that this is not the number of LIA -> NIA, LIA -> NIA, ... iterations. [default: 10]"
            )
        ), TransformationAgnosticConfig {}

        val ModelDiff: ConfigType.BooleanCmdLine = object : ConfigType.BooleanCmdLine(
            false,
            Option(
                "cegar_modelDiff",
                true,
                "Relax a LIA model in CEGAR if it is too similar to the previous LIA model. [default: false]"
            )
        ), TransformationAgnosticConfig {}

        val ModelDiffThreshold: ConfigType.IntCmdLine = object : ConfigType.IntCmdLine(
            20,
            Option(
                "cegar_modelDiffThreshold", true, "The maximum number of variables assignments" +
                    " that might differ in the new and the previous LIA model to relax the new model. [default: 20]"
            )
        ), TransformationAgnosticConfig {}

        val Learn: ConfigType.BooleanCmdLine = object : ConfigType.BooleanCmdLine(
            false,
            Option(
                "cegar_learn",
                true,
                "Include CVC5 in the worker pool, use its learned-lits functionality, and add the learned lits " +
                    "to the LIA and NIA queries. [default: false]"
            )
        ), TransformationAgnosticConfig {}
    }

    /** Note: despite being in the [PathEnumeration] category, this flag can also be used in other modes (though
     * to less usefulness probably). */
    val GenerateUnsatCores = object : ConfigType.BooleanCmdLine(
        default = false,
        option = Option(
            "pathEnum_generateUnsatCores",
            true,
            "For each refuted path, display an unsat core that summarizes the reason of infeasibility. " +
                "Note that this can considerably slow down the SMT solvers. [default: false]"
        )
    ) {}

    object ProofArtifacts {
        val ProofArtifactPreCheckTimeout = object : ConfigType.IntCmdLine(
            default = 10,
            option = Option(
                "proofArtifactPreCheckTimeout",
                true,
                "In proof artifact mode, individual paths (and their purely conjunctive sub-paths) get a " +
                    "low-timeout pre-check to see if they can be discharged without the artifact. This option sets" +
                    "that timeout."
            )
        ) {}

        val ProofArtifactFile = object : ConfigType.StringCmdLine(
            default = null,
            option = Option(
                "proofArtifactFile",
                true,
                "Provide the given file as source of proof artifacts; use in conjunction with other option to " +
                    "give the name of a lemma inside the file."
            )
        ) {}

        val ProofArtifactLemmaName = object : ConfigType.StringCmdLine(
            default = null,
            option = Option(
                "proofArtifactLemmaName",
                true,
                "Name of the lemma that should be used from the file given via the other option."
            )
        ) {}
    }

    val DispatchOnCreated = object : ConfigType.BooleanCmdLine(
        false,
        Option(
            "dispatchOnCreated",
            true,
            "Automatically attempt dispatch on all call-sites that must be on new contract instances"
        ),
        pythonName = "--dynamic_dispatch"
    ) {}

    val DynamicCreationBound = object : ConfigType.IntCmdLine(
        0,
        Option(
            "dynamicCreationBound",
            true,
            "Simulate contract creation by cloning existing scene contracts up to the given bound"
        ),
        pythonName = "--dynamic_bound"
    ) {}

    val OptimisticFallback = ConfigType.BooleanCmdLine(
        false,
        Option(
            "optimisticFallback",
            true,
            "Set whether to optimistically assume unresolved fallback functions do not havoc state (default: false)"
        ),
        pythonName = "--optimistic_fallback"
    )

    val DivideByConstants = object : ConfigType.BigIntCmdLine(
        null,
        Option(
            "divideByConstants",
            true,
            "Replace divisions with a constant divider to quickly flesh out problems before running the full NIA problem. " +
                "This option is disabled by default."
        )
    ) {
        override fun check(newValue: BigInteger): Boolean {
            return newValue != BigInteger.ZERO
        }

        override fun illegalArgMessage(newValue: BigInteger): String = "constant divider must be > 0"
    }

    val DivideNoRemainder = object : ConfigType.BooleanCmdLine(
        false,
        Option(
            "divideNoRemainder",
            true,
            "Constrain divisions to have no remainder"
        )
    ) {}

    @Deprecated("Remove in next major version v8")
    val RelaxedFunctionFinders = object : ConfigType.RelaxedFinders(
        default = false,
        option = Option(
            "functionFinderMode",
            true,
            "The function finder mode; possible values are `default`, `extended`, and `relaxed`. `relaxed` will relax some restrictions of the function finder."
        )
    ) {}

    val RegressionTest = object : ConfigType.BooleanCmdLine(
        false,
        Option(
            "regressionTest",
            false,
            "set whether to collect output messages of regression test  [default: false]"
        )
    ) {}

    // Getters and wrappers

    // If configs exist for those, then they can live outside the main artifact folder.
    // for stats file, we always create statsdata.json, but if we override it, we just make another one

    fun getDefaultJSONStatsDataOutputFile(): String = OutputJSONStatsDataFilePrefix.default.let { defaultFilePrefix ->
        "${ArtifactManagerFactory().mainReportsDir}${File.separator}${defaultFilePrefix}.json"
    }

    fun getJSONStatsDataOutputFile(): String =
        OutputJSONStatsDataFilePrefix.get().let { currFilePrefix ->
            val defaultFilePrefix = OutputJSONStatsDataFilePrefix.default
            check(defaultFilePrefix != null) { "For ${OutputJSONStatsDataFilePrefix}, expecting non-null default filename prefix" }
            if (currFilePrefix != defaultFilePrefix) { // if not the default prefix, use the current file prefix
                prependInternalDir("${currFilePrefix}.json")
            } else { // otherwise, use the default
                "${ArtifactManagerFactory().mainReportsDir}${File.separator}${defaultFilePrefix}.json"
            }
        }

    fun getTACSizeProfilePath(contractName: String, methodName: String) = Path(
        "${ArtifactManagerFactory().mainReportsDir}${File.separator}CodeSize.TAC.$contractName.$methodName.heapsnapshot"
    )

    fun getUnfoldedSizeProfilePath(contractName: String, methodName: String) = Path(
        "${ArtifactManagerFactory().mainReportsDir}${File.separator}CodeSize.Unfolded.$contractName.$methodName.heapsnapshot"
    )

    fun getIsUseCache(): Boolean = (CacheKeyName.get() != CacheKeyName.default) && (CacheKeyName.get() != "none")

    /** Looks like this is used for certain CI tests only. Right now, e.g., the circleCI tests `equiv_check`,
     * `local_cache_test`, `mutation_test`, `mutation_test_local`,`test_standard` set this environment variable.
     * Afaict this should never be used in non-test context. */
    fun getUseVerificationResultsForExitCode(): Boolean {
        val prop = System.getenv("DONT_USE_VERIFICATION_RESULTS_FOR_EXITCODE")
        return prop?.equals("1").let { dontuseEnabled ->
            dontuseEnabled == null || !dontuseEnabled
        }
    }


    // Log settings
    private fun isLoggerSetInEnv(loggerType: LoggerName): Boolean = System.getProperty(loggerType.toTopicProp()) != null

    fun isEnabledLogger(loggerType: LoggerName): Boolean {
        return isLoggerSetInEnv(loggerType)
    }

    fun isEnabledReport(reportName: ReportTypes) = System.getProperty(reportName.withPrefix("report")) != null

    @Suppress("HashCodeStability")
    fun isEnabledReport(reportName: String): Boolean {
        val onByDefault =
            setOf(
                ReportTypes.REPORT,
                ReportTypes.CFG,
                ReportTypes.PRESOLVER_RULE,
                ReportTypes.OPTIMIZE,
                ReportTypes.ENVFREE,
                ReportTypes.ERROR
            )/*
            Until Presimplified dumps get unf--ked this needs to be turned off I guess
             + if(DevMode.isDevMode()) {
                setOf(
                    ReportTypes.RULE,
                    ReportTypes.PRESIMPLIFIED_RULE,
                    ReportTypes.PREOPTIMIZED_RULE,
                    ReportTypes.PRELASTOPT_RULE
                )
            } else {
                setOf()
            }*/

        return ReportTypes.entries.toTypedArray().toSet()
            .find {
                reportName.lowercase().startsWith(it.toFilenamePrefix().lowercase() + OUTPUT_NAME_DELIMITER)
            }
            .let { matchingReportType ->
                when (matchingReportType) {
                    null -> {
                        logger.error("Report name $reportName doesn't match any of the known report types")
                        false
                    }

                    in onByDefault -> true
                    ReportTypes.NONE -> false
                    else -> isLoggerSetInEnv(matchingReportType.loggerCategory) || isEnabledReport(matchingReportType)
                }
            }
    }

    val TreeViewReportUpdateInterval = object : ConfigType.IntCmdLine(
        8,
        Option(
            "treeViewReportUpdateInterval",
            true,
            "Time interval in seconds determining how frequently the hotUpdate() function of " +
                "TreeViewReporter is being called. [default: 8 seconds]"
        )
    ) {}

    fun isRunningInLocalEnv(): Boolean =
        ArtifactFileUtils.hasCertoraDir()

    /**
     * Generic rules config
     */
    val CheckViewReentrancyBeforeUnresolvedCall = GenericRules.CheckViewReentrancyBeforeUnresolvedCall
    val ExhaustiveViewReentrancy = GenericRules.ExhaustiveViewReentrancy

    object GenericRules {
        val CheckViewReentrancyBeforeUnresolvedCall = object : ConfigType.BooleanCmdLine(
            false,
            Option(
                "vr_checkBeforeUnresolved", true,
                "Sample view function value before unresolved call. May lead to false negatives. If this " +
                    "value is false, the view functions value will be check after the unresolved call which may lead" +
                    "to false positives."
            )

        ) {}

        val ExhaustiveViewReentrancy = object : ConfigType.BooleanCmdLine(
            false,
            Option(
                "exhaustiveViewReentrancy",
                true,
                "Generate an assert for all view function pairs"
            )
        ) {}
    }

    val AggressiveHashDecomposition = object : ConfigType.BooleanCmdLine(
        false,
        Option(
            "aggressiveHashDecomposition",
            true,
            "Aggressively decompose hashed buffers, even those that do not appear to be the result of encodePacked"
        )
    ) {}

    val includeEmptyFallback = object : ConfigType.BooleanCmdLine(
        false,
        Option(
            "includeEmptyFallback",
            true,
            "create a Certora fallback method, even if the fallback function always reverts [default: false]"
        ),
        pythonName = "--include_empty_fallback"
    ) {}

    /**
     * Make it so that using [DestructiveOptimizationsMode] requires a special [OptIn] annotation, preventing people
     * from accidentally using this config directly instead of going through [CoreTACProgram.destructiveOptimizations].
     */
    @RequiresOptIn(
        level = RequiresOptIn.Level.ERROR,
        message = "Use CoreTACProgram.destructiveOptimizations to check whether destructive optimizations are enabled."
    )
    annotation class DestructiveOptimizationsOption

    /**
     * CallTrace config flags.
     * Note that [DestructiveOptimizationsMode] should never be checked directly, but only via the [destructiveOptimizations]
     * utility. Check the comment in [DynamicSettings.kt] and
     * https://www.notion.so/certora/1b305a84c4fa4a90b73f63e1e1c4f9d6 for more details.
     */
    @DestructiveOptimizationsOption
    val DestructiveOptimizationsMode =
        "Allow more aggressive optimizations, but disable the generation of call traces.".let { desc ->
            object : ConfigType.CmdLine<DestructiveOptimizationsModeEnum>(
                DestructiveOptimizationsModeEnum.DISABLE,
                DestructiveOptimizationsModeConverter,
                Option("destructiveOptimizations", true, desc),
                aliases = listOf(Option("calltraceFreeOpt", true, desc))
            ) {}
        }

    val noCalltraceStorageInformation: ConfigType.BooleanCmdLine = object : ConfigType.BooleanCmdLine(
        false,
        Option(
            "noCalltraceStorageInformation",
            true,
            "Avoid adding storage information to CallTrace. (default false)"
        ),
        pythonName = "--no_calltrace_storage_information"
    ), TransformationAgnosticConfig {}

    val flattenBranchesInCallTrace: ConfigType.BooleanCmdLine = object : ConfigType.BooleanCmdLine(
        true,
        Option(
            "flattenBranchesInCallTrace",
            true,
            "Don't indent branches in CallTrace. (default true)"
        )
    ), TransformationAgnosticConfig {}

    val FastCache = object : ConfigType.BooleanCmdLine(
        false,
        Option(
            "fastCache",
            true,
            "Trade-off disk space for faster caching (default false)"
        )
    ) {}

    /**
     * Solana configs.
     * The rest of options are defined in another static object called [sbf.SolanaConfig].
     */
    val SolanaEntrypoint = "The export name of the function that represents the rule to be verified.".let{ desc ->
        object : ConfigType.StringSetCmdLine(
            null,
            Option(
                "solanaEntrypoint",
                true,
                desc
            ),
            aliases = listOf(Option("rule", true, desc)),
        ) {}}


    /**
     *  Wasm configs.
     */
    val WasmEntrypoint = "The export name of the function that represents the rule to be verified.".let{ desc ->
        object : ConfigType.StringSetCmdLine(
        null,
        Option(
            "target",
            true,
            desc
        ),
        aliases = listOf(Option("rule", true, desc)),
    ) {}}

    val TrapAsAssert = object : ConfigType.BooleanCmdLine(
        false,
        Option(
            "trapAsAssert",
            true,
            "Treat traps as asserts."
        )
    ) {}

    /**
     * Temporary options. Stating the trigger for removal for each.
     */
    val TmpAllGhostsAreGlobal = object : ConfigType.BooleanCmdLine(
        false,
        Option(
            "tmpOptAllGhostsAreGlobal", // TODO CERT-4343 global ghosts
            true,
            "Return to legacy ghosts mode where they were not havoc'd along with state. " +
                "This option will deprecate once globals are introduced to CVL [default: false]"
        )
    ) {}

    val SorobanSDKSummaries = object : ConfigType.BooleanCmdLine(
        true,
        Option(
            "useSorobanSDKSummaries",
            true,
            "Apply summaries of Soroban SDK functions [default: true]"
        )
    ) {}

    val optionsForHelpMsg =
        listOf(
            MethodChoicesInput,
            IsAssumeUnwindCondForLoops,
            IgnoreViewFunctionsInParametricRules,
            Smt.UseNIA,
            Smt.UseBV,
            SolverTimeout,
            RuleChoice,
            ExcludeRuleChoice
        )
}

@PollutesGlobalState
fun main() {
    CommandLineParser.registerConfigurations()
    val dictOfConfigsWithPythonName = ConfigRegister.registeredConfigs
        .mapNotNull { (it as? ConfigType.CmdLine)?.takeIf { it.pythonName != null } }
        .associate { it.pythonName!! to it.name }
    val json = Json {
        prettyPrint = true
    }
    val str = json.encodeToString(dictOfConfigsWithPythonName)
    FileWriter("dump_configs.json").use { writer ->
        // Serialize the artifact using the provided JSON instance.
        writer.write(str)
    }
}
