/*
 *     The Certora Prover
 *     Copyright (C) 2025  Certora Ltd.
 *
 *     This program is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU General Public License as published by
 *     the Free Software Foundation, version 3 of the License.
 *
 *     This program is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU General Public License for more details.
 *
 *     You should have received a copy of the GNU General Public License
 *     along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

// CER-1384: Supressing warnings at file level to avoid churn during rewrite
@file:Suppress("UNUSED_VARIABLE")

// Note to reviewers: this file is changed to reuse the error classes for things like undefined variables.  Those error
// classes require some position information about the previous definition, so we also add some range fields to the
// [SymbolInfo], and set them at the appropriate places.
//
// Finally, I inlined some of the cases for [SymbolInfo.Companion.invoke] with the hopes of removing it entirely (it's
// awfully ugly), but I didn't finish removing it because doing the obvious thing introduced bugs that I didn't want to
// chase down.  But I left some of the inlining anyhow.

package spec.cvlast

import allocator.Allocator
import bridge.ContractInstanceInSDC
import bridge.EVMExternalMethodInfo
import datastructures.stdcollections.*
import log.Logger
import log.LoggerTypes
import spec.AutoGeneratedRuleException
import spec.CVLCastFunction
import spec.CVLKeywords
import spec.CVLReservedVariables
import spec.cvlast.CVLSymbolTable.SymbolInfo
import spec.cvlast.CVLSymbolTable.SymbolInfo.CVLFunctionInfo
import spec.cvlast.CVLSymbolTable.SymbolInfo.NonValueSymbol
import spec.cvlast.CVLSymbolTable.SymbolTableNamespace.FUNCTION_LIKE
import spec.cvlast.CVLSymbolTable.SymbolTableNamespace.NON_FUNCTION_LIKE
import spec.cvlast.typechecker.CVLError
import spec.cvlast.typechecker.DeclaredKeyword
import spec.cvlast.typechecker.DuplicateDeclaration
import spec.cvlast.typedescriptors.FromVMContext
import spec.cvlast.typedescriptors.VMTypeDescriptor
import spec.isWildcard
import utils.CollectingResult
import utils.CollectingResult.Companion.asError
import utils.CollectingResult.Companion.bind
import utils.CollectingResult.Companion.flatten
import utils.CollectingResult.Companion.flattenToVoid
import utils.CollectingResult.Companion.lift
import utils.CollectingResult.Companion.map
import utils.CollectingResult.Companion.ok
import utils.ErrorCollector.Companion.collectingErrors
import utils.VoidResult
import utils.`impossible!`

private val logger = Logger(LoggerTypes.CVL_TYPE_CHECKER)

class CVLSymbolTable(
    /** Maps scope and identifier to metadata (typically type information, but [SymbolInfo] can be enhanced when
     * needed... */
    private val backing: MutableMap<SymbolTableKey, SymbolInfo> = HashMap(),
    /** For every [ContractReference] a scope is created in which the contract's function are registered
     * Keep a mapping from [ContractReference] to the created [CVLScope].
     * This mapping is used when lookup a method where we first lookup the contract and then the method
     */
    private val contractsScope: MutableMap<String, CVLScope> = HashMap(),
    /** No register.. calls (or other changes) are allowed once this flag has been set */
    private var isFinalized: Boolean = false,
) {
    /**
     * Used to key into the [backing] of the symbol table and separate namespaces.
     * [FUNCTION_LIKE] keys anything that acts like a function in CVL
     *  - [CVLFunction]
     *  - [ContractFunction]
     *  - [CVLGhostFunction]
     *  - [CVLDefinition]
     *  - [CVLCastFunction]
     *
     *  [NON_FUNCTION_LIKE] keys all other symbols
     */
    enum class SymbolTableNamespace {
        FUNCTION_LIKE,
        NON_FUNCTION_LIKE,
        CONTRACT_IDENTIFIER_NAMESPACE
    }

    data class SymbolTableKey(val scope: CVLScope, val namespace: SymbolTableNamespace, val symbolName: String)

    /**
     * Maps each identifier of a from-user rule/invariant to the number of from-user rules/invariants that have this identifier.
     * The goal of this mapping is to detect ids' collisions that result from the cvl spec.
     * If no such collisions are detected, only then we look for collisions between ids of auto-generated rules.
     * The reason is that auto-generated rules may have ids' collisions that are induced by collisions of from-user rules' ids.
     * Once we rule out those, we report a collision between auto-generated rules as an [AutoGeneratedRuleException], rather
     * than a CVL syntax error.
     */
    private val fromUserInvariantsAndRulesIds: MutableMap<String, Int> = mutableMapOf()

    private fun reportFromUserInvOrRuleId(id: String) {
        fromUserInvariantsAndRulesIds[id] =
            fromUserInvariantsAndRulesIds.computeIfAbsent(id) { 0 } + 1
    }

    internal fun fromUserInvsRulesIdsCollide(): Boolean = fromUserInvariantsAndRulesIds.any { it.value > 1 }


    private val reserved = CVLReservedVariables.values().map { it.name }.toSet()

    private val freshNameGenerator = FreshNameGenerator()

    /**
     * Provides globally unique names during rule generation.
     */
    inner class FreshNameGenerator {
        private val generated = mutableSetOf<String>()
        private val lastUsedIndex = mutableMapOf<String, Int>()
        // allIds should not be modified once isFinalized is set, additionally, no concurrent updates to this should
        // happen while isFinalized is not set
        private var allIds: Set<String> = setOf() // initializes field
            set(value) = if (isFinalized) {
                throw IllegalStateException("Tried to modify a finalized symbol table")
            } else {
                field = value
            }
            get() = if (isFinalized) {
                field
            } else {
                computeAllIds()
            }
        fun finalize() {
            allIds = computeAllIds()
        }

        private fun inAnyScope(id: String) = allIds.contains(id)

        private fun computeAllIds() = backing.keys.map { key -> key.symbolName }.toSet()

        private fun taken(requested: String) = requested in generated || reserved.contains(requested)
                || inAnyScope(requested)

        /**
         * Many threads may concurrently ask for a unique ID, and multiple threads may be asking for a unique id for
         * the same rule. Thus, being thread local is not sufficient and this must be synchronized.
         */
        @Synchronized
        fun generate(requested: String): String {
            var result = requested
            var idx = 0
            if (taken(result)) {
                idx = lastUsedIndex[requested] ?: 0
                idx++
                result = "$requested$idx"

                while (taken(result)) {
                    idx++
                    result = "$requested$idx"
                }
            }

            generated.add(result)
            lastUsedIndex[result] = idx
            return result
        }
    }

    fun getAllStructTypes() = backing.entries.mapNotNull { (key, info) ->
        key.scope.enclosingContract()
            ?.let { contractsScope ->
                ((info.symbolValue as? ContractTypeDefinition)?.type as? CVLType.PureCVLType.Struct)?.let { structType ->
                    contractsScope.contract to structType
                }
            }
    }


    private fun checkName(name: CallableName, cvlRange: CVLRange): VoidResult<CVLError> = checkName(name.methodId, cvlRange)

    private fun checkName(name: String, cvlRange: CVLRange): VoidResult<CVLError> {
        val nameIsKeyword = CVLKeywords.find(name)
        if (CVLKeywords.values().any { kw -> kw != CVLKeywords.wildCardExp && name == kw.name }) {
            return DeclaredKeyword(name, cvlRange).asError()
        }

        val nameIsCVLType = CVLType.valueFromString(name)
        if (nameIsCVLType != null) {
            return CVLError.General(
                cvlRange,
                "Trying to declare an identifier with a type name: $name. Please use another name",
            ).asError()
        }

        val nameIsReserved =
            name in (reserved).minus(CVLReservedVariables.certorafallback_0.name) // allowed to use certorafallback_0 due to invoke_fallback. TODO improve
        if (nameIsReserved) {
            return DeclaredKeyword(name, cvlRange).asError()
        }

        val startingWithReservedPrefix = name.startsWith(CVLReservedVariables.prefix)
        if (startingWithReservedPrefix) {
            return CVLError.General(
                cvlRange,
                "Trying to declare an identifier with a reserved prefix: $name. Please use another name",
            ).asError()
        }
        return ok
    }

    fun lookUpFunctionLikeSymbol(id: String, typeEnv: CVLTypeEnvironment): SymbolInfo? =
        lookUp(id, FUNCTION_LIKE, typeEnv)

    fun lookUpNonFunctionLikeSymbol(id: String, typeEnv: CVLTypeEnvironment): SymbolInfo? =
        lookUp(id, NON_FUNCTION_LIKE, typeEnv)

    fun lookUpFunctionLikeSymbol(id: String, scope: CVLScope): SymbolInfo? =
        lookUp(id, FUNCTION_LIKE, scope)

    fun lookUpNonFunctionLikeSymbol(id: String, scope: CVLScope): SymbolInfo? =
        lookUp(id, NON_FUNCTION_LIKE, scope)

    fun lookUpContractIdentifierNamespaceSymbol(id: String, scope: CVLScope): SymbolInfo? =
        lookUp(id, SymbolTableNamespace.CONTRACT_IDENTIFIER_NAMESPACE, scope)

    fun lookUp(id: String, namespace: SymbolTableNamespace, typeEnv: CVLTypeEnvironment): SymbolInfo? {
        logger.info { "Looking up $id in typeenv $typeEnv" }
        /* first, look into type environment */
        val typeFromEnv = typeEnv.lookUp(id)
        if (typeFromEnv != null) {
            return typeFromEnv
        }
        return lookUp(id, namespace, typeEnv.scope)
    }


    fun lookUp(id: String, namespace: SymbolTableNamespace, scope: CVLScope): SymbolInfo? {
        var currentInnerScope: CVLScope? = scope
        while (currentInnerScope != null) {
            logger.info {
                "Looking for $id. All IDs in the scope $currentInnerScope: ${
                    backing.keys.filter { it.scope == currentInnerScope }
                        .map { it.symbolName }
                }"
            }
//            logger.info("Symbol with id $id may appear in other scopes: ${backing.keys.filter { it.second == id }.map { it.first } }")
            val symbolInfo = backing[SymbolTableKey(currentInnerScope, namespace, id)]
            if (symbolInfo != null) {
                return symbolInfo
            }
            currentInnerScope = currentInnerScope.innerScope
        }
        return null
    }

    @Suppress("unused")
    fun freshVar(requested: CVLExp.VariableExp) =
        if (requested.isWildCard()) {
            requested
        } else {
            requested.copy(id = freshNameGenerator.generate(requested.id))
        }

    fun freshParam(requested: CVLParam) =
        if (requested.id.isWildcard()) {
            requested
        } else {
            requested.copy(id = "${requested.id}${Allocator.getFreshNumber()}")
        }

    fun freshQuantifierSym(requested: CVLExp.QuantifierExp) =
        requested.copy(param = freshParam(requested.param))

    fun freshName(requested: String): String = freshNameGenerator.generate(requested)

    private fun lookUpWithMethodIdWithCallContext(methodIdWithCallContext: ResolvedCallableName, lookup: (methodId: String) -> SymbolInfo?) =
        when (val context = methodIdWithCallContext.host) {
            is CvlSpecFile -> lookup(methodIdWithCallContext.methodId)
            is SolidityContract -> lookupMethodInContractEnv(
                context,
                methodIdWithCallContext.methodId,
            )?.let {
                if(it is CVLFunctionInfo && methodIdWithCallContext is ConcreteMethod) {
                    val unique = it.impFuncs.singleOrNull {
                        (it as? ContractFunction)?.methodSignature?.matchesContractAndParams(methodIdWithCallContext.signature) == true
                    } ?: return@let null
                    CVLFunctionInfo(
                        impFuncs = listOf(unique),
                        symbolValue = unique,
                        isTwoState = false
                    )
                } else {
                    it
                }
            }

            CvlBuiltIn,
            AllContracts,
            CurrentContract -> `impossible!`
        }

    fun lookUpWithMethodIdWithCallContext(
        methodIdWithCallContext: ResolvedCallableName,
        scope: CVLScope
    ): SymbolInfo? = lookUpWithMethodIdWithCallContext(methodIdWithCallContext) { host ->
        lookUp(host, FUNCTION_LIKE, scope)
    }

    fun lookUpWithMethodIdWithCallContext(
        methodIdWithCallContext: ResolvedCallableName,
        typeEnv: CVLTypeEnvironment
    ): SymbolInfo? = lookUpWithMethodIdWithCallContext(methodIdWithCallContext) { host ->
        lookUp(host, FUNCTION_LIKE, typeEnv)
    }

    /**
     * Return the [SymbolInfo] of a function with contractId.methodId
     * ContractId must be a symbolic reference to a contract therefore need to
     * first lookup the contractId, then lookup the method in the right contract
     */
    @Suppress("unused")
    fun lookUpMethodWithContractID(
        contractId: String,
        methodId: String,
        scope: CVLScope
    ): SymbolInfo? {
        return lookupMethodInContractEnv(lookUpContractIdentifierNamespaceSymbol(contractId, scope), methodId)
    }

    private fun lookupMethodInContractEnv(
        contractSym: SymbolInfo?,
        methodId: String,
    ): SymbolInfo? {
        return (contractSym?.symbolValue as? CVLImportedContract)?.solidityContractName?.let {
            lookupMethodInContractEnv(
                it, methodId
            )
        }
    }

    fun lookupMethodInContractEnv(
        contractSym: ContractReference?,
        methodId: String
    ): SymbolInfo? {
        if(contractSym != null) {
            val scope = getContractScope(contractSym)
            if (scope != null) {
                return lookUpFunctionLikeSymbol(methodId, scope)
            }
        }
        return null
    }

    private fun verifyUniqueFunctionLikeKey(scope: CVLScope, id: String, objectString: String, cvlRange: CVLRange): VoidResult<CVLError> {
        val symbolTableKey = SymbolTableKey(scope, FUNCTION_LIKE, id)
        val currentContractScope = getContractScope(CurrentContract)!!
        val currentContractKey = SymbolTableKey(getContractScope(CurrentContract)!!, FUNCTION_LIKE, id)
        return if (backing.containsKey(symbolTableKey) || backing.containsKey(currentContractKey)) {
            // currently an important assumption for summary inlining
            CVLError.General(
                cvlRange,
                "The identifier $id has already been declared in scope $scope. Overloading not allowed for $objectString"
            ).asError()
        } else {
            ok
        }
    }
    fun register(sortDecl: SortDeclaration, scope: CVLScope): VoidResult<CVLError> {
        logger.info { "For decl sort ${sortDecl.sort.name}, registering in $scope" }
        checkNotFinalized()
        return checkName(sortDecl.sort.name, sortDecl.cvlRange).bind {
            registerSymbol(
                sortDecl.sort.name, SymbolInfo(sortDecl, sortDecl.cvlRange),
                NON_FUNCTION_LIKE, scope, sortDecl.cvlRange
            )
        }
    }

    fun register(typeDefinition: ContractTypeDefinition, scope: CVLScope): VoidResult<CVLError> {
        logger.info { "For type definition ${typeDefinition.name}, registering in $scope" }
        checkNotFinalized()
        return registerSymbol(
            typeDefinition.name, SymbolInfo(typeDefinition, CVLRange.Empty()),
            NON_FUNCTION_LIKE, scope, CVLRange.Empty()
        )
    }

    fun register(contract: ContractReference, slot: String, storage: VMTypeDescriptor) : VoidResult<CVLError> {
        logger.info {
            "In ${contract.name}, registering root slot $slot has type $storage"
        }
        checkNotFinalized()
        val symbolTableKey = SymbolTableKey(getContractScope(contract)!!, NON_FUNCTION_LIKE, slot)
        if(symbolTableKey in backing) {
            return CVLError.General(
                message = "Already registered slot with name $slot in contract $contract",
                cvlRange = CVLRange.Empty()
            ).asError()
        }
        backing[symbolTableKey] = SymbolInfo.ContractStorageType(storage)
        return ok
    }

    fun registerImmutable(contract: ContractReference, immutableName: String, type: VMTypeDescriptor) : VoidResult<CVLError> {
        logger.info {
            "In ${contract.name}, registering immutable $immutableName with type $type"
        }
        checkNotFinalized()
        val symbolTableKey = SymbolTableKey(getContractScope(contract)!!, NON_FUNCTION_LIKE, immutableName)
        if(symbolTableKey in backing) {
            return CVLError.General(
                message = "Already registered a symbol with the name $immutableName in contract $contract, tried to register as an immutable now",
                cvlRange = CVLRange.Empty()
            ).asError()
        }
        backing[symbolTableKey] = SymbolInfo.ContractImmutableType(type)
        return ok
    }

    fun register(inv: CVLInvariant, scope: CVLScope) : VoidResult<CVLError> {
        logger.info { "For invariant ${inv.id}, registering in $scope" }
        checkNotFinalized()

        reportFromUserInvOrRuleId(inv.id)

        return checkName(inv.id, CVLRange.Empty()).bind {
            // we could have chosen to register this in the [FUNCTION_LIKE] namespace since it can be referred to
            // in a requireInvariant which syntactically looks "function-like". We chose to register it in the
            // NON_FUNCTION_LIKE table for consistency with rules
            val symbolTableKey = SymbolTableKey(scope, NON_FUNCTION_LIKE, inv.id)
            if (backing.containsKey(symbolTableKey)) {
                CVLError.General(
                    inv.cvlRange, "identifier ${inv.id} has already been declared in scope $scope"
                ).asError()
            } else {
                symbolTableKey.lift()
            }
        }.map { symbolTableKey ->
            backing[symbolTableKey] = NonValueSymbol(inv, inv.cvlRange)
        }
    }

    fun register(sub: CVLFunction, scope: CVLScope): VoidResult<CVLError> {
        logger.info { "For decl of $sub, registering in $scope" }
        checkNotFinalized()
        return checkName(sub.functionIdentifier, CVLRange.Empty()).bind {
            // currently an important assumption for summary inlining
            verifyUniqueFunctionLikeKey(scope, sub.functionIdentifier.methodId, "functions", sub.cvlRange)
        }.bind {
            registerFunction(sub, scope)
        }
    }


    fun register(ghost: CVLGhostDeclaration, scope: CVLScope): VoidResult<CVLError> {
        return when (ghost) {
            is CVLGhostDeclaration.Function -> {
                logger.info { "For decl of ghost function $ghost, registering in $scope" }
                checkNotFinalized()
                return checkName(ghost.functionReference, CVLRange.Empty()).bind {
                    verifyUniqueFunctionLikeKey(
                        scope,
                        ghost.functionReference.methodId,
                        "ghost functions",
                        ghost.cvlRange
                    )
                }.bind {
                    registerFunction(ghost, scope)
                }
            }
            is CVLGhostDeclaration.Variable,
            is CVLGhostDeclaration.Sum -> {
                logger.info { "For decl of ghost ${if (ghost is CVLGhostDeclaration.Variable) { "variable" }  else { "sum" } } ${ghost.id}, registering in $scope" }
                checkNotFinalized()
                checkName(ghost.id, CVLRange.Empty()).bind {
                    val symbolTableKey = SymbolTableKey(scope, NON_FUNCTION_LIKE, ghost.id)
                    if (backing.containsKey(symbolTableKey)) {
                        CVLError.General(
                            ghost.cvlRange,
                            "Some symbol with name ${ghost.id} has already been declared in " + "scope $scope.",
                        ).asError()
                    } else {
                        registerSymbol(
                            ghost.id,
                            SymbolInfo(ghost, ghost.cvlRange, false),
                            NON_FUNCTION_LIKE,
                            scope,
                            ghost.cvlRange,
                        )
                    }
                }
            }
        }
    }

    fun register(
        rule: IRule,
        scope: CVLScope,
        registerFromUserRules: Boolean,
        suppressAutoGenRuleExceptions: Boolean
    ): VoidResult<CVLError> {
        logger.info { "Registering rule $rule" }
        checkNotFinalized()
        val symbolTableKey = SymbolTableKey(scope, NON_FUNCTION_LIKE, rule.declarationId)
        val ruleIsFromUser = rule.ruleType.isFromUser()
        if (ruleIsFromUser && registerFromUserRules) {
            reportFromUserInvOrRuleId(rule.declarationId)
            return checkName(rule.declarationId, CVLRange.Empty()).bind {
                val loc = when (rule) {
                    is CVLSingleRule -> {
                        rule.cvlRange
                    }

                    is AssertRule, is GroupRule, is StaticRule -> {
                        throw IllegalStateException(
                            "Expected SingleRuleWithCode, but got a from-user rule of a different type ($rule)"
                        )
                    }
                }
                if (backing.containsKey(symbolTableKey)) { // We assume here that, at this point, there are no auto-generated rules' ids in [backing]
                    CVLError.General(
                        loc, "Identifier ${rule.declarationId} has already been declared in scope $scope"
                    ).asError()
                } else {
                    backing[symbolTableKey] = NonValueSymbol(rule, rule.cvlRange)
                    ok
                }
            }
        } else if (!ruleIsFromUser && !registerFromUserRules) { // [rule] is auto-generated
            if (backing.containsKey(symbolTableKey)) {
                val existingSymbolHook = backing[symbolTableKey]!!.symbolValue
                if (existingSymbolHook is IRule && !existingSymbolHook.ruleType.isFromUser()) {
                    // Collision between two auto-generated rules :(((
                    if (!suppressAutoGenRuleExceptions) {
                        AutoGeneratedRuleException.autoGenRuleIdError(
                            "The identifier ${rule.declarationId} belongs to two distinct auto-generated rules " +
                                    "in scope $scope"
                        )
                    }
                } else if (existingSymbolHook is CVLSingleRule && existingSymbolHook.ruleType.isFromUser() &&
                    rule.ruleType is SpecType.Group &&
                    rule.ruleType.getOriginatingRule()?.declarationId == existingSymbolHook.declarationId &&
                    rule.ruleType.getOriginatingRule()?.cvlRange == existingSymbolHook.cvlRange
                ) {
                    /**
                     * We have a "pseudo-collision" between the auto-generated, Group [rule] and the from-user rule
                     * existingSymbolHook that lead to the generation of [rule].
                     * That is, existingSymbolHook has been reduced to [rule].
                     */
                } else if (existingSymbolHook is CVLInvariant && rule.ruleType is SpecType.Group.InvariantCheck &&
                    (rule.ruleType as SpecType.Group.InvariantCheck).originalInv.id == existingSymbolHook.id
                ) {
                    /*
                    * We have a "pseudo-collision" between the auto-generated, Group, invariant-check [rule], and
                    * the invariant existingSymbolHook that lead to the generation of [rule].
                    *
                    * */
                } else { // Some user-defined element collides with an auto-generated rule: treat this as a syntax error
                    val loc = when (existingSymbolHook) {
                        is HasRange -> {
                            existingSymbolHook.cvlRange
                        }
                        else -> CVLRange.Empty()
                    }
                    return CVLError.General(
                        loc,
                        "The identifier ${rule.declarationId} has been reserved in scope $scope " +
                                "for ${
                                    if (rule.ruleType.getOriginatingInvariant() != null) {
                                        val origInv = rule.ruleType.getOriginatingInvariant()!!
                                        "checking ${origInv.id} (${origInv.cvlRange})"
                                    } else if (rule.ruleType.getOriginatingRule() != null) {
                                        val origRule = rule.ruleType.getOriginatingRule()!!
                                        "checking ${origRule.declarationId} (${origRule.cvlRange})"
                                    } else if (rule.ruleType is SpecType.Single.BuiltIn) {
                                        "an imported builtin rule"
                                    } else {
                                        null
                                    }
                                        ?: "an auto-generated rule"
                                }. Please use another name"
                    ).asError()
                }
            } else {
                backing[symbolTableKey] = NonValueSymbol(rule, rule.cvlRange)
            }
        }
        return ok
    }

    fun register(definition: CVLDefinition, scope: CVLScope): VoidResult<CVLError> {
        logger.info { "For definition $definition, registering in $scope" }
        checkNotFinalized()
        return checkName(definition.id, CVLRange.Empty()).bind {
            verifyUniqueFunctionLikeKey(scope, definition.id, "definitions", definition.cvlRange)
        }.bind {
            registerFunction(definition, scope)
        }
    }

    /**
     * Registers identifiers that may include parametric method identifiers: these must be registered in both the
     * function-like symbol table (for when they are invoked) as well as in the non function-like symbol table
     * for instances when they are used as structs
     */
    private fun registerLocalVariableSymbol(
        id: String,
        type: CVLType,
        symbol: SymbolInfo,
        scope: CVLScope,
        cvlRange: CVLRange,
        autoGeneratedScope: Boolean = false,
        suppressAutoGenRuleExceptions: Boolean = false
    ): VoidResult<CVLError> =
        if (type == EVMBuiltinTypes.method) {
                registerSymbol(
                    id, symbol, FUNCTION_LIKE, scope,
                    cvlRange, autoGeneratedScope, suppressAutoGenRuleExceptions
                ).map(registerSymbol(
                    id, symbol, NON_FUNCTION_LIKE, scope,
                    cvlRange, autoGeneratedScope, suppressAutoGenRuleExceptions
                ))
        } else {
            registerSymbol(
                id,
                symbol,
                NON_FUNCTION_LIKE,
                scope,
                cvlRange,
                autoGeneratedScope,
                suppressAutoGenRuleExceptions
            )
        }

    /**
     * @param autoGeneratedScope whether [scope] is a scope of an auto-generated rule (rather than a from-user rule)
     *  Returns true if the registration has been done without an identifier collision in [scope].
     */
    fun register(
        cmd: CVLCmd.Simple.Declaration,
        scope: CVLScope,
        autoGeneratedScope: Boolean = false,
        suppressAutoGenRuleExceptions: Boolean = false
    ): VoidResult<CVLError> {
        logger.info { "For decl $cmd, registering" }
        checkNotFinalized()
        return checkName(cmd.id, cmd.cvlRange).bind {
            registerLocalVariableSymbol(
                cmd.id,
                cmd.cvlType,
                SymbolInfo(cmd, cmd.cvlRange),
                scope,
                cmd.cvlRange,
                autoGeneratedScope,
                suppressAutoGenRuleExceptions
            )
        }
    }

    /**
     * @param autoGeneratedScope whether [scope] is a scope of an auto-generated rule (rather than a from-user rule)
     * Returns true if the registration has been done without an identifier collision in [scope].
     */
    fun register(
        cmd: CVLCmd.Simple.Definition, scope: CVLScope, autoGeneratedScope: Boolean = false,
        suppressAutoGenRuleExceptions: Boolean = false
    ): VoidResult<CVLError> {
        logger.info { "For def $cmd, registering in $scope" }
        checkNotFinalized()
        return cmd.idL.map { checkName(it.getIdLhs().id, cmd.cvlRange) }.flatten().bind {
            if (cmd.type == null) {
                // cmd is a regular assignment rather than a declaration with an initialization --> do nothing
                ok
            } else {
                cmd.idL.map { lhs ->
                    registerLocalVariableSymbol(
                        lhs.getIdLhs().id,
                        cmd.type,
                        SymbolInfo(cmd, cmd.cvlRange),
                        scope,
                        cmd.cvlRange,
                        autoGeneratedScope,
                        suppressAutoGenRuleExceptions
                    )
                }.flattenToVoid()
            }
        }
    }

    private fun registerSymbol(
        id: String,
        symbol: SymbolInfo,
        namespace: SymbolTableNamespace,
        scope: CVLScope,
        cvlRange: CVLRange,
        autoGeneratedScope: Boolean = false,
        suppressAutoGenRuleExceptions: Boolean = false
    ): VoidResult<CVLError> = collectingErrors {
        val key = SymbolTableKey(scope, namespace, id)
        backing[key]?.let {
            val error = DuplicateDeclaration(id, cvlRange, it.declaration)
            if (autoGeneratedScope && !suppressAutoGenRuleExceptions) {
                // throw an exception
                AutoGeneratedRuleException.idCollisionInAutoGenScope(error.message)
            }
            if (autoGeneratedScope) {
                // error should be present in the original rule as well; don't report it again
                return@let
            }
            returnError(error)
        }
        logger.info { "Registered in $scope, $id: $symbol" }
        backing[key] = symbol
    }

    fun registerParam(
        param: VMParam.Named,
        context: FromVMContext,
        scope: CVLScope,
        cvlRange: CVLRange,
        autoGeneratedScope: Boolean = false,
        suppressAutoGenRuleExceptions: Boolean = false
    ) : VoidResult<CVLError> {
        if (param.id.isWildcard()) {
            // Wildcard params shouldn't get registered
            return ok
        }

        val nameChecked = if (!autoGeneratedScope) {
            checkName(param.id, cvlRange)
        } else {
            ok
        }
        return nameChecked.bind {
            val type = CVLType.VM(param.type, context)
            val paramVariable: CVLExp.VariableExp = CVLExp.VariableExp(param.name, CVLExpTag(scope, type, cvlRange))
            registerLocalVariableSymbol(
                param.name,
                type,
                SymbolInfo(paramVariable, cvlRange),
                scope,
                cvlRange,
                autoGeneratedScope,
                suppressAutoGenRuleExceptions
            )
        }

    }


    /**
     * @param autoGeneratedScope whether [scope] is a scope of an auto-generated rule (rather than a from-user rule)
     *
     * Returns true if the registration of [param] has been done without an identifier collision in [scope]
     */
    fun registerParam(
        param: CVLParam,
        scope: CVLScope,
        cvlRange: CVLRange,
        autoGeneratedScope: Boolean = false,
        suppressAutoGenRuleExceptions: Boolean = false
    ) : VoidResult<CVLError> {
        checkNotFinalized()
        if (param.id.isWildcard()) {
            // Wildcard params shouldn't get registered
            return ok
        }

        val nameChecked = if (!autoGeneratedScope) {
            checkName(param.id, cvlRange)
        } else {
            ok
        }

        return nameChecked.bind {
            if (param.type == EVMBuiltinTypes.method) {
                registerSymbol(
                    param.id,
                    SymbolInfo(param, cvlRange),
                    FUNCTION_LIKE,
                    scope,
                    cvlRange,
                    autoGeneratedScope,
                    suppressAutoGenRuleExceptions
                ).map(
                    registerSymbol(
                        param.id,
                        SymbolInfo(param, cvlRange),
                        NON_FUNCTION_LIKE,
                        scope,
                        cvlRange,
                        autoGeneratedScope,
                        suppressAutoGenRuleExceptions
                    )
                )
            } else {
                registerSymbol(
                    param.id,
                    SymbolInfo(param, cvlRange),
                    NON_FUNCTION_LIKE,
                    scope,
                    cvlRange,
                    autoGeneratedScope,
                    suppressAutoGenRuleExceptions
                )
            }
        }
    }


    /**
     * TODO Nicer would be for CVL keywords to have their own class
     */
    fun registerCVLKeyword(keyword: CVLKeywords, scope: CVLScope): VoidResult<CVLError> {
        checkNotFinalized()
        return registerSymbol(
            keyword.keyword,
            SymbolInfo(keyword, CVLRange.Empty()),
            NON_FUNCTION_LIKE,
            scope,
            CVLRange.Empty()
        )
    }

    private fun <T, U> registerFunction(function: Function<T, U>, scope: CVLScope): CollectingResult<Unit, CVLError> {
        val symbolTableKey =
            SymbolTableKey(scope, FUNCTION_LIKE, function.functionIdentifier.methodId)

        /** register the method itself */
        val stEntry = backing[symbolTableKey]
        return if (stEntry == null) {
            // create a new st entry, as usual
            backing[symbolTableKey] = CVLFunctionInfo(function, listOf(function))
            ok
        } else if (function is ContractFunction) {
            // seems we have an overloaded function -- register the overloading
            stEntry as CVLFunctionInfo
            return stEntry.registerOverloading(function).map { functionInfo ->
                backing[symbolTableKey] = functionInfo
            }
        } else {
            ok
        }
    }

    /**
     * Question: do functions have their own namespace?? -- currently they don't..
     */
    fun register(importedFunction: ContractFunction, scope: CVLScope): VoidResult<CVLError> {
        checkNotFinalized()
        return checkName(importedFunction.functionIdentifier, CVLRange.Empty()).bind {
            registerFunction(importedFunction, scope)
        }
    }

    fun register(importedContract: CVLImportedContract, scope: CVLScope): VoidResult<CVLError> {
        checkNotFinalized()
        val symbolTableKey =
            SymbolTableKey(
                scope,
                NON_FUNCTION_LIKE,
                importedContract.solidityContractVarId
            )
        return checkName(importedContract.solidityContractVarId, CVLRange.Empty()).map {
            backing[symbolTableKey] = SymbolInfo(importedContract, importedContract.cvlRange)
        }
    }

    fun registerContract(contractName: ContractInstanceInSDC, scope: CVLScope): VoidResult<CVLError> {
        checkNotFinalized()
        val symbolTableKey =
            SymbolTableKey(
                scope,
                SymbolTableNamespace.CONTRACT_IDENTIFIER_NAMESPACE,
                contractName.name
            )
        return checkName(contractName.name, CVLRange.Empty()).map {
            backing[symbolTableKey] = SymbolInfo(
                CVLContractNamespace(
                    contractName.name,
                    SolidityContract(contractName.name),
                    contractName.address,
                    CVLRange.Empty()
                ), CVLRange.Empty()
            )
        }
    }

    private fun checkNotFinalized() {
        if (isFinalized) {
            throw AssertionError("Attempt to update symbol table when it has been finalized already")
        }
    }

    fun finalize() {
        freshNameGenerator.finalize()
        isFinalized = true
    }


    fun addContractScope(contractName: ContractReference, scope: CVLScope): VoidResult<CVLError> {
        if (contractsScope.containsKey(contractName.name)) {
            return CVLError.General(
                CVLRange.Empty(), "Contract name $contractName already has an entry in scope $scope"
            ).asError()
        }

        contractsScope[contractName.name] = scope
        return ok
    }

    fun getContractScope(contractName: ContractReference): CVLScope? {
        return contractsScope[contractName.name]
    }

    fun getAllContractScopes(): List<CVLScope> {
        return contractsScope.values.toList()
    }

    fun getAllContracts(): List<ContractInstanceInSDC> = getAllContractScopes().map { it.enclosingContract()!!.contract }

    fun getContractNameFromContractId(contractId: ContractReference): SolidityContract? {
        return getContractScope(contractId)?.enclosingContract()?.contract?.name?.let(::SolidityContract)
    }

    fun getAllContractAliases(): Set<String> {
        return backing.filter { it.key.namespace == NON_FUNCTION_LIKE && it.value.symbolValue is CVLImportedContract }.map {
            (it.value.symbolValue as CVLImportedContract).alias
        }.toSet()
    }

    sealed class SymbolInfo {
        abstract val symbolValue: Any
        abstract val isTwoState: Boolean

        // TODO CERT-3553: This information probably duplicates the information in [symbolValue], but the (lack of)
        //                 typing makes it very difficult to extract.
        abstract val declaration : CVLRange

        abstract fun getCVLTypeOrNull(): CVLType?

        sealed class WithCVLType : SymbolInfo() {
            abstract fun getCVLType(): CVLType
            override fun getCVLTypeOrNull(): CVLType? = getCVLType()
        }

        data class CVLValueInfo(override val symbolValue: Any, override val declaration: CVLRange, override val isTwoState: Boolean = false) : WithCVLType() {
            override fun getCVLType(): CVLType = when (symbolValue) {
                is CVLParam -> symbolValue.type
                is CVLCmd.Simple.Declaration -> symbolValue.cvlType
                is CVLCmd.Simple.Definition -> symbolValue.type
                    ?: throw AssertionError(
                        "should not have registered a definition that does not " +
                                "declare anything in the symbol table "
                    )
                is SortDeclaration -> symbolValue.sort
                is CVLGhostDeclaration.Function -> throw CVLTODO("this should be in CVLFunctionInfo I think, so dead code here pretty sure") // hook.type
                is ContractTypeDefinition -> symbolValue.type
                is CVLKeywords -> symbolValue.type
                is CVLExp.VariableExp -> symbolValue.getCVLType() // quantified var (see CVLTypeEnv)
                is CVLImportedContract -> CVLType.PureCVLType.Primitive.CodeContract(symbolValue.solidityContractName) //a contract is an address
                is CVLGhostDeclaration.Variable -> symbolValue.type
                else -> throw UnsupportedOperationException("missing case? ($symbolValue)")
            }
        }

        /**
         * @property symbolValue the name of the function
         */
        data class CVLFunctionInfo(
            override val symbolValue: Function<*, *>,
            val impFuncs: List<Function<*, *>>,
            override val isTwoState: Boolean = false
        ) : SymbolInfo() {
            override val declaration: CVLRange = when(symbolValue) {
                    is CVLFunction -> symbolValue.cvlRange
                    is CVLGhostDeclaration.Function -> symbolValue.cvlRange
                    is CVLDefinition -> symbolValue.cvlRange
                    is ContractFunction -> CVLRange.Empty()
                }

            override fun getCVLTypeOrNull(): CVLType? = if (symbolValue is CVLGhostDeclaration.Function) {
                CVLType.PureCVLType.Ghost.Function(symbolValue.paramTypes, symbolValue.ret)
            } else {
                null
            }

            /** returns a copy of this [CVLFunctionInfo] where the additional overloading was registered */
            fun <T> registerOverloading(impFunc: Function<T, *>): CollectingResult<CVLFunctionInfo, CVLError> =
                if (impFunc in impFuncs) {
                    // impFunc already registered --> return [this] (current symbol table) unchanged
                    this.lift()
                } else if(impFunc is ContractFunction) {
                    val potentialCopyIdx = impFuncs.indexOfFirst { impFunc.methodSignature.matchesContractAndParams((it as ContractFunction).methodSignature) }
                    val potentialCopy = potentialCopyIdx.takeIf { it != -1 }?.let(impFuncs::get)
                    if (potentialCopyIdx == -1) {
                        // no version of impFunc exists: register it
                        // TODO: it seems to happen that we add the same function overloading several times only with flipped envfree --> investigate...
                        CVLFunctionInfo(symbolValue, impFuncs + listOf(impFunc), isTwoState).lift()
                    } else {
                        check(potentialCopy is ContractFunction)
                        // some version of impFunc already exists [potentialCopy], merge some properties
                        // only allow this overloading if both functions are imported functions
                        /* TODO(jtoman): I do not think this merging use case is compelling: we do all our merging elsewhere */
                        CVLFunctionInfo(
                            symbolValue,
                            impFuncs.mapIndexedNotNull { idx, function ->
                                if (idx == potentialCopyIdx) {
                                    null
                                } else {
                                    function as ContractFunction
                                }
                            } + potentialCopy.copy(
                                definitelyNonPayable = potentialCopy.definitelyNonPayable || impFunc.definitelyNonPayable,
                                annotation = MethodQualifiers(
                                    envFree = potentialCopy.annotation.envFree || impFunc.annotation.envFree,
                                    library = potentialCopy.annotation.library,
                                    visibility = potentialCopy.annotation.visibility,
                                    virtual = potentialCopy.annotation.virtual
                                )
                            ),
                            isTwoState
                        ).lift()
                    }
                } else {
                    // Overloading of non-ContractFunctions disallowed
                    CVLError.General(
                        CVLRange.Empty(),
                        "Tried to register two ambiguous function types $impFunc and ${impFuncs.first()}"
                    ).asError()
                }
        }

        /** used for storing the value of [CVLExp.Constant.SignatureLiteralExp]
         * TODO: maybe this could be merged with/purpose could be fulfilled by [CVLFunctionInfo]
         * */
        data class CVLFunctionIdentifierInfo(val evmExternalMethodInfo: EVMExternalMethodInfo, override val declaration: CVLRange) : WithCVLType() {
            override val symbolValue: Any
                get() = evmExternalMethodInfo
            override val isTwoState: Boolean
                get() = false

            override fun getCVLType(): CVLType = EVMBuiltinTypes.method // TODO(jtoman): we went from struct literal to type, why?
        }

        data class NonValueSymbol(override val symbolValue: Any, override val declaration: CVLRange) : SymbolInfo() {
            override val isTwoState: Boolean
                get() = false

            override fun getCVLTypeOrNull(): CVLType? = null
        }

        data class ContractStorageType(val storageType: VMTypeDescriptor) : SymbolInfo() {
            override val declaration = CVLRange.Empty()

            override val symbolValue: Any
                get() = storageType

            override val isTwoState: Boolean
                get() = false
            override fun getCVLTypeOrNull(): CVLType? = null
        }

        data class ContractImmutableType(val immutableType: VMTypeDescriptor) : SymbolInfo() {
            override val declaration = CVLRange.Empty()

            override val symbolValue: Any
                get() = immutableType

            override val isTwoState: Boolean
                get() = false
            override fun getCVLTypeOrNull(): CVLType? = null
        }

        companion object {
            operator fun invoke(hook: Any, declaration: CVLRange, isTwoState: Boolean = false): SymbolInfo =
                when (hook) {
                    is Function<*, *> -> CVLFunctionInfo(hook, listOf(hook), isTwoState)
                    is EVMExternalMethodInfo -> CVLFunctionIdentifierInfo(hook, declaration)
                    is IRule, is CVLInvariant -> NonValueSymbol(hook, declaration)
                    else -> CVLValueInfo(hook, declaration, isTwoState)
                }
        }
    }
}
