/*
 *     The Certora Prover
 *     Copyright (C) 2025  Certora Ltd.
 *
 *     This program is free software: you can redistribute it and/or modify
 *     it under the terms of the GNU General Public License as published by
 *     the Free Software Foundation, version 3 of the License.
 *
 *     This program is distributed in the hope that it will be useful,
 *     but WITHOUT ANY WARRANTY; without even the implied warranty of
 *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *     GNU General Public License for more details.
 *
 *     You should have received a copy of the GNU General Public License
 *     along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */

package spec.cvlast

import bridge.ContractInstanceInSDC
import bridge.types.SolidityTypeDescription
import datastructures.stdcollections.*
import log.Logger
import log.LoggerTypes
import spec.CVLKeywords
import spec.CVLWarningLogger
import spec.cvlast.typechecker.CVLError
import spec.cvlast.typedescriptors.FromVMContext
import utils.CollectingResult
import utils.CollectingResult.Companion.bind
import utils.CollectingResult.Companion.flattenToVoid
import utils.CollectingResult.Companion.map
import utils.CollectingResult.Companion.ok
import utils.ErrorCollector.Companion.collectingErrors
import utils.VoidResult
import utils.mapToSet

private val logger = Logger(LoggerTypes.CVL_TYPE_CHECKER)

/**
 * Traverses the AST (only down to commands), fills the symbol table, annotates commands' locations with [CVLScope]s.
 *
 *
 * @param contractToItsFunctionsFromSpecAndContract map from a contract to its functions; a function declaration can
 *   come from the contract (Solidity) or from the methods block in our spec (CVL/Specify)
 */
class SymbolTableFiller(
    private val symbolTable: CVLSymbolTable,
    private val ast: CVLAst,
    private val contractToItsFunctionsFromSpecAndContract: Map<ContractInstanceInSDC, List<ContractFunction>>,
    private val primaryContract: String,
    private val contractsNames: List<ContractInstanceInSDC>,
) {
    fun traverseAst(): VoidResult<CVLError> {

        /** traverse rules,
         * - visit all declarations and fill the symbol table accordingly
         * Does not touch the input AST, but creates a new one.
         */

        //register methods of contracts used in spec file - current contract and imported contracts
        val contractsToRegister = contractToItsFunctionsFromSpecAndContract
        val registrationResults = mutableListOf<VoidResult<CVLError>>()

        registrationResults.add(registerIdentifiersDeclaredOutsideOfCVLSpec(contractsToRegister))

        //register available contracts in a new namespace(contractIdentifierNameSpace)
        contractsNames.mapTo(registrationResults) { contractName ->
            symbolTable.registerContract(
                contractName, ast.scope
            )
        }

        // add to symbol table contract variables
        ast.importedContracts.mapTo(registrationResults) { importedContract ->
            symbolTable.register(importedContract, ast.scope)
        }

        // We need to register "currentContract" as well
        registrationResults.add(
            symbolTable.register(
                CVLImportedContract(CVLKeywords.CURRENT_CONTRACT, SolidityContract(primaryContract), CVLRange.Empty()), ast.scope
            )
        )

        // Register and traverse "from-user" rules
        // Note that the result of the rule and invariant traversal is used to determine whether to suppress
        // autogenerated-rule exceptions, which is why we store these results in separate variables
        val ruleRegistrationResults = ast.rules.map {
            logger.info { "Traversing rule ${it.declarationId}" }
            registerRuleId(it) { r: IRule ->
                symbolTable.register(
                    r,
                    r.scope.innerScope!!,
                    registerFromUserRules = true,
                    suppressAutoGenRuleExceptions = false
                )
            }.bind(
                traverseRule(
                    it, traverseFromUserRule = true, suppressAutoGenRuleExceptions = false
                )
            )
        }

        val invariantRegistrationResults = ast.invs.map { inv ->
            logger.info { "Traversing invariant ${inv.id}" }
            traverseInvariant(inv)
        }

        // Traverse auto-generated rules (note: this is done after traversing from-user rules and invariants)
        val ruleOrInvariantRegistrationFailed = (ruleRegistrationResults + invariantRegistrationResults).flattenToVoid() is CollectingResult.Error
        ast.rules.mapTo(registrationResults) {
            traverseRule(
                it,
                traverseFromUserRule = false,
                suppressAutoGenRuleExceptions = it.ruleType.isDerived() && ruleOrInvariantRegistrationFailed
            )
        }
        registrationResults += ruleRegistrationResults + invariantRegistrationResults
        ast.sorts.mapTo(registrationResults) { sort ->
            logger.info { "Traversing sort $sort" }
            traverseSort(sort, ast.scope)
        }
        ast.ghosts.mapTo(registrationResults) { ghost ->
            logger.info { "Traversing ghost ${ghost.id}" }
            traverseGhost(ghost)
        }
        ast.definitions.mapTo(registrationResults) { definition ->
            logger.info { "Traversing definition ${definition.id}" }
            traverseDefinition(definition)
        }

        // IMPORTANT: hooks MUST go LAST as we may actually end up renaming variables as a result of _other_ scopes
        // that names here may *or may not* collide with at time of hook inlining
        ast.subs.mapTo(registrationResults) {
            logger.info { "Traversing CVL Function ${it.declarationId}" }
            traverseCVLFunction(it)
        }
        ast.hooks.mapTo(registrationResults) { hook ->
            logger.info { "Traversing hook ${hook.pattern}" }
            traverseHook(hook)
        }

        // Finally, register the ids of auto-generated rules. This comes last as we want to check id collisions
        // against all other elements, and give priority to ids of auto-generated rules over all other ids.
        ast.rules.mapTo(registrationResults) {
            registerRuleId(it) { r: IRule ->
                symbolTable.register(
                    r,
                    r.scope.innerScope!!,
                    registerFromUserRules = false,
                    suppressAutoGenRuleExceptions = r.ruleType.isDerived() && symbolTable.fromUserInvsRulesIdsCollide()
                )
            }
        }

        ast.importedMethods.mapTo(registrationResults) { annot ->
            ((annot as? ConcreteMethodBlockAnnotation)?.summary as? SpecCallSummary.Exp)?.let { exp ->
                val params = exp.funParams.filterIsInstance<VMParam.Named>().map {
                    symbolTable.registerParam(
                        it,
                        when (annot.qualifiers.visibility) {
                            Visibility.INTERNAL -> FromVMContext.InternalSummaryArgBinding
                            Visibility.EXTERNAL -> FromVMContext.ExternalSummaryArgBinding
                        },
                        scope = exp.scope,
                        cvlRange = annot.cvlRange,
                        autoGeneratedScope = false,
                        suppressAutoGenRuleExceptions = true
                    )
                }.flattenToVoid()
                val withArgs = exp.withClause?.let {
                    symbolTable.registerParam(
                        it.param,
                        scope = exp.scope,
                        cvlRange = it.range,
                        autoGeneratedScope = false,
                        suppressAutoGenRuleExceptions = true
                    )
                } ?: ok
                val calledContract = symbolTable.registerCVLKeyword(CVLKeywords.calledContract, exp.scope)
                listOf(params, withArgs, calledContract).flattenToVoid()
            } ?: ok
        }
        return registrationResults.flattenToVoid()
    }

    /**
     * Add identifiers to the symbol table that are visible everywhere without them being declared in the CVL file.
     * (e.g. keywords, methods occurring in the contract), the functions from the methods section are registered here,
     * too.
     *
     * @param functionsFromSpecFileAndContracts imported functions of each contract from [CVLAst]'s "methods" block had to be massaged before
     *   being registered in the symbol table in this method
     */
    private fun registerIdentifiersDeclaredOutsideOfCVLSpec(functionsFromSpecFileAndContracts: Map<ContractInstanceInSDC, List<ContractFunction>>): VoidResult<CVLError> {
        val results = mutableListOf<VoidResult<CVLError>>()
        /** register all cvl keywords at ast scope */
        CVLKeywords.values().mapTo(results) {symbolTable.registerCVLKeyword(it, ast.scope) }

        /** for every contract open a scope    */
        /** register all imported methods at ast scope (lookup returns their result type) */
        functionsFromSpecFileAndContracts.forEach { (contract, functions) ->
            val contractScope = CVLScope.newScope().push(contract)
            val namedContract = SolidityContract(contract.name)
            results.add(symbolTable.addContractScope(namedContract, contractScope).bind {
                if (contract.name == primaryContract) {
                    // Add to the scope table an entry for currentContract so that `currentContract.foo` will also work for
                    // functions in the primary contract.
                    symbolTable.addContractScope(SolidityContract.Current, contractScope)
                } else {
                    ok
                }
            })
            functions.mapTo(results) { importedFunction ->
                check(importedFunction.annotation.visibility == Visibility.EXTERNAL) {
                    "Should only be registering external methods in the symbol table"
                }
                logger.info { "Registering new method from headers $importedFunction in scope $contractScope" }
                symbolTable.register(importedFunction, contractScope)
            }
            contract.solidityTypes
                .filterIsInstance<SolidityTypeDescription.UserDefined>() // Only register user-defined types
                .groupBy { it.qualifiedName }
                .mapNotNullTo(results) { (name, typeDescriptions) ->
                    if (typeDescriptions.mapToSet { it.toUserDefinedCVLType() }.size > 1) {
                        CVLWarningLogger.generalWarning(
                            "Type $name has several conflicting declarations, this type will not be usable within CVL. Definition sites:\n\t" +
                                typeDescriptions.joinToString("\n\t") { it.canonicalId }
                        )
                        return@mapNotNullTo null
                    }

                    // only types declared in this contract should be registered, none from super contracts
                    // a null contractName indicates that the type was declared at the file level--in this case
                    // we import it (which means those imported in super contracts will be available--pretty sure)
                    // a null toCVLType() means we aren't supporting that type yet
                    val type = typeDescriptions.first()
                    type.toUserDefinedCVLType().resultOrNull()?.let { theType ->
                        symbolTable.register(ContractTypeDefinition(type.qualifiedName, theType), contractScope)
                    }
                }

            val duplicateSlotNames = contract.storageLayout?.let { storage ->
                storage.storage.groupingBy { it.label }.eachCount().filter { it.value > 1 }.keys
            } ?: setOf()
            duplicateSlotNames.forEach { slotName ->
                CVLWarningLogger.generalWarning(
                    "Contract ${contract.name} has multiple storage slots with the same name - $slotName (multiple inheritance could cause this), " +
                        "they will be ignored"
                )
            }

            contract.storageLayout?.toTACStorageLayout()?.slots?.let { slots ->
                slots.filter { it.key !in duplicateSlotNames }.mapTo(results) { (slot, type) ->
                    type.typeDescriptor?.let { _ ->
                        symbolTable.register(namedContract, slot, type.typeDescriptor)
                    } ?: ok
                }
            }

            contract.immutables.distinctBy { it.varname }
                .forEach { immutable ->
                    val type = immutable.type
                    symbolTable.registerImmutable(namedContract, immutable.varname, type.toVMTypeDescriptor())
                }
        }
        return results.flattenToVoid()
    }

    private fun traverseInvariant(inv: CVLInvariant): VoidResult<CVLError> {
        val collisionResult = mutableListOf<VoidResult<CVLError>>()
        inv.params.mapTo(collisionResult) { param ->
            logger.info { "Registering param $param in ${inv.scope}" }
            symbolTable.registerParam(param, inv.scope, inv.cvlRange).map(
                inv.proof.preserved.map { preserve ->
                    symbolTable.registerParam(param, preserve.scope, preserve.cvlRange)
                }.flattenToVoid()
            )
        }

        inv.proof.preserved.mapTo(collisionResult) { preserve ->
            // Note that we're not using the `namedParam` field because that one skips unnamed params, but we want
            // to catch those here
            preserve.withParams.map { param ->
                symbolTable.registerParam(param, preserve.scope, preserve.cvlRange)
            }.flattenToVoid().bind(
            preserve.params.map { param ->
                symbolTable.registerParam(param, preserve.scope, preserve.cvlRange)
            }.flattenToVoid())
        }

        inv.proof.preserved.flatMapTo(collisionResult) { preserve ->
            preserve.block.map { cmd ->
                traverseCmd(
                    cmd,
                    autoGeneratedScope = false,
                    suppressAutoGenRuleExceptions = false
                )
            }
        }

        return collisionResult.flattenToVoid().bind { symbolTable.register(inv, ast.scope) }
    }

    /**
     * Returns a [CVLError] if a method parameter has the same name as a function of one of the contracts in the scene.
     */
    private fun verifyMethodParamIsNotContractFunction(param: CVLParam, range: CVLRange, source: String): VoidResult<CVLError> = collectingErrors {
        if (param.type != EVMBuiltinTypes.method) { return@collectingErrors }
        contractToItsFunctionsFromSpecAndContract.forEach { (contract, functions) ->
            functions.forEach {
                if (it.methodSignature.functionName == param.id) {
                    returnError(CVLError.General(
                        range,
                        "The $source parameter name `${param.id}` coincides with a method name in contract `${contract.name}`"
                    ))
                }
            }
        }
    }

    private fun traverseCVLFunction(sub: CVLFunction): VoidResult<CVLError> {
        return sub.params.map { param ->
            logger.info { "Registering subroutine param $param in ${sub.scope}" }
            verifyMethodParamIsNotContractFunction(param, sub.cvlRange, "function").bind {
                symbolTable.registerParam(param, sub.scope, sub.cvlRange)
            }
        }.flattenToVoid().bind {
            sub.block.map { cmd ->
                traverseCmd(cmd, autoGeneratedScope = false, suppressAutoGenRuleExceptions = false)
            }.flattenToVoid()
        }.bind {
            symbolTable.register(sub, ast.scope)
        }
    }

    private fun traverseRule(
        rule: IRule,
        traverseFromUserRule: Boolean,
        suppressAutoGenRuleExceptions: Boolean
    ): VoidResult<CVLError> =
        when (rule) {
            is CVLSingleRule -> {
                if (traverseFromUserRule && rule.ruleType.isFromUser()) { // traverse from-user rule
                    traverseRule(rule, suppressAutoGenRuleExceptions = suppressAutoGenRuleExceptions)
                } else if (!traverseFromUserRule && !rule.ruleType.isFromUser()) { // traverse auto-generated rule
                    traverseRule(rule, suppressAutoGenRuleExceptions = suppressAutoGenRuleExceptions)
                } else {
                    ok
                }
            }
            is GroupRule -> {
                rule.rules.map {
                    traverseRule(
                        it,
                        traverseFromUserRule,
                        suppressAutoGenRuleExceptions
                    )
                }.flattenToVoid()
            }
            is AssertRule, // nothing to traverse in it
            is StaticRule -> { // nothing to traverse in it
                ok
            }
        }

    private fun registerRuleId(rule: IRule, registerRuleOp: (IRule) -> VoidResult<CVLError>): VoidResult<CVLError> {
        return when (rule) {
            is GroupRule -> {
                rule.rules.map { registerRuleId(it, registerRuleOp) }.flattenToVoid()
            }
            is CVLSingleRule, is AssertRule, is StaticRule -> {
                ok
            }
        }.bind(registerRuleOp(rule))
    }


    private fun traverseRule(
        rule: CVLSingleRule,
        suppressAutoGenRuleExceptions: Boolean
    ): VoidResult<CVLError> {
            val paramsToIdCollisions = rule.params.map { param ->
                logger.info { "Registering rule param $param in ${rule.scope}" }
                verifyMethodParamIsNotContractFunction(param, rule.cvlRange, "rule").bind {
                    symbolTable.registerParam(
                        param,
                        rule.scope,
                        rule.cvlRange,
                        autoGeneratedScope = !rule.ruleType.isFromUser(),
                        suppressAutoGenRuleExceptions = suppressAutoGenRuleExceptions
                    )
                }
        }.flattenToVoid()
        val traversedBlockResults = rule.block.map { cmd ->
            traverseCmd(
                cmd,
                autoGeneratedScope = !rule.ruleType.isFromUser(),
                suppressAutoGenRuleExceptions = suppressAutoGenRuleExceptions
            )
        }.flattenToVoid()

        return paramsToIdCollisions.map(traversedBlockResults)
    }

    /**
     * @param autoGeneratedScope whether [cmd] is in a scope of an auto-generated rule (rather than a from-user rule)
     * @param suppressAutoGenRuleExceptions whether the tool should throw an exception if there is a collision within generated rules
     */
    private fun traverseCmd(
        cmd: CVLCmd,
        autoGeneratedScope: Boolean,
        suppressAutoGenRuleExceptions: Boolean
    ): VoidResult<CVLError> {
        logger.info { "Traversing $cmd" }
        return when (cmd) {
            is CVLCmd.Composite.Block -> {
                cmd.block.map { traverseCmd(it, autoGeneratedScope, suppressAutoGenRuleExceptions) }.flattenToVoid()
            }
            is CVLCmd.Simple.Declaration -> {
                symbolTable.register(
                    cmd,
                    cmd.scope,
                    autoGeneratedScope = autoGeneratedScope,
                    suppressAutoGenRuleExceptions = suppressAutoGenRuleExceptions
                )
            }
            is CVLCmd.Simple.Definition -> {
                if (cmd.type != null) {
                    symbolTable.register(
                        cmd,
                        cmd.scope,
                        autoGeneratedScope = autoGeneratedScope,
                        suppressAutoGenRuleExceptions = suppressAutoGenRuleExceptions
                    )
                } else {
                    ok
                }
            }
            is CVLCmd.Composite.If -> {
                val traversedThenCmdResult = traverseCmd(cmd.thenCmd, autoGeneratedScope, suppressAutoGenRuleExceptions)
                val traversedElseCmdResult = traverseCmd(cmd.elseCmd, autoGeneratedScope, suppressAutoGenRuleExceptions)
                traversedThenCmdResult.map(traversedElseCmdResult)
            }
            else -> {
                ok
            }
        }
    }

    private fun traverseSort(sort: SortDeclaration, scope: CVLScope): VoidResult<CVLError> {
        return symbolTable.register(sort, scope)
    }

    private fun traverseGhost(ghost: CVLGhostDeclaration): VoidResult<CVLError> {
        return symbolTable.register(ghost, ghost.scope)
    }

    private fun traverseDefinition(definition: CVLDefinition): VoidResult<CVLError> {
        return symbolTable.register(definition, definition.scope!!)
    }

    private fun traverseHook(hook: CVLHook): VoidResult<CVLError> {
        return traverseHookPattern(hook.pattern, hook.scope, hook.cvlRange).map(
            hook.block.map {
                traverseCmd(
                    it, autoGeneratedScope = false, suppressAutoGenRuleExceptions = true
                )
            }.flattenToVoid()
        )
    }

    private fun traverseHookPattern(hookPattern: CVLHookPattern, scope: CVLScope, cvlRange: CVLRange) : VoidResult<CVLError> {
        val initialRes =
            when (hookPattern) {
                is CVLHookPattern.StoragePattern -> {
                    symbolTable.registerParam(hookPattern.value, FromVMContext.HookValue, scope, cvlRange)
                    if (hookPattern is CVLHookPattern.StoragePattern.Store && hookPattern.previousValue != null) {
                        symbolTable.registerParam(hookPattern.previousValue, FromVMContext.HookValue, scope, cvlRange)
                    } else {
                        ok
                    }
                }
                is CVLHookPattern.Create -> symbolTable.registerParam(hookPattern.value, FromVMContext.HookValue, scope, cvlRange)
                is CVLHookPattern.Opcode -> {
                    hookPattern.params.map {
                        symbolTable.registerParam(it, FromVMContext.HookValue, scope, cvlRange)
                    }.flattenToVoid().bind(
                        if (hookPattern is PatternWithValue) {
                            symbolTable.registerParam(hookPattern.value, FromVMContext.HookValue, scope, cvlRange)
                        } else {
                            ok
                        },
                        symbolTable.registerCVLKeyword(
                            CVLKeywords.executingContract, scope
                        ),
                        if(hookPattern is OpcodeHookWithEnv) {
                            hookPattern.environmentParams().map {
                                symbolTable.registerParam(it, FromVMContext.HookValue, scope, cvlRange)
                            }.flattenToVoid()
                        } else {
                            ok
                        }
                    )
                }
            }

        fun traverseSlotPattern(slotPattern: CVLSlotPattern): VoidResult<CVLError> = when (slotPattern) {
            is CVLSlotPattern.MapAccess -> {
                symbolTable.registerParam(slotPattern.key, FromVMContext.HookValue, scope, cvlRange).map(
                    traverseSlotPattern(slotPattern.base)
                )
            }
            is CVLSlotPattern.ArrayAccess -> {
                symbolTable.registerParam(slotPattern.index, FromVMContext.HookValue, scope, cvlRange).map(
                    traverseSlotPattern(slotPattern.base)
                )
            }
            is CVLSlotPattern.StructAccess -> {
                traverseSlotPattern(slotPattern.base)
            }
            is CVLSlotPattern.Static -> { /* Nothing to do */
                ok
            }
            is CVLSlotPattern.FieldAccess -> traverseSlotPattern(slotPattern.base)
        }

        return initialRes.bind {
            if (hookPattern is CVLHookPattern.StoragePattern) {
                traverseSlotPattern(hookPattern.slot)
            } else {
                ok
            }
        }
    }
}
