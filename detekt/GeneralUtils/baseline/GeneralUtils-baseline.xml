<?xml version="1.0" encoding="UTF-8"?><SmellBaseline>
    <CurrentIssues>
        <ID>BracesOnIfStatements:ArrayHashTable.kt$&lt;no name provided&gt;$if</ID>
        <ID>BracesOnIfStatements:Bijection.kt$Bijection$if</ID>
        <ID>BracesOnIfStatements:Bijection.kt$MutableBijection$if</ID>
        <ID>BracesOnIfStatements:Color.kt$Color$else</ID>
        <ID>BracesOnIfStatements:Color.kt$Color$if</ID>
        <ID>BracesOnIfStatements:Configurable.kt$CLIParser$if</ID>
        <ID>BracesOnIfStatements:EVMOps.kt$EVMOps$else</ID>
        <ID>BracesOnIfStatements:EVMOps.kt$EVMOps$if</ID>
        <ID>BracesOnIfStatements:ExtStdlib.kt$else</ID>
        <ID>BracesOnIfStatements:Iterables.kt$else</ID>
        <ID>BracesOnIfStatements:Iterables.kt$if</ID>
        <ID>BracesOnIfStatements:LazyCrossProduct.kt$LazyCrossProduct$if</ID>
        <ID>BracesOnIfStatements:Maps.kt$else</ID>
        <ID>BracesOnIfStatements:Maps.kt$if</ID>
        <ID>BracesOnIfStatements:NFA.kt$NFA$if</ID>
        <ID>BracesOnIfStatements:PersistentStack.kt$else</ID>
        <ID>BracesOnIfStatements:PersistentStack.kt$if</ID>
        <ID>BracesOnIfStatements:Sets.kt$else</ID>
        <ID>BracesOnIfStatements:Sets.kt$if</ID>
        <ID>BracesOnIfStatements:SmallList.kt$SmallList$if</ID>
        <ID>BracesOnIfStatements:SmallList.kt$SmallList.Of1$else</ID>
        <ID>BracesOnIfStatements:SmallList.kt$SmallList.Of1$if</ID>
        <ID>BracesOnIfStatements:SmallList.kt$SmallList.Of2$else</ID>
        <ID>BracesOnIfStatements:SmallList.kt$SmallList.Of2$if</ID>
        <ID>BracesOnIfStatements:SmallList.kt$SmallList.Of3$else</ID>
        <ID>BracesOnIfStatements:SmallList.kt$SmallList.Of3$if</ID>
        <ID>BracesOnIfStatements:SmallList.kt$SmallList.Of4$else</ID>
        <ID>BracesOnIfStatements:SmallList.kt$SmallList.Of4$if</ID>
        <ID>BracesOnIfStatements:SmallList.kt$SmallList.Of5$else</ID>
        <ID>BracesOnIfStatements:SmallList.kt$SmallList.Of5$if</ID>
        <ID>BracesOnIfStatements:SolverConfig.kt$SolverConfig$else</ID>
        <ID>BracesOnIfStatements:SolverConfig.kt$SolverConfig$if</ID>
        <ID>BracesOnIfStatements:smt.CEGARConfig.WorkerConfig_dynamicConversion.kt$if</ID>
        <ID>BracesOnIfStatements:smt.CEGARConfig_dynamicConversion.kt$if</ID>
        <ID>BracesOnIfStatements:solver.SolverConfig_dynamicConversion.kt$if</ID>
        <ID>ForbiddenComment:Converter.kt$// (tokenized_list.count() != tokenized_list.distinct().count()) // we may want to log this, TODO</ID>
        <ID>ForbiddenMethodCall:ArtifactFileUtils.kt$ArtifactFileUtils$!in</ID>
        <ID>ForbiddenMethodCall:ArtifactFileUtils.kt$ArtifactFileUtils$Regex(separators)</ID>
        <ID>ForbiddenMethodCall:ArtifactFileUtils.kt$ArtifactFileUtils$split(Regex(separators))</ID>
        <ID>ForbiddenMethodCall:BitwuzlaSolverInfo.kt$BitwuzlaSolverInfo$startsWith("[bitwuzla&gt;main] ALARM TRIGGERED: time limit ")</ID>
        <ID>ForbiddenMethodCall:Configurable.kt$CLIParser$in</ID>
        <ID>ForbiddenMethodCall:Configurable.kt$CLIParser$startsWith(e)</ID>
        <ID>ForbiddenMethodCall:Configurable.kt$Configuration$split(':')</ID>
        <ID>ForbiddenMethodCall:Converter.kt$split(",")</ID>
        <ID>ForbiddenMethodCall:ExtStdlib.kt$split(System.lineSeparator())</ID>
        <ID>ForbiddenMethodCall:ExtStdlib.kt$toRegex()</ID>
        <ID>ForbiddenMethodCall:TestParallel.kt$println(end - start)</ID>
        <ID>ForbiddenMethodCall:TestParallel.kt$println(res)</ID>
        <ID>ImportStdCollections:AltErgoSolverInfo.kt$AltErgoSolverInfo$+</ID>
        <ID>ImportStdCollections:AltErgoSolverInfo.kt$AltErgoSolverInfo$listOf</ID>
        <ID>ImportStdCollections:ArtifactFileUtils.kt$ArtifactFileUtils$listOf</ID>
        <ID>ImportStdCollections:Bijection.kt$Bijection$mutableMapOf</ID>
        <ID>ImportStdCollections:BitwuzlaSolverInfo.kt$BitwuzlaSolverInfo$+</ID>
        <ID>ImportStdCollections:BitwuzlaSolverInfo.kt$BitwuzlaSolverInfo$listOf</ID>
        <ID>ImportStdCollections:BitwuzlaSolverInfo.kt$BitwuzlaSolverInfo$setOf</ID>
        <ID>ImportStdCollections:CEGARConfig.kt$CEGARConfig$listOf</ID>
        <ID>ImportStdCollections:CEGARConfig.kt$CEGARConfig.Companion$listOf</ID>
        <ID>ImportStdCollections:CEGARConfig.kt$CEGARConfig.WorkerConfig.Companion$listOf</ID>
        <ID>ImportStdCollections:Graph.kt$Graph$mutableSetOf</ID>
        <ID>ImportStdCollections:Graph.kt$MutableSparseLabelledGraph$mutableMapOf</ID>
        <ID>ImportStdCollections:Graph.kt$MutableSparseLabelledGraph$toSet</ID>
        <ID>ImportStdCollections:MutableReversibleMap.kt$MutableReversibleMap$forEach</ID>
        <ID>ImportStdCollections:MutableReversibleMap.kt$MutableReversibleMap$mutableMapOf</ID>
        <ID>ImportStdCollections:NFA.kt$NFA$mutableSetOf</ID>
        <ID>ImportStdCollections:NFA.kt$NFA$setOf</ID>
        <ID>ImportStdCollections:NFA.kt$NFA$toSet</ID>
        <ID>ImportStdCollections:Reachability.kt$listOf</ID>
        <ID>ImportStdCollections:Reachability.kt$toMutableSet</ID>
        <ID>ImportStdCollections:SolverInfo.kt$SolverChoice$toList</ID>
        <ID>ImportStdCollections:SolverInfo.kt$SolverChoice.Companion$+</ID>
        <ID>ImportStdCollections:SolverInfo.kt$SolverChoice.Companion$listOf</ID>
        <ID>ImportStdCollections:SolverInfo.kt$SolverInfo$listOf</ID>
        <ID>ImportStdCollections:SolverInfo.kt$SolverInfo.Companion$mutableMapOf</ID>
        <ID>ImportStdCollections:VampireSolverInfo.kt$VampireSolverInfo$+</ID>
        <ID>ImportStdCollections:VampireSolverInfo.kt$VampireSolverInfo$listOf</ID>
        <ID>ImportStdCollections:YicesSolverInfo.kt$YicesSolverInfo$+</ID>
        <ID>ImportStdCollections:YicesSolverInfo.kt$YicesSolverInfo$listOf</ID>
        <ID>ImportStdCollections:smt.CEGARConfig.WorkerConfig_dynamicConversion.kt$forEach</ID>
        <ID>ImportStdCollections:smt.CEGARConfig.WorkerConfig_dynamicConversion.kt$toMutableMap</ID>
        <ID>ImportStdCollections:smt.CEGARConfig_dynamicConversion.kt$forEach</ID>
        <ID>ImportStdCollections:smt.CEGARConfig_dynamicConversion.kt$toMutableMap</ID>
        <ID>ImportStdCollections:solver.SolverConfig_dynamicConversion.kt$forEach</ID>
        <ID>ImportStdCollections:solver.SolverConfig_dynamicConversion.kt$toMutableMap</ID>
        <ID>SwallowedException:Configurable.kt$CLIParser$e: ConfigurationException</ID>
        <ID>ThrowingExceptionsWithoutMessageOrCause:SmallList.kt$SmallList$IndexOutOfBoundsException()</ID>
        <ID>TooGenericExceptionCaught:BigIntegerSerializer.kt$BigIntegerSerializer$e: Exception</ID>
        <ID>TooGenericExceptionThrown:ArtifactFileUtils.kt$ArtifactFileUtils$throw Exception("Could not find $newRootDir in $wholePath")</ID>
        <ID>TooGenericExceptionThrown:ArtifactFileUtils.kt$ArtifactFileUtils$throw Exception("Failed to create directory $dirString")</ID>
        <ID>TooGenericExceptionThrown:BigIntegerSerializer.kt$BigIntegerSerializer$throw Exception(msg, e)</ID>
        <ID>UseAnyOrNoneInsteadOfFind:ExtStdlib.kt$firstOrNull()</ID>
        <ID>UseIsNullOrEmpty:smt.CEGARConfig.WorkerConfig_dynamicConversion.kt$overrides == null || overrides.isEmpty()</ID>
        <ID>UseIsNullOrEmpty:smt.CEGARConfig_dynamicConversion.kt$overrides == null || overrides.isEmpty()</ID>
        <ID>UseIsNullOrEmpty:solver.SolverConfig_dynamicConversion.kt$overrides == null || overrides.isEmpty()</ID>
        <ID>UseOrEmpty:Configurable.kt$Configuration$name?.split(':')?.toTypedArray() ?: arrayOf()</ID>
        <ID>UseOrEmpty:MultiMap.kt$EdgeLabeledGraph$backing[v] ?: emptySet()</ID>
        <ID>UseOrEmpty:MultiMap.kt$UndirectedGraph$backing[v] ?: emptySet()</ID>
        <ID>UseOrEmpty:TarjanSCCFinding.kt$TarjanSCCFinding$g[v.t] ?: emptySet()</ID>
    </CurrentIssues>
</SmellBaseline>
