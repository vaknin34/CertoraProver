<?xml version="1.0" encoding="UTF-8"?><SmellBaseline>
    <CurrentIssues>
        <ID>BracesOnIfStatements:CVLAst.kt$CVLCmd.Simple.Definition$else</ID>
        <ID>BracesOnIfStatements:CVLAst.kt$CVLCmd.Simple.Definition$if</ID>
        <ID>BracesOnIfStatements:CVLAst.kt$CVLExp.ApplyExp.ContractFunction.Concrete$else</ID>
        <ID>BracesOnIfStatements:CVLAst.kt$CVLExp.ApplyExp.ContractFunction.Concrete$if</ID>
        <ID>BracesOnIfStatements:CVLAst.kt$CVLExp.ApplyExp.ContractFunction.Symbolic$else</ID>
        <ID>BracesOnIfStatements:CVLAst.kt$CVLExp.ApplyExp.ContractFunction.Symbolic$if</ID>
        <ID>BracesOnIfStatements:CVLAst.kt$CVLExp.Constant.BoolLit$else</ID>
        <ID>BracesOnIfStatements:CVLAst.kt$CVLExp.Constant.BoolLit$if</ID>
        <ID>BracesOnIfStatements:CVLAst.kt$CVLExp.QuantifierExp$else</ID>
        <ID>BracesOnIfStatements:CVLAst.kt$CVLExp.QuantifierExp$if</ID>
        <ID>BracesOnIfStatements:CVLExpTypeChecker.kt$CVLExpTypeCheckerWithContext$else</ID>
        <ID>BracesOnIfStatements:CVLExpTypeChecker.kt$CVLExpTypeCheckerWithContext$if</ID>
        <ID>BracesOnIfStatements:CVLSymbolTable.kt$CVLSymbolTable$else</ID>
        <ID>BracesOnIfStatements:CommandLineExecutor.kt$else</ID>
        <ID>BracesOnIfStatements:CommandLineExecutor.kt$if</ID>
        <ID>BracesOnIfStatements:Config.kt$Config$if</ID>
        <ID>BracesOnIfStatements:ConfigRegister.kt$ConfigRegister$else</ID>
        <ID>BracesOnIfStatements:ConfigRegister.kt$ConfigRegister$if</ID>
        <ID>BracesOnIfStatements:Method.kt$Method$else</ID>
        <ID>BracesOnIfStatements:Method.kt$Method$if</ID>
        <ID>BracesOnIfStatements:MethodAttribute.kt$MethodAttribute.Unique.Companion$if</ID>
        <ID>BracesOnIfStatements:Tag.kt$Tag.Map.Companion$else</ID>
        <ID>BracesOnIfStatements:Tag.kt$Tag.Map.Companion$if</ID>
        <ID>BracesOnIfStatements:TreeViewPath.kt$TreeViewPathNode.Rule$if</ID>
        <ID>CVLErrorsNeedDocs:CVLError.kt$CVLError.Exp$Exp</ID>
        <ID>CVLErrorsNeedDocs:CVLError.kt$CVLError.General$General</ID>
        <ID>CVLErrorsNeedDocs:CVLError.kt$CVLError.Lhs$Lhs</ID>
        <ID>DataClassShouldBeImmutable:CVLAst.kt$CVLDefinition$var modifies: Set&lt;CVLGhostFunction&gt;</ID>
        <ID>DataClassShouldBeImmutable:CVLAst.kt$CVLDefinition$var reads: Set&lt;CVLGhostFunction&gt;</ID>
        <ID>Deprecation:AbstractTypeResolver.kt$AbstractTypeResolver$General</ID>
        <ID>Deprecation:CVLASTBuilder.kt$CVLAstBuilder$General</ID>
        <ID>Deprecation:CVLASTBuilder.kt$CVLAstBuilder.&lt;no name provided&gt;$General</ID>
        <ID>Deprecation:CVLAstAdditionalChecks.kt$CVLAstAdditionalChecks$Exp</ID>
        <ID>Deprecation:CVLAstAdditionalChecks.kt$CVLAstAdditionalChecks.&lt;no name provided&gt;$Exp</ID>
        <ID>Deprecation:CVLAstAdditionalChecks.kt$CVLAstAdditionalChecks.&lt;no name provided&gt;$General</ID>
        <ID>Deprecation:CVLAstUtil.kt$GenerateRulesForInvariantsAndEnvFree$General</ID>
        <ID>Deprecation:CVLCmdTypeChecker.kt$CVLCmdTypeChecker$Exp</ID>
        <ID>Deprecation:CVLCmdTypeChecker.kt$CVLCmdTypeChecker$General</ID>
        <ID>Deprecation:CVLExpTypeChecker.kt$CVLExpTypeCheckerWithContext$Exp</ID>
        <ID>Deprecation:CVLExpTypeChecker.kt$CVLExpTypeCheckerWithContext$General</ID>
        <ID>Deprecation:CVLExpTypeChecker.kt$CVLExpTypeCheckerWithContext$Lhs</ID>
        <ID>Deprecation:CVLExpTypeChecker.kt$CVLExpTypeCheckerWithContext.Companion$Exp</ID>
        <ID>Deprecation:CVLHookTypeChecker.kt$CVLHookTypeChecker$General</ID>
        <ID>Deprecation:CVLInput.kt$CVLInput.Companion$General</ID>
        <ID>Deprecation:CVLInput.kt$CVLInput.Plain$General</ID>
        <ID>Deprecation:CVLInput.kt$CVLInput.WithImportedSpecs$General</ID>
        <ID>Deprecation:CVLMethodsBlockTypeChecker.kt$CVLMethodsBlockTypeChecker$Exp</ID>
        <ID>Deprecation:CVLMethodsBlockTypeChecker.kt$CVLMethodsBlockTypeChecker$General</ID>
        <ID>Deprecation:CVLParamTypeChecker.kt$CVLParamTypeChecker$General</ID>
        <ID>Deprecation:CVLRuleAndMethodChoiceValidation.kt$General</ID>
        <ID>Deprecation:CVLSymbolTable.kt$CVLSymbolTable$General</ID>
        <ID>Deprecation:CVLSymbolTable.kt$CVLSymbolTable.SymbolInfo.CVLFunctionInfo$General</ID>
        <ID>Deprecation:CVLTypeChecker.kt$CVLAstTypeChecker$Exp</ID>
        <ID>Deprecation:CVLTypeChecker.kt$CVLAstTypeChecker$General</ID>
        <ID>Deprecation:CVLTypeTypeChecker.kt$CVLTypeTypeChecker$Exp</ID>
        <ID>Deprecation:CVLTypeTypeChecker.kt$CVLTypeTypeChecker$General</ID>
        <ID>Deprecation:DeepSanityGenerator.kt$DeepSanityGenerator$General</ID>
        <ID>Deprecation:DefinitionDependencyChecker.kt$DefinitionDependencyChecker$General</ID>
        <ID>Deprecation:EVMConfig.kt$EVMConfig$General</ID>
        <ID>Deprecation:GeneratedHookHelpers.kt$GeneratedHookHelpers$General</ID>
        <ID>Deprecation:GeneratedOpcodeParsers.kt$GeneratedOpcodeParsers$General</ID>
        <ID>Deprecation:QuantifierChecker.kt$QuantifierChecker$Exp</ID>
        <ID>Deprecation:StorageComparisonChecker.kt$StorageComparisonChecker.&lt;no name provided&gt;$Exp</ID>
        <ID>Deprecation:StorageComparisonChecker.kt$StorageComparisonChecker.&lt;no name provided&gt;.&lt;no name provided&gt;$Exp</ID>
        <ID>Deprecation:SymbolTableFiller.kt$SymbolTableFiller$General</ID>
        <ID>ForbiddenComment:Allocator.kt$Allocator$* TODO: document ... e.g., what's the purpose of this class?</ID>
        <ID>ForbiddenComment:CVLASTBuilder.kt$CVLAstBuilder$// TODO better classification</ID>
        <ID>ForbiddenComment:CVLASTBuilder.kt$CVLAstBuilder.&lt;no name provided&gt;$// TODO: Fix all the signature comparison stuff</ID>
        <ID>ForbiddenComment:CVLAst.kt$CVLTODO$// todo remove me</ID>
        <ID>ForbiddenComment:CVLAst.kt$ContractFunction$//TODO return type???</ID>
        <ID>ForbiddenComment:CVLAst.kt$OverrideDeclaration$// TODO: Naive question: why not keep an instance of T here, to avoid information loss? e.g. of scope</ID>
        <ID>ForbiddenComment:CVLAstUtil.kt$GenerateRulesForInvariantsAndEnvFree$// TODO(jtoman): this is pointless, the constructor doesn't read from calldata...</ID>
        <ID>ForbiddenComment:CVLAstUtil.kt$GenerateRulesForInvariantsAndEnvFree$//TODO: unique name per function or merge to single rule</ID>
        <ID>ForbiddenComment:CVLExpTypeChecker.kt$CVLExpTypeCheckerWithContext$/* TODO(jtoman): revisit the use of host here */</ID>
        <ID>ForbiddenComment:CVLExpTypeChecker.kt$CVLExpTypeCheckerWithContext$// TODO: do we actually use the CodeContract type?</ID>
        <ID>ForbiddenComment:CVLHookTypeChecker.kt$CVLHookTypeChecker$// TODO(jtoman): *awful* error</ID>
        <ID>ForbiddenComment:CVLHookTypeChecker.kt$CVLHookTypeChecker$// new case for returning something todo revise</ID>
        <ID>ForbiddenComment:CVLInput.kt$CVLInput.Companion$// TODO Merge: Config.prependInternalDir(cvlFile)</ID>
        <ID>ForbiddenComment:CVLKeywords.kt$CVLKeywords$//// Blockhash("blockhash", null, ), // TODO needs a CVL functiontype</ID>
        <ID>ForbiddenComment:CVLReservedVariables.kt$CVLReservedVariables$* variable names/function names that we use internally -- we could/should/do avoid name clashes using this list * * TODO: how is this tied to CVL? apparently it's used in TAC as well? see, e.g. [toVar] method...</ID>
        <ID>ForbiddenComment:CVLScope.kt$CVLScope$// TODO(jtoman): don't use the hash code for the scope id you dummy</ID>
        <ID>ForbiddenComment:CVLSymbolTable.kt$CVLSymbolTable$* TODO Nicer would be for CVL keywords to have their own class</ID>
        <ID>ForbiddenComment:CVLSymbolTable.kt$CVLSymbolTable$// allowed to use certorafallback_0 due to invoke_fallback. TODO improve</ID>
        <ID>ForbiddenComment:CVLSymbolTable.kt$CVLSymbolTable.SymbolInfo.CVLFunctionIdentifierInfo$ used for storing the value of [CVLExp.Constant.SignatureLiteralExp] * TODO: maybe this could be merged with/purpose could be fulfilled by [CVLFunctionInfo] * </ID>
        <ID>ForbiddenComment:CVLSymbolTable.kt$CVLSymbolTable.SymbolInfo.CVLFunctionIdentifierInfo$// TODO(jtoman): we went from struct literal to type, why?</ID>
        <ID>ForbiddenComment:CVLSymbolTable.kt$CVLSymbolTable.SymbolInfo.CVLFunctionInfo$/* TODO(jtoman): I do not think this merging use case is compelling: we do all our merging elsewhere */</ID>
        <ID>ForbiddenComment:CVLSymbolTable.kt$CVLSymbolTable.SymbolInfo.CVLFunctionInfo$// TODO: it seems to happen that we add the same function overloading several times only with flipped envfree --&gt; investigate...</ID>
        <ID>ForbiddenComment:CVLType.kt$CVLType.PureCVLType.Bottom$// throw UnsupportedOperationException() // todo what about wildcards // throws in DSA on CVL keywords</ID>
        <ID>ForbiddenComment:CVLType.kt$CVLType.PureCVLType.Struct$// TODO: Should we have explicit toString()s for all types here? in particular ones expressible</ID>
        <ID>ForbiddenComment:CVLType.kt$EVMBuiltinTypes$// TODO Merge: bytesblob is now Tag.Bit256</ID>
        <ID>ForbiddenComment:CVLTypeChecker.kt$CVLAstTypeChecker$// nothing to type check here? TODO</ID>
        <ID>ForbiddenComment:CVLTypeChecker.kt$CVLAstTypeChecker$// nothing to type check? TODO</ID>
        <ID>ForbiddenComment:CVLTypeEnvCleanser.kt$CVLTypeEnvCleanser$// TODO(jtoman): this is right?</ID>
        <ID>ForbiddenComment:CertoraConf.kt$CertoraConf$// TODO: Make this strict again, on purpose changed to support changing formats</ID>
        <ID>ForbiddenComment:CertoraConf.kt$CertoraConf$// should we make this non-strict to make it more backward compatible? TODO in the end should be strict</ID>
        <ID>ForbiddenComment:Config.kt$Config$ Get a solver timeout that respects the global timeout -- leading to more graceful shutdowns in some cases. * (This is a very lightweight-but-partial solution to the soft timeout problem.) * TODO: this isn't queried at just the right time right now -- it's queried at job creation time, but should be queried at solver start time .. (since the parallel job may have to wait its turn) </ID>
        <ID>ForbiddenComment:Config.kt$Config$// Log scale BigInteger.TWO.pow(4).toInt() // 16 // 16 is a nice number because it is 0x10 in hexa so cexs' are readable // TODO : (1) affects cache</ID>
        <ID>ForbiddenComment:Config.kt$Config$// TODO(sg): consider grouping in sub-objects?</ID>
        <ID>ForbiddenComment:DefinitionDependencyChecker.kt$DefinitionDependencyChecker$// TODO: would a different topo sort allow us to infer where the cycle is?</ID>
        <ID>ForbiddenComment:FunctionHashes.kt$// TODO: change from String to BigInteger</ID>
        <ID>ForbiddenComment:FunctionHashes.kt$SolidityFunctionStateMutability.Companion$// TODO: Default should allow for both "view" and "non view", "pure" and "non pure" (how to encode that pure is also view?)</ID>
        <ID>ForbiddenComment:IScene.kt$ISceneIdentifiers$// TODO: handle in cached</ID>
        <ID>ForbiddenComment:LongProcessKiller.kt$LongProcessKiller$/* This filter does not work for some reason in conjunction with /IM flag. TODO: Run tasklist instead with the '/FI "IMAGENAME eq dot*"' flag instead, and parse PIDs. Kill each PID */</ID>
        <ID>ForbiddenComment:Method.kt$Method$// TODO: make this an enum, no strings from solidity should propagate into the tool</ID>
        <ID>ForbiddenComment:NBId.kt$BlockIdentifier.Companion$// TODO: Must be updated if number of fields changes</ID>
        <ID>ForbiddenComment:QualifiedFunctionName.kt$ExternalQualifiedMethodParameterSignature.ExternalQualifiedMethodParamSig$* Canonical representation of a [ExternalQualifiedMethodParameterSignature] -- omits names of params (if there are any) * e.g. foo(uint) instead of foo(uint x). * * TODO(jtoman): this is probably still wrong, because this doesn't yield an actually correct canonical name</ID>
        <ID>ForbiddenComment:QualifiedFunctionName.kt$QualifiedMethodParameterSignature$* Pretty printing of a [QualifiedMethodParameterSignature] -- omits names of params (if there are any) * e.g. foo(uint) instead of foo(uint x). * * TODO(jtoman): this is probably still wrong, because this doesn't yield an actually correct canonical name</ID>
        <ID>ForbiddenComment:QualifiedFunctionName.kt$UniqueMethod$* A concrete method which is uniquely identified (and thus is a [ResolvedContractCall] via [ConcreteContractMethod]. * * For convenience, implements the [QualifiedMethodSignature] interface, so as to provide return/param information (always the * empty lists) * * TODO(jtoman): does this need to be a method signature???</ID>
        <ID>ForbiddenComment:SolcType.kt$SolcType$// TODO: SolidtyStorageTypeDescription</ID>
        <ID>ForbiddenComment:SolidityParserTools.kt$ABI$// TODO: Check default - did not find</ID>
        <ID>ForbiddenMethodCall:CVLSymbolTable.kt$CVLSymbolTable$startsWith(CVLReservedVariables.prefix)</ID>
        <ID>ForbiddenMethodCall:CVLType.kt$CVLType.Companion$startsWith("bytes")</ID>
        <ID>ForbiddenMethodCall:CVLType.kt$CVLType.Companion$startsWith("int")</ID>
        <ID>ForbiddenMethodCall:CVLType.kt$CVLType.Companion$startsWith("uint")</ID>
        <ID>ForbiddenMethodCall:Config.kt$Config$startsWith(it.toFilenamePrefix().lowercase() + OUTPUT_NAME_DELIMITER)</ID>
        <ID>ForbiddenMethodCall:Config.kt$Config.&lt;no name provided&gt;$Regex("[a-zA-Z0-9_]+")</ID>
        <ID>ForbiddenMethodCall:ConfigType.kt$ConfigType.ExecName$contains(File.separator)</ID>
        <ID>ForbiddenMethodCall:ErrorDocGenerator.kt$println(errorListText())</ID>
        <ID>ForbiddenMethodCall:OutPrinter.kt$OutPrinter$println(x)</ID>
        <ID>ForbiddenMethodCall:PerMethodLoadPolicy.kt$PerMethodLoadPolicy$split(",")</ID>
        <ID>ForbiddenMethodCall:PerMethodLoadPolicy.kt$PerMethodLoadPolicy$split(":")</ID>
        <ID>ForbiddenMethodCall:ProverInputPreprocessor.kt$ProverInputPreprocessor$println("Type checking ${verify.primary_contract}")</ID>
        <ID>ForbiddenMethodCall:ReportTypes.kt$ReportTypes$split("_")</ID>
        <ID>ForbiddenMethodCall:SolcType.kt$SolcType$startsWith("contract ")</ID>
        <ID>ForbiddenMethodCall:SolcType.kt$SolcType$startsWith("enum ")</ID>
        <ID>ForbiddenMethodCall:SolidityGlobalData.kt$SrcMapping.Companion$split(":")</ID>
        <ID>ForbiddenMethodCall:SolidityParserTools.kt$ABIComponent$endsWith("]")</ID>
        <ID>ForbiddenMethodCall:SolidityParserTools.kt$ABIComponent$split('.')</ID>
        <ID>ForbiddenMethodCall:SolidityParserTools.kt$ABIComponent$startsWith("address")</ID>
        <ID>ForbiddenMethodCall:SolidityParserTools.kt$ABIComponent$startsWith("contract ")</ID>
        <ID>ForbiddenMethodCall:SolidityParserTools.kt$ABIComponent$startsWith("enum ")</ID>
        <ID>ForbiddenMethodCall:SolidityParserTools.kt$ABIComponent$startsWith("struct ")</ID>
        <ID>ForbiddenMethodCall:SolidityParserTools.kt$ABIComponent$startsWith("tuple")</ID>
        <ID>ForbiddenMethodCall:SolidityParserTools.kt$ABIComponent$toRegex()</ID>
        <ID>ForbiddenMethodCall:SolidityParserTools.kt$split(",")</ID>
        <ID>ForbiddenMethodCall:SolidityParserTools.kt$split(":")</ID>
        <ID>ForbiddenMethodCall:SolidityParserTools.kt$split(";")</ID>
        <ID>ImportStdCollections:AbstractSolcRunner.kt$AbstractSolcRunner$listOf</ID>
        <ID>ImportStdCollections:AbstractSolcRunner.kt$AbstractSolcRunner$mapOf</ID>
        <ID>ImportStdCollections:AbstractSolcRunner.kt$AbstractSolcRunner$setOf</ID>
        <ID>ImportStdCollections:AbstractSolcRunner.kt$AbstractSolcRunner$toMap</ID>
        <ID>ImportStdCollections:AbstractTypeResolver.kt$AbstractTypeResolver$mutableMapOf</ID>
        <ID>ImportStdCollections:Allocator.kt$Allocator$mutableMapOf</ID>
        <ID>ImportStdCollections:CVLAst.kt$MethodParamFilters.Companion$forEach</ID>
        <ID>ImportStdCollections:CVLExpDeclaredSymbolsCollector.kt$CVLExpDeclaredSymbolsCollector$+</ID>
        <ID>ImportStdCollections:CVLExpDeclaredSymbolsCollector.kt$CVLExpDeclaredSymbolsCollector$setOf</ID>
        <ID>ImportStdCollections:CVLExpDeclaredSymbolsCollector.kt$CVLExpDeclaredSymbolsCollector$toSet</ID>
        <ID>ImportStdCollections:CVLExpModifiesReads.kt$CVLExpModifiesReads$mutableSetOf</ID>
        <ID>ImportStdCollections:CVLExpModifiesReads.kt$CVLExpModifiesReads$toSet</ID>
        <ID>ImportStdCollections:CVLInput.kt$CVLInput.WithImportedSpecs$forEach</ID>
        <ID>ImportStdCollections:CVLKeywords.kt$CVLKeywords.Companion$plus</ID>
        <ID>ImportStdCollections:CVLScope.kt$CVLScope$+</ID>
        <ID>ImportStdCollections:CVLScope.kt$CVLScope.Companion$listOf</ID>
        <ID>ImportStdCollections:CVLType.kt$EVMBuiltinTypes$listOf</ID>
        <ID>ImportStdCollections:CVLTypeEnvCleanser.kt$CVLTypeEnvCleanser$mutableMapOf</ID>
        <ID>ImportStdCollections:CVLTypeEnvironment.kt$CVLTypeEnvironment$+</ID>
        <ID>ImportStdCollections:CVLTypeEnvironment.kt$CVLTypeEnvironment.Companion$listOf</ID>
        <ID>ImportStdCollections:CVLTypeTypeChecker.kt$CVLTypeTypeChecker$mutableMapOf</ID>
        <ID>ImportStdCollections:CertoraConf.kt$listOf</ID>
        <ID>ImportStdCollections:CommandLineExecutor.kt$emptyList</ID>
        <ID>ImportStdCollections:ConfigRegister.kt$ConfigRegister$mutableSetOf</ID>
        <ID>ImportStdCollections:EVMConfig.kt$EVMConfig$listOf</ID>
        <ID>ImportStdCollections:EVMConfig.kt$EVMConfig$setOf</ID>
        <ID>ImportStdCollections:Method.kt$Method$listOf</ID>
        <ID>ImportStdCollections:PerMethodLoadPolicy.kt$PerMethodLoadPolicy$mapValues</ID>
        <ID>ImportStdCollections:PerMethodLoadPolicy.kt$PerMethodLoadPolicy$toSet</ID>
        <ID>ImportStdCollections:SolcStandardInput.kt$FileSourceSerializer$listOf</ID>
        <ID>ImportStdCollections:SolcStandardOutput.kt$Contract$listOf</ID>
        <ID>ImportStdCollections:SolcStandardOutput.kt$ContractEVM$mapOf</ID>
        <ID>ImportStdCollections:SolcStandardOutput.kt$Output$listOf</ID>
        <ID>ImportStdCollections:SolcStandardOutput.kt$Output$mapOf</ID>
        <ID>ImportStdCollections:SolcType.kt$SolcType$mutableMapOf</ID>
        <ID>ImportStdCollections:SolidityParserTools.kt$ABI$listOf</ID>
        <ID>ImportStdCollections:SolidityParserTools.kt$ABIComponent$listOf</ID>
        <ID>ImportStdCollections:SolidityParserTools.kt$listOf</ID>
        <ID>ImportStdCollections:SolidityParserTools.kt$mapOf</ID>
        <ID>ImportStdCollections:SubstitutorExp.kt$SubstitutorExp$mutableMapOf</ID>
        <ID>ImportStdCollections:SymbolTableFiller.kt$SymbolTableFiller$forEach</ID>
        <ID>ImportStdCollections:TrivialScene.kt$TrivialScene$listOf</ID>
        <ID>ImportStdCollections:VariableSubstitutor.kt$VariableSubstitutor$mutableMapOf</ID>
        <ID>TooGenericExceptionCaught:BigIntegerDecimalSerializer.kt$BigIntegerDecimalSerializer$e: Exception</ID>
        <ID>TooGenericExceptionCaught:CVLSource.kt$CVLSource.File$e: Exception</ID>
        <ID>TooGenericExceptionCaught:CommandLineExecutor.kt$e: Exception</ID>
        <ID>TooGenericExceptionCaught:LongProcessKiller.kt$LongProcessKiller$e: Exception</ID>
        <ID>TooGenericExceptionCaught:OutPrinter.kt$TimePing$e : Exception</ID>
        <ID>TooGenericExceptionCaught:StandardSolcRunner.kt$StandardSolcRunner$e: Exception</ID>
        <ID>TooGenericExceptionThrown:BigIntegerDecimalSerializer.kt$BigIntegerDecimalSerializer$throw Exception(msg, e)</ID>
        <ID>TooGenericExceptionThrown:CVLAst.kt$CVLExp.RelopExp.CVLERelop.Companion$throw RuntimeException("Illegal relop $s")</ID>
        <ID>TooGenericExceptionThrown:CommandLineExecutor.kt$throw Exception("Failed to run command ($stringCommand), exited with code $exitValue, see errors: ${fileError?.path ?: "N/A"}, output: ${fileOutput?.path ?: "N/A"}. Details: $errors")</ID>
        <ID>TooGenericExceptionThrown:SolidityGlobalData.kt$SrcMapping.Companion$throw Exception("Bad source mapping string $s")</ID>
        <ID>TooGenericExceptionThrown:SolidityParserTools.kt$throw Exception("Invalid srcmap starting with $i (should have 4 components separated by ':'")</ID>
        <ID>TooGenericExceptionThrown:SolidityParserTools.kt$throw Exception("Invalid srcmap starting with $i (should have at least 4 components separated by ':'")</ID>
        <ID>TooGenericExceptionThrown:SolidityParserTools.kt$throw Exception("Invalid srcmap string $i with more than 4 components")</ID>
        <ID>TooGenericExceptionThrown:SolidityParserTools.kt$throw Exception("malformed variable mapping: $mapping, " + "should have exactly 2 elements at $it")</ID>
        <ID>UseOrEmpty:AbstractSolcRunner.kt$AbstractSolcRunner$contract.evm.methodIdentifiers[sig] ?: ""</ID>
    </CurrentIssues>
</SmellBaseline>
